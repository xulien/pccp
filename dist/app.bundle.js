var pccp =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 11);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _nouislider = __webpack_require__(9);\n\nvar _nouislider2 = _interopRequireDefault(_nouislider);\n\nvar _getElement = __webpack_require__(4);\n\nvar _getElement2 = _interopRequireDefault(_getElement);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (pccp, options) {\n\n  // workspace\n  var workspace = (0, _getElement2.default)('div', { id: 'workspace' });\n  var canvas_background = (0, _getElement2.default)('canvas', { id: 'background' });\n  var canvas_clip = (0, _getElement2.default)('canvas', { id: 'mask' });\n\n  canvas_background.style.position = canvas_clip.style.position = 'absolute';\n  canvas_background.style.top = canvas_clip.style.top = 0;\n  canvas_background.style.left = canvas_clip.style.left = 0;\n\n  workspace.appendChild(canvas_background);\n  workspace.style.width = workspace.style.height = options.board.side;\n  workspace.style.position = 'relative';\n  workspace.style['min-width'] = '300px';\n  workspace.style['min-height'] = '300px';\n  workspace.style['background-color'] = 'black';\n  workspace.style.display = 'inline-block';\n  workspace.style['vertical-align'] = 'top';\n  workspace.style.margin = '10px';\n  workspace.style.border = '3px solid black';\n  workspace.appendChild(canvas_clip);\n\n  // dropbox\n  var dropboxLayout = (0, _getElement2.default)('div', { className: 'dropbox-layout' });\n  var dropboxLabel = (0, _getElement2.default)('label', { className: 'dropbox' });\n  var dropbox = (0, _getElement2.default)('input', { id: 'dropbox', type: 'file' });\n  var preview = (0, _getElement2.default)('img', { id: 'preview', alt: 'cliquez ici pour charger une image' });\n\n  preview.style['max-width'] = options.board.side - 5 + 'px';\n  preview.style['max-height'] = options.board.side - 5 + 'px';\n\n  dropbox.style.display = 'none';\n\n  dropboxLabel.style.border = '2px dashed #BBBBBB';\n  dropboxLabel.style['line-height'] = '50px';\n  dropboxLabel.style['text-align'] = 'center';\n  dropboxLabel.style.display = 'inline-block';\n  dropboxLabel.style.padding = '6px';\n  dropboxLabel.style.cursor = 'pointer';\n\n  dropboxLabel.appendChild(dropbox);\n  dropboxLabel.appendChild(preview);\n\n  dropboxLayout.appendChild(dropboxLabel);\n  dropboxLayout.style['min-width'] = dropboxLayout.style['min-height'];\n  dropboxLayout.style.display = 'inline-block';\n  dropboxLayout.style['vertical-align'] = 'top';\n\n  dropboxLabel.style['min-width'] = dropboxLabel.style['min-height'] = options.board.side;\n\n  // control\n  var control = (0, _getElement2.default)('div', { className: 'control' });\n  var board = (0, _getElement2.default)('div', { className: 'board' });\n  var preset = (0, _getElement2.default)('div', { className: 'preset' });\n  var effect = (0, _getElement2.default)('div', { className: 'effect' });\n  var brightness = (0, _getElement2.default)('div', { className: 'brightness' });\n  var moreBrightness = (0, _getElement2.default)('button', { id: 'moreBrightness', text: 'Brightness +' });\n  var lessBrightness = (0, _getElement2.default)('button', { id: 'lessBrightness', text: 'Brightness -' });\n  var level = (0, _getElement2.default)('div', { className: 'level' });\n  var red = (0, _getElement2.default)('div', { id: 'red', className: 'item-level' });\n  var green = (0, _getElement2.default)('div', { id: 'green', className: 'item-level' });\n  var blue = (0, _getElement2.default)('div', { id: 'blue', className: 'item-level' });\n  var clear = (0, _getElement2.default)('button', { id: 'clear', text: 'Clear' });\n  var apply = (0, _getElement2.default)('button', { id: 'apply', text: 'Apply' });\n  var save = (0, _getElement2.default)('button', { id: 'save', text: 'Send' });\n\n  moreBrightness.style.margin = lessBrightness.style.margin = clear.style.margin = apply.style.margin = save.style.margin = '10px';\n\n  moreBrightness.style.width = lessBrightness.style.width = clear.style.width = apply.style.width = save.style.width = '100px';\n\n  moreBrightness.style.height = lessBrightness.style.height = clear.style.height = apply.style.height = save.style.height = '30px';\n\n  red.style.margin = green.style.margin = blue.style.margin = '20px 10px';\n\n  level.style.display = 'flex';\n  level.style['flex-direction'] = 'column';\n  level.style.width = '300px';\n  level.style['margin'] = '35px 25px';\n\n  level.appendChild(red);\n  level.appendChild(green);\n  level.appendChild(blue);\n\n  effect.appendChild(clear);\n  effect.appendChild(apply);\n  effect.appendChild(save);\n\n  brightness.appendChild(moreBrightness);\n  brightness.appendChild(lessBrightness);\n\n  preset.appendChild(brightness);\n\n  board.appendChild(preset);\n  board.appendChild(effect);\n\n  control.appendChild(level);\n  control.appendChild(board);\n\n  control.style.display = 'flex';\n  control.style['background-color'] = 'grey';\n  control.style['min-height'] = '240px';\n  control.style.margin = '10px';\n\n  // pccp\n  pccp.appendChild(workspace);\n  pccp.appendChild(dropboxLayout);\n  pccp.appendChild(control);\n\n  pccp.style.display = 'inline-flex';\n  pccp.style['flex-wrap'] = 'wrap';\n  pccp.style.width = '100%';\n\n  if (red.classList.contains('noUi-target')) red.noUiSlider.destroy();\n  if (green.classList.contains('noUi-target')) green.noUiSlider.destroy();\n  if (blue.classList.contains('noUi-target')) blue.noUiSlider.destroy();\n\n  var redRangeSlider = _nouislider2.default.create(red, {\n    start: [0],\n    tooltips: [true],\n    range: {\n      'min': [0],\n      'max': [255]\n    },\n    pips: {\n      mode: 'steps',\n      stepped: true,\n      density: 8\n    }\n  });\n\n  var greenRangeSlider = _nouislider2.default.create(green, {\n    start: [0],\n    tooltips: [true],\n    range: {\n      'min': [0],\n      'max': [255]\n    },\n    pips: {\n      mode: 'steps',\n      stepped: true,\n      density: 8\n    }\n  });\n\n  var blueRangeSlider = _nouislider2.default.create(blue, {\n    start: [0],\n    tooltips: [true],\n    range: {\n      'min': [0],\n      'max': [255]\n    },\n    pips: {\n      mode: 'steps',\n      stepped: true,\n      density: 8\n    }\n  });\n\n  redRangeSlider.target.children[0].style.background = '#c0392b';\n  greenRangeSlider.target.children[0].style.background = '#27ae60';\n  blueRangeSlider.target.children[0].style.background = '#2980b9';\n\n  return {\n    canvas_clip: canvas_clip,\n    preview: preview,\n    canvas_background: canvas_background,\n    dropbox: dropbox,\n    clear: clear,\n    apply: apply,\n    save: save,\n    redRangeSlider: redRangeSlider,\n    greenRangeSlider: greenRangeSlider,\n    blueRangeSlider: blueRangeSlider,\n    moreBrightness: moreBrightness,\n    lessBrightness: lessBrightness\n  };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYm9hcmQuanM/OGIyZiJdLCJuYW1lcyI6WyJwY2NwIiwib3B0aW9ucyIsIndvcmtzcGFjZSIsImlkIiwiY2FudmFzX2JhY2tncm91bmQiLCJjYW52YXNfY2xpcCIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwiYXBwZW5kQ2hpbGQiLCJ3aWR0aCIsImhlaWdodCIsImJvYXJkIiwic2lkZSIsImRpc3BsYXkiLCJtYXJnaW4iLCJib3JkZXIiLCJkcm9wYm94TGF5b3V0IiwiY2xhc3NOYW1lIiwiZHJvcGJveExhYmVsIiwiZHJvcGJveCIsInR5cGUiLCJwcmV2aWV3IiwiYWx0IiwicGFkZGluZyIsImN1cnNvciIsImNvbnRyb2wiLCJwcmVzZXQiLCJlZmZlY3QiLCJicmlnaHRuZXNzIiwibW9yZUJyaWdodG5lc3MiLCJ0ZXh0IiwibGVzc0JyaWdodG5lc3MiLCJsZXZlbCIsInJlZCIsImdyZWVuIiwiYmx1ZSIsImNsZWFyIiwiYXBwbHkiLCJzYXZlIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJub1VpU2xpZGVyIiwiZGVzdHJveSIsInJlZFJhbmdlU2xpZGVyIiwiY3JlYXRlIiwic3RhcnQiLCJ0b29sdGlwcyIsInJhbmdlIiwicGlwcyIsIm1vZGUiLCJzdGVwcGVkIiwiZGVuc2l0eSIsImdyZWVuUmFuZ2VTbGlkZXIiLCJibHVlUmFuZ2VTbGlkZXIiLCJ0YXJnZXQiLCJjaGlsZHJlbiIsImJhY2tncm91bmQiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7OztrQkFFZSxVQUFDQSxJQUFELEVBQU9DLE9BQVAsRUFBbUI7O0FBRWhDO0FBQ0EsTUFBTUMsWUFBWSwwQkFBVyxLQUFYLEVBQWtCLEVBQUVDLElBQUksV0FBTixFQUFsQixDQUFsQjtBQUNBLE1BQU1DLG9CQUFvQiwwQkFBVyxRQUFYLEVBQXFCLEVBQUVELElBQUksWUFBTixFQUFyQixDQUExQjtBQUNBLE1BQU1FLGNBQWMsMEJBQVcsUUFB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LElBRkw7QUFHSkMsZUFBUztBQUhMO0FBUHdDLEdBQXhCLENBQXhCOztBQWNBUixpQkFBZVcsTUFBZixDQUFzQkMsUUFBdEIsQ0FBK0IsQ0FBL0IsRUFBa0NuRCxLQUFsQyxDQUF3Q29ELFVBQXhDLEdBQXFELFNBQXJEO0FBQ0FKLG1CQUFpQkUsTUFBakIsQ0FBd0JDLFFBQXhCLENBQWlDLENBQWpDLEVBQW9DbkQsS0FBcEMsQ0FBMENvRCxVQUExQyxHQUF1RCxTQUF2RDtBQUNBSCxrQkFBZ0JDLE1BQWhCLENBQXVCQyxRQUF2QixDQUFnQyxDQUFoQyxFQUFtQ25ELEtBQW5DLENBQXlDb0QsVUFBekMsR0FBc0QsU0FBdEQ7O0FBRUEsU0FBTztBQUNMckQsNEJBREs7QUFFTGtCLG9CQUZLO0FBR0xuQix3Q0FISztBQUlMaUIsb0JBSks7QUFLTGlCLGdCQUxLO0FBTUxDLGdCQU5LO0FBT0xDLGNBUEs7QUFRTEssa0NBUks7QUFTTFMsc0NBVEs7QUFVTEMsb0NBVks7QUFXTHhCLGtDQVhLO0FBWUxFO0FBWkssR0FBUDtBQWVELEMiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBub1VpU2xpZGVyIGZyb20gJ25vdWlzbGlkZXInXG5pbXBvcnQgZ2V0RWxlbWVudCBmcm9tICcuL2dldEVsZW1lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IChwY2NwLCBvcHRpb25zKSA9PiB7XG5cbiAgLy8gd29ya3NwYWNlXG4gIGNvbnN0IHdvcmtzcGFjZSA9IGdldEVsZW1lbnQoJ2RpdicsIHsgaWQ6ICd3b3Jrc3BhY2UnIH0pXG4gIGNvbnN0IGNhbnZhc19iYWNrZ3JvdW5kID0gZ2V0RWxlbWVudCgnY2FudmFzJywgeyBpZDogJ2JhY2tncm91bmQnIH0pXG4gIGNvbnN0IGNhbnZhc19jbGlwID0gZ2V0RWxlbWVudCgnY2FudmFzJywgeyBpZDogJ21hc2snIH0pXG5cbiAgY2FudmFzX2JhY2tncm91bmQuc3R5bGUucG9zaXRpb24gPSBjYW52YXNfY2xpcC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcbiAgY2FudmFzX2JhY2tncm91bmQuc3R5bGUudG9wID0gY2FudmFzX2NsaXAuc3R5bGUudG9wID0gMFxuICBjYW52YXNfYmFja2dyb3VuZC5zdHlsZS5sZWZ0ID0gY2FudmFzX2NsaXAuc3R5bGUubGVmdCA9IDBcblxuICB3b3Jrc3BhY2UuYXBwZW5kQ2hpbGQoY2FudmFzX2JhY2tncm91bmQpXG4gIHdvcmtzcGFjZS5zdHlsZS53aWR0aCA9IHdvcmtzcGFjZS5zdHlsZS5oZWlnaHQgPSBvcHRpb25zLmJvYXJkLnNpZGVcbiAgd29ya3NwYWNlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJ1xuICB3b3Jrc3BhY2Uuc3R5bGVbJ21pbi13aWR0aCddID0gJzMwMHB4J1xuICB3b3Jrc3BhY2Uuc3R5bGVbJ21pbi1oZWlnaHQnXSA9ICczMDBweCdcbiAgd29ya3NwYWNlLnN0eWxlWydiYWNrZ3JvdW5kLWNvbG9yJ10gPSAnYmxhY2snXG4gIHdvcmtzcGFjZS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jaydcbiAgd29ya3NwYWNlLnN0eWxlWyd2ZXJ0aWNhbC1hbGlnbiddID0gJ3RvcCdcbiAgd29ya3NwYWNlLnN0eWxlLm1hcmdpbiA9ICcxMHB4J1xuICB3b3Jrc3BhY2Uuc3R5bGUuYm9yZGVyID0gJzNweCBzb2xpZCBibGFjaydcbiAgd29ya3NwYWNlLmFwcGVuZENoaWxkKGNhbnZhc19jbGlwKVxuXG4gIC8vIGRyb3Bib3hcbiAgY29uc3QgZHJvcGJveExheW91dCA9IGdldEVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiAnZHJvcGJveC1sYXlvdXQnIH0pXG4gIGNvbnN0IGRyb3Bib3hMYWJlbCA9IGdldEVsZW1lbnQoJ2xhYmVsJywgeyBjbGFzc05hbWU6ICdkcm9wYm94JyB9KVxuICBjb25zdCBkcm9wYm94ID0gZ2V0RWxlbWVudCgnaW5wdXQnLCB7IGlkOiAnZHJvcGJveCcsIHR5cGU6ICdmaWxlJyB9KVxuICBjb25zdCBwcmV2aWV3ID0gZ2V0RWxlbWVudCgnaW1nJywgeyBpZDogJ3ByZXZpZXcnLCBhbHQ6ICdjbGlxdWV6IGljaSBwb3VyIGNoYXJnZXIgdW5lIGltYWdlJyB9KVxuXG4gIHByZXZpZXcuc3R5bGVbJ21heC13aWR0aCddID0gKG9wdGlvbnMuYm9hcmQuc2lkZSAtIDUpICsgJ3B4J1xuICBwcmV2aWV3LnN0eWxlWydtYXgtaGVpZ2h0J10gPSAob3B0aW9ucy5ib2FyZC5zaWRlIC0gNSkgKyAncHgnXG5cbiAgZHJvcGJveC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG5cbiAgZHJvcGJveExhYmVsLnN0eWxlLmJvcmRlciA9ICcycHggZGFzaGVkICNCQkJCQkInXG4gIGRyb3Bib3hMYWJlbC5zdHlsZVsnbGluZS1oZWlnaHQnXSA9ICc1MHB4J1xuICBkcm9wYm94TGFiZWwuc3R5bGVbJ3RleHQtYWxpZ24nXSA9ICdjZW50ZXInXG4gIGRyb3Bib3hMYWJlbC5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jaydcbiAgZHJvcGJveExhYmVsLnN0eWxlLnBhZGRpbmcgPSAnNnB4J1xuICBkcm9wYm94TGFiZWwuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInXG5cbiAgZHJvcGJveExhYmVsLmFwcGVuZENoaWxkKGRyb3Bib3gpXG4gIGRyb3Bib3hMYWJlbC5hcHBlbmRDaGlsZChwcmV2aWV3KVxuXG4gIGRyb3Bib3hMYXlvdXQuYXBwZW5kQ2hpbGQoZHJvcGJveExhYmVsKVxuICBkcm9wYm94TGF5b3V0LnN0eWxlWydtaW4td2lkdGgnXSA9IGRyb3Bib3hMYXlvdXQuc3R5bGVbJ21pbi1oZWlnaHQnXVxuICBkcm9wYm94TGF5b3V0LnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJ1xuICBkcm9wYm94TGF5b3V0LnN0eWxlWyd2ZXJ0aWNhbC1hbGlnbiddID0gJ3RvcCdcblxuICBkcm9wYm94TGFiZWwuc3R5bGVbJ21pbi13aWR0aCddID0gZHJvcGJveExhYmVsLnN0eWxlWydtaW4taGVpZ2h0J10gPSBvcHRpb25zLmJvYXJkLnNpZGVcblxuICAvLyBjb250cm9sXG4gIGNvbnN0IGNvbnRyb2wgPSBnZXRFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogJ2NvbnRyb2wnIH0pXG4gIGNvbnN0IGJvYXJkID0gZ2V0RWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6ICdib2FyZCcgfSlcbiAgY29uc3QgcHJlc2V0ID0gZ2V0RWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6ICdwcmVzZXQnIH0pXG4gIGNvbnN0IGVmZmVjdCA9IGdldEVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiAnZWZmZWN0JyB9KVxuICBjb25zdCBicmlnaHRuZXNzID0gZ2V0RWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6ICdicmlnaHRuZXNzJyB9KVxuICBjb25zdCBtb3JlQnJpZ2h0bmVzcyA9IGdldEVsZW1lbnQoJ2J1dHRvbicsIHsgaWQ6ICdtb3JlQnJpZ2h0bmVzcycsIHRleHQ6ICdCcmlnaHRuZXNzICsnIH0pXG4gIGNvbnN0IGxlc3NCcmlnaHRuZXNzID0gZ2V0RWxlbWVudCgnYnV0dG9uJywgeyBpZDogJ2xlc3NCcmlnaHRuZXNzJywgdGV4dDogJ0JyaWdodG5lc3MgLScgfSlcbiAgY29uc3QgbGV2ZWwgPSBnZXRFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogJ2xldmVsJyB9KVxuICBjb25zdCByZWQgPSBnZXRFbGVtZW50KCdkaXYnLCB7IGlkOiAncmVkJywgY2xhc3NOYW1lOiAnaXRlbS1sZXZlbCcgfSlcbiAgY29uc3QgZ3JlZW4gPSBnZXRFbGVtZW50KCdkaXYnLCB7IGlkOiAnZ3JlZW4nLCBjbGFzc05hbWU6ICdpdGVtLWxldmVsJyB9KVxuICBjb25zdCBibHVlID0gZ2V0RWxlbWVudCgnZGl2JywgeyBpZDogJ2JsdWUnLCBjbGFzc05hbWU6ICdpdGVtLWxldmVsJyB9KVxuICBjb25zdCBjbGVhciA9IGdldEVsZW1lbnQoJ2J1dHRvbicsIHsgaWQ6ICdjbGVhcicsIHRleHQ6ICdDbGVhcicgfSlcbiAgY29uc3QgYXBwbHkgPSBnZXRFbGVtZW50KCdidXR0b24nLCB7IGlkOiAnYXBwbHknLCB0ZXh0OiAnQXBwbHknIH0pXG4gIGNvbnN0IHNhdmUgPSBnZXRFbGVtZW50KCdidXR0b24nLCB7IGlkOiAnc2F2ZScsIHRleHQ6ICdTZW5kJyB9KVxuXG4gIG1vcmVCcmlnaHRuZXNzLnN0eWxlLm1hcmdpbiA9XG4gIGxlc3NCcmlnaHRuZXNzLnN0eWxlLm1hcmdpbiA9XG4gIGNsZWFyLnN0eWxlLm1hcmdpbiA9XG4gIGFwcGx5LnN0eWxlLm1hcmdpbiA9XG4gIHNhdmUuc3R5bGUubWFyZ2luID0gJzEwcHgnXG5cbiAgbW9yZUJyaWdodG5lc3Muc3R5bGUud2lkdGggPVxuICBsZXNzQnJpZ2h0bmVzcy5zdHlsZS53aWR0aCA9XG4gIGNsZWFyLnN0eWxlLndpZHRoID1cbiAgYXBwbHkuc3R5bGUud2lkdGggPVxuICBzYXZlLnN0eWxlLndpZHRoID0gJzEwMHB4J1xuXG4gIG1vcmVCcmlnaHRuZXNzLnN0eWxlLmhlaWdodCA9XG4gIGxlc3NCcmlnaHRuZXNzLnN0eWxlLmhlaWdodCA9XG4gIGNsZWFyLnN0eWxlLmhlaWdodCA9XG4gIGFwcGx5LnN0eWxlLmhlaWdodCA9XG4gIHNhdmUuc3R5bGUuaGVpZ2h0ID0gJzMwcHgnXG5cbiAgcmVkLnN0eWxlLm1hcmdpbiA9IGdyZWVuLnN0eWxlLm1hcmdpbiA9IGJsdWUuc3R5bGUubWFyZ2luID0gJzIwcHggMTBweCdcblxuICBsZXZlbC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXG4gIGxldmVsLnN0eWxlWydmbGV4LWRpcmVjdGlvbiddID0gJ2NvbHVtbidcbiAgbGV2ZWwuc3R5bGUud2lkdGggPSAnMzAwcHgnXG4gIGxldmVsLnN0eWxlWydtYXJnaW4nXSA9ICczNXB4IDI1cHgnXG5cbiAgbGV2ZWwuYXBwZW5kQ2hpbGQocmVkKVxuICBsZXZlbC5hcHBlbmRDaGlsZChncmVlbilcbiAgbGV2ZWwuYXBwZW5kQ2hpbGQoYmx1ZSlcblxuICBlZmZlY3QuYXBwZW5kQ2hpbGQoY2xlYXIpXG4gIGVmZmVjdC5hcHBlbmRDaGlsZChhcHBseSlcbiAgZWZmZWN0LmFwcGVuZENoaWxkKHNhdmUpXG5cbiAgYnJpZ2h0bmVzcy5hcHBlbmRDaGlsZChtb3JlQnJpZ2h0bmVzcylcbiAgYnJpZ2h0bmVzcy5hcHBlbmRDaGlsZChsZXNzQnJpZ2h0bmVzcylcblxuICBwcmVzZXQuYXBwZW5kQ2hpbGQoYnJpZ2h0bmVzcylcblxuICBib2FyZC5hcHBlbmRDaGlsZChwcmVzZXQpXG4gIGJvYXJkLmFwcGVuZENoaWxkKGVmZmVjdClcblxuXG4gIGNvbnRyb2wuYXBwZW5kQ2hpbGQobGV2ZWwpXG4gIGNvbnRyb2wuYXBwZW5kQ2hpbGQoYm9hcmQpXG5cbiAgY29udHJvbC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXG4gIGNvbnRyb2wuc3R5bGVbJ2JhY2tncm91bmQtY29sb3InXSA9ICdncmV5J1xuICBjb250cm9sLnN0eWxlWydtaW4taGVpZ2h0J10gPSAnMjQwcHgnXG4gIGNvbnRyb2wuc3R5bGUubWFyZ2luID0gJzEwcHgnXG5cbiAgLy8gcGNjcFxuICBwY2NwLmFwcGVuZENoaWxkKHdvcmtzcGFjZSlcbiAgcGNjcC5hcHBlbmRDaGlsZChkcm9wYm94TGF5b3V0KVxuICBwY2NwLmFwcGVuZENoaWxkKGNvbnRyb2wpXG5cbiAgcGNjcC5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1mbGV4J1xuICBwY2NwLnN0eWxlWydmbGV4LXdyYXAnXSA9ICd3cmFwJ1xuICBwY2NwLnN0eWxlLndpZHRoID0gJzEwMCUnXG5cbiAgaWYgKHJlZC5jbGFzc0xpc3QuY29udGFpbnMoJ25vVWktdGFyZ2V0JykpIHJlZC5ub1VpU2xpZGVyLmRlc3Ryb3koKVxuICBpZiAoZ3JlZW4uY2xhc3NMaXN0LmNvbnRhaW5zKCdub1VpLXRhcmdldCcpKSBncmVlbi5ub1VpU2xpZGVyLmRlc3Ryb3koKVxuICBpZiAoYmx1ZS5jbGFzc0xpc3QuY29udGFpbnMoJ25vVWktdGFyZ2V0JykpIGJsdWUubm9VaVNsaWRlci5kZXN0cm95KClcblxuICBjb25zdCByZWRSYW5nZVNsaWRlciA9IG5vVWlTbGlkZXIuY3JlYXRlKHJlZCwge1xuICAgIHN0YXJ0OiBbMF0sXG4gICAgdG9vbHRpcHM6IFsgdHJ1ZSBdLFxuICAgIHJhbmdlOiB7XG4gICAgICAnbWluJzogWyAwIF0sXG4gICAgICAnbWF4JzogWyAyNTUgXVxuICAgIH0sXG4gICAgcGlwczoge1xuICAgICAgbW9kZTogJ3N0ZXBzJyxcbiAgICAgIHN0ZXBwZWQ6IHRydWUsXG4gICAgICBkZW5zaXR5OiA4XG4gICAgfVxuICB9KVxuXG4gIGNvbnN0IGdyZWVuUmFuZ2VTbGlkZXIgPSBub1VpU2xpZGVyLmNyZWF0ZShncmVlbiwge1xuICAgIHN0YXJ0OiBbMF0sXG4gICAgdG9vbHRpcHM6IFsgdHJ1ZSBdLFxuICAgIHJhbmdlOiB7XG4gICAgICAnbWluJzogWyAwIF0sXG4gICAgICAnbWF4JzogWyAyNTUgXVxuICAgIH0sXG4gICAgcGlwczoge1xuICAgICAgbW9kZTogJ3N0ZXBzJyxcbiAgICAgIHN0ZXBwZWQ6IHRydWUsXG4gICAgICBkZW5zaXR5OiA4XG4gICAgfVxuICB9KVxuXG4gIGNvbnN0IGJsdWVSYW5nZVNsaWRlciA9IG5vVWlTbGlkZXIuY3JlYXRlKGJsdWUsIHtcbiAgICBzdGFydDogWzBdLFxuICAgIHRvb2x0aXBzOiBbIHRydWUgXSxcbiAgICByYW5nZToge1xuICAgICAgJ21pbic6IFsgMCBdLFxuICAgICAgJ21heCc6IFsgMjU1IF1cbiAgICB9LFxuICAgIHBpcHM6IHtcbiAgICAgIG1vZGU6ICdzdGVwcycsXG4gICAgICBzdGVwcGVkOiB0cnVlLFxuICAgICAgZGVuc2l0eTogOFxuICAgIH1cbiAgfSlcblxuICByZWRSYW5nZVNsaWRlci50YXJnZXQuY2hpbGRyZW5bMF0uc3R5bGUuYmFja2dyb3VuZCA9ICcjYzAzOTJiJ1xuICBncmVlblJhbmdlU2xpZGVyLnRhcmdldC5jaGlsZHJlblswXS5zdHlsZS5iYWNrZ3JvdW5kID0gJyMyN2FlNjAnXG4gIGJsdWVSYW5nZVNsaWRlci50YXJnZXQuY2hpbGRyZW5bMF0uc3R5bGUuYmFja2dyb3VuZCA9ICcjMjk4MGI5J1xuXG4gIHJldHVybiB7XG4gICAgY2FudmFzX2NsaXAsXG4gICAgcHJldmlldyxcbiAgICBjYW52YXNfYmFja2dyb3VuZCxcbiAgICBkcm9wYm94LFxuICAgIGNsZWFyLFxuICAgIGFwcGx5LFxuICAgIHNhdmUsXG4gICAgcmVkUmFuZ2VTbGlkZXIsXG4gICAgZ3JlZW5SYW5nZVNsaWRlcixcbiAgICBibHVlUmFuZ2VTbGlkZXIsXG4gICAgbW9yZUJyaWdodG5lc3MsXG4gICAgbGVzc0JyaWdodG5lc3NcbiAgfVxuXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYm9hcmQuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _background = __webpack_require__(2);\n\nvar _background2 = _interopRequireDefault(_background);\n\nvar _clip = __webpack_require__(3);\n\nvar _clip2 = _interopRequireDefault(_clip);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (raw, board, options) {\n  var canvas_clip = board.canvas_clip,\n      canvas_background = board.canvas_background,\n      clear = board.clear,\n      apply = board.apply,\n      save = board.save,\n      preview = board.preview,\n      redRangeSlider = board.redRangeSlider,\n      greenRangeSlider = board.greenRangeSlider,\n      blueRangeSlider = board.blueRangeSlider,\n      lessBrightness = board.lessBrightness,\n      moreBrightness = board.moreBrightness;\n\n\n  raw.ratio = raw.width / raw.height;\n\n  // Initial canvas_background size ==========\n  if (raw.ratio < 1) {\n    canvas_background.width = canvas_clip.width = options.board.side * raw.ratio;\n    canvas_background.height = canvas_clip.height = options.board.side;\n  } else if (raw.ratio > 1) {\n    canvas_background.width = canvas_clip.width = options.board.side;\n    canvas_background.height = canvas_clip.height = options.board.side / raw.ratio;\n  } else {\n    canvas_background.width = canvas_clip.width = canvas_background.height = canvas_clip.height = options.board.side;\n  }\n  // =============================================================================\n\n  var background = new _background2.default(preview, raw, canvas_background, options);\n  var clip = new _clip2.default(canvas_clip, options);\n\n  redRangeSlider.updateOptions({ start: [background.rgbAverage.red] });\n  redRangeSlider.on('update', function (values, handle) {\n    return background.changeColorLevel(Math.round(values[handle]), 'red');\n  });\n\n  greenRangeSlider.updateOptions({ start: [background.rgbAverage.green] });\n  greenRangeSlider.on('update', function (values, handle) {\n    return background.changeColorLevel(Math.round(values[handle]), 'green');\n  });\n\n  blueRangeSlider.updateOptions({ start: [background.rgbAverage.blue] });\n  blueRangeSlider.on('update', function (values, handle) {\n    return background.changeColorLevel(Math.round(values[handle]), 'blue');\n  });\n\n  moreBrightness.addEventListener('click', function () {\n    redRangeSlider.set(Math.round(redRangeSlider.get()) + 5);\n    greenRangeSlider.set(Math.round(greenRangeSlider.get()) + 5);\n    blueRangeSlider.set(Math.round(blueRangeSlider.get()) + 5);\n  });\n  lessBrightness.addEventListener('click', function () {\n    redRangeSlider.set(Math.round(redRangeSlider.get()) - 5);\n    greenRangeSlider.set(Math.round(greenRangeSlider.get()) - 5);\n    blueRangeSlider.set(Math.round(blueRangeSlider.get()) - 5);\n  });\n\n  redRangeSlider.set(background.rgbAverage.red);\n  greenRangeSlider.set(background.rgbAverage.green);\n  blueRangeSlider.set(background.rgbAverage.blue);\n\n  apply.addEventListener('click', function () {\n    return preview.src = background.apply(clip, raw);\n  });\n  save.addEventListener('click', function () {\n    return background.save();\n  });\n  clear.addEventListener('click', function () {\n    background.clear();\n    redRangeSlider.set(background.rgbAverage.red);\n    greenRangeSlider.set(background.rgbAverage.green);\n    blueRangeSlider.set(background.rgbAverage.blue);\n  });\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz8zNDc5Il0sIm5hbWVzIjpbInJhdyIsImJvYXJkIiwib3B0aW9ucyIsImNhbnZhc19jbGlwIiwiY2FudmFzX2JhY2tncm91bmQiLCJjbGVhciIsImFwcGx5Iiwic2F2ZSIsInByZXZpZXciLCJyZWRSYW5nZVNsaWRlciIsImdyZWVuUmFuZ2VTbGlkZXIiLCJibHVlUmFuZ2VTbGlkZXIiLCJsZXNzQnJpZ2h0bmVzcyIsIm1vcmVCcmlnaHRuZXNzIiwicmF0aW8iLCJ3aWR0aCIsImhlaWdodCIsInNpZGUiLCJiYWNrZ3JvdW5kIiwiY2xpcCIsInVwZGF0ZU9wdGlvbnMiLCJzdGFydCIsInJnYkF2ZXJhZ2UiLCJyZWQiLCJvbiIsInZhbHVlcyIsImhhbmRsZSIsImNoYW5nZUNvbG9yTGV2ZWwiLCJNYXRoIiwicm91bmQiLCJncmVlbiIsImJsdWUiLCJhZGRFdmVudExpc3RlbmVyIiwic2V0IiwiZ2V0Iiwic3JjIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7OztBQUNBOzs7Ozs7a0JBRWUsVUFBQ0EsR0FBRCxFQUFNQyxLQUFOLEVBQWFDLE9BQWIsRUFBeUI7QUFBQSxNQUdwQ0MsV0FIb0MsR0FjbENGLEtBZGtDLENBR3BDRSxXQUhvQztBQUFBLE1BSXBDQyxpQkFKb0MsR0FjbENILEtBZGtDLENBSXBDRyxpQkFKb0M7QUFBQSxNQUtwQ0MsS0FMb0MsR0FjbENKLEtBZGtDLENBS3BDSSxLQUxvQztBQUFBLE1BTXBDQyxLQU5vQyxHQWNsQ0wsS0Fka0MsQ0FNcENLLEtBTm9DO0FBQUEsTUFPcENDLElBUG9DLEdBY2xDTixLQWRrQyxDQU9wQ00sSUFQb0M7QUFBQSxNQVFwQ0MsT0FSb0MsR0FjbENQLEtBZGtDLENBUXBDTyxPQVJvQztBQUFBLE1BU3BDQyxjQVRvQyxHQWNsQ1IsS0Fka0MsQ0FTcENRLGNBVG9DO0FBQUEsTUFVcENDLGdCQVZvQyxHQWNsQ1QsS0Fka0MsQ0FVcENTLGdCQVZvQztBQUFBLE1BV3BDQyxl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MUM7QUFDRCxHQUxEO0FBTUQsQyIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhY2tncm91bmQgZnJvbSAnLi9iYWNrZ3JvdW5kJ1xuaW1wb3J0IENsaXAgZnJvbSAnLi9jbGlwJ1xuXG5leHBvcnQgZGVmYXVsdCAocmF3LCBib2FyZCwgb3B0aW9ucykgPT4ge1xuXG4gIGNvbnN0IHtcbiAgICBjYW52YXNfY2xpcCxcbiAgICBjYW52YXNfYmFja2dyb3VuZCxcbiAgICBjbGVhcixcbiAgICBhcHBseSxcbiAgICBzYXZlLFxuICAgIHByZXZpZXcsXG4gICAgcmVkUmFuZ2VTbGlkZXIsXG4gICAgZ3JlZW5SYW5nZVNsaWRlcixcbiAgICBibHVlUmFuZ2VTbGlkZXIsXG4gICAgbGVzc0JyaWdodG5lc3MsXG4gICAgbW9yZUJyaWdodG5lc3NcbiAgfSA9IGJvYXJkXG5cbiAgcmF3LnJhdGlvID0gcmF3LndpZHRoIC8gcmF3LmhlaWdodFxuXG4gIC8vIEluaXRpYWwgY2FudmFzX2JhY2tncm91bmQgc2l6ZSA9PT09PT09PT09XG4gIGlmIChyYXcucmF0aW8gPCAxKSB7XG4gICAgY2FudmFzX2JhY2tncm91bmQud2lkdGggPSBjYW52YXNfY2xpcC53aWR0aCA9IG9wdGlvbnMuYm9hcmQuc2lkZSAqIHJhdy5yYXRpb1xuICAgIGNhbnZhc19iYWNrZ3JvdW5kLmhlaWdodCA9IGNhbnZhc19jbGlwLmhlaWdodCA9IG9wdGlvbnMuYm9hcmQuc2lkZVxuICB9IGVsc2UgaWYgKHJhdy5yYXRpbyA+IDEpIHtcbiAgICBjYW52YXNfYmFja2dyb3VuZC53aWR0aCA9IGNhbnZhc19jbGlwLndpZHRoID0gb3B0aW9ucy5ib2FyZC5zaWRlXG4gICAgY2FudmFzX2JhY2tncm91bmQuaGVpZ2h0ID0gY2FudmFzX2NsaXAuaGVpZ2h0ID0gb3B0aW9ucy5ib2FyZC5zaWRlIC8gcmF3LnJhdGlvXG4gIH0gZWxzZSB7XG4gICAgY2FudmFzX2JhY2tncm91bmQud2lkdGggPSBjYW52YXNfY2xpcC53aWR0aCA9IGNhbnZhc19iYWNrZ3JvdW5kLmhlaWdodCA9IGNhbnZhc19jbGlwLmhlaWdodCAgPSBvcHRpb25zLmJvYXJkLnNpZGVcbiAgfVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGNvbnN0IGJhY2tncm91bmQgPSBuZXcgQmFja2dyb3VuZChwcmV2aWV3LCByYXcsIGNhbnZhc19iYWNrZ3JvdW5kLCBvcHRpb25zKVxuICBjb25zdCBjbGlwID0gbmV3IENsaXAoY2FudmFzX2NsaXAsIG9wdGlvbnMpXG5cblxuICByZWRSYW5nZVNsaWRlci51cGRhdGVPcHRpb25zKHsgc3RhcnQ6IFsgYmFja2dyb3VuZC5yZ2JBdmVyYWdlLnJlZCBdIH0pXG4gIHJlZFJhbmdlU2xpZGVyLm9uKCd1cGRhdGUnLCAoIHZhbHVlcywgaGFuZGxlICkgPT4gYmFja2dyb3VuZC5jaGFuZ2VDb2xvckxldmVsKE1hdGgucm91bmQodmFsdWVzW2hhbmRsZV0pLCAncmVkJykpXG5cbiAgZ3JlZW5SYW5nZVNsaWRlci51cGRhdGVPcHRpb25zKHsgc3RhcnQ6IFsgYmFja2dyb3VuZC5yZ2JBdmVyYWdlLmdyZWVuIF0gfSlcbiAgZ3JlZW5SYW5nZVNsaWRlci5vbigndXBkYXRlJywgKCB2YWx1ZXMsIGhhbmRsZSApID0+IGJhY2tncm91bmQuY2hhbmdlQ29sb3JMZXZlbChNYXRoLnJvdW5kKHZhbHVlc1toYW5kbGVdKSwgJ2dyZWVuJykpXG5cbiAgYmx1ZVJhbmdlU2xpZGVyLnVwZGF0ZU9wdGlvbnMoeyBzdGFydDogWyBiYWNrZ3JvdW5kLnJnYkF2ZXJhZ2UuYmx1ZSBdIH0pXG4gIGJsdWVSYW5nZVNsaWRlci5vbigndXBkYXRlJywgKCB2YWx1ZXMsIGhhbmRsZSApID0+IGJhY2tncm91bmQuY2hhbmdlQ29sb3JMZXZlbChNYXRoLnJvdW5kKHZhbHVlc1toYW5kbGVdKSwgJ2JsdWUnKSlcblxuICBtb3JlQnJpZ2h0bmVzcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICByZWRSYW5nZVNsaWRlci5zZXQoTWF0aC5yb3VuZChyZWRSYW5nZVNsaWRlci5nZXQoKSkgKyA1KVxuICAgIGdyZWVuUmFuZ2VTbGlkZXIuc2V0KE1hdGgucm91bmQoZ3JlZW5SYW5nZVNsaWRlci5nZXQoKSkgKyA1KVxuICAgIGJsdWVSYW5nZVNsaWRlci5zZXQoTWF0aC5yb3VuZChibHVlUmFuZ2VTbGlkZXIuZ2V0KCkpICsgNSlcbiAgfSlcbiAgbGVzc0JyaWdodG5lc3MuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgcmVkUmFuZ2VTbGlkZXIuc2V0KE1hdGgucm91bmQocmVkUmFuZ2VTbGlkZXIuZ2V0KCkpIC0gNSlcbiAgICBncmVlblJhbmdlU2xpZGVyLnNldChNYXRoLnJvdW5kKGdyZWVuUmFuZ2VTbGlkZXIuZ2V0KCkpIC0gNSlcbiAgICBibHVlUmFuZ2VTbGlkZXIuc2V0KE1hdGgucm91bmQoYmx1ZVJhbmdlU2xpZGVyLmdldCgpKSAtIDUpXG4gIH0pXG5cbiAgcmVkUmFuZ2VTbGlkZXIuc2V0KGJhY2tncm91bmQucmdiQXZlcmFnZS5yZWQpXG4gIGdyZWVuUmFuZ2VTbGlkZXIuc2V0KGJhY2tncm91bmQucmdiQXZlcmFnZS5ncmVlbilcbiAgYmx1ZVJhbmdlU2xpZGVyLnNldChiYWNrZ3JvdW5kLnJnYkF2ZXJhZ2UuYmx1ZSlcblxuXG4gIGFwcGx5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gcHJldmlldy5zcmMgPSBiYWNrZ3JvdW5kLmFwcGx5KGNsaXAsIHJhdykpXG4gIHNhdmUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBiYWNrZ3JvdW5kLnNhdmUoKSlcbiAgY2xlYXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgYmFja2dyb3VuZC5jbGVhcigpXG4gICAgcmVkUmFuZ2VTbGlkZXIuc2V0KGJhY2tncm91bmQucmdiQXZlcmFnZS5yZWQpXG4gICAgZ3JlZW5SYW5nZVNsaWRlci5zZXQoYmFja2dyb3VuZC5yZ2JBdmVyYWdlLmdyZWVuKVxuICAgIGJsdWVSYW5nZVNsaWRlci5zZXQoYmFja2dyb3VuZC5yZ2JBdmVyYWdlLmJsdWUpXG4gIH0pXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWFpbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _request = __webpack_require__(5);\n\nvar _request2 = _interopRequireDefault(_request);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Background = function () {\n  function Background(preview, raw, canvas, options) {\n    _classCallCheck(this, Background);\n\n    this.preview = preview;\n    this.raw = raw;\n    this.preview.crossOrigin = 'Anonymous';\n    this.preview.ratio = this.preview.width / this.preview.height;\n\n    this.options = options;\n    this.options.output.r = this.options.output.w / this.options.output.h;\n\n    this.clip = Object.assign({}, this.options.clip);\n\n    this.canvas = canvas;\n\n    this.rgbAverage = { red: 0, green: 0, blue: 0 };\n    this.rgbDiff = { red: 0, green: 0, blue: 0 };\n\n    this.ctx = this.canvas.getContext('2d');\n\n    this.resultData = null;\n    this.position = {\n      x: this.canvas.offsetTop,\n      y: this.canvas.offsetLeft\n    };\n\n    this.draw();\n\n    this.imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n    this.srcData = new Uint8ClampedArray(this.imageData.data);\n\n    this.average();\n    this.rgbDiff = this.rgbAverage;\n  }\n\n  _createClass(Background, [{\n    key: 'average',\n    value: function average() {\n\n      var data = this.imageData.data;\n      var m = data.length / 3;\n\n      var red = 0,\n          green = 0,\n          blue = 0;\n\n      for (var i = 0; i < data.length; i += 4) {\n        if (data[i] > 0) red += data[i];\n        if (data[i + 1] > 0) green += data[i + 1];\n        if (data[i + 2] > 0) blue += data[i + 2];\n      }\n\n      this.rgbAverage = {\n        red: Math.round(red / m),\n        green: Math.round(green / m),\n        blue: Math.round(blue / m)\n      };\n\n      return this;\n    }\n\n    // ===============  change color level  =================\n\n  }, {\n    key: 'changeColorLevel',\n    value: function changeColorLevel(r, color) {\n      if (!this.imageData) return this;\n\n      var data = this.imageData.data;\n\n      if (color == 'red') {\n        for (var i = 0; i < data.length; i += 4) {\n          data[i] = this.srcData[i] + Math.round(r) - this.rgbAverage.red;\n        }\n        this.average().ctx.putImageData(this.imageData, 0, 0);\n      }\n\n      if (color == 'green') {\n        for (var j = 0; j < data.length; j += 4) {\n          data[j + 1] = this.srcData[j + 1] + Math.round(r) - this.rgbAverage.green;\n        }\n        this.average().ctx.putImageData(this.imageData, 0, 0);\n      }\n\n      if (color == 'blue') {\n        for (var k = 0; k < data.length; k += 4) {\n          data[k + 2] = this.srcData[k + 2] + Math.round(r) - this.rgbAverage.blue;\n        }\n        this.average().ctx.putImageData(this.imageData, 0, 0);\n      }\n\n      return this;\n    }\n\n    // =========================================================\n\n\n  }, {\n    key: 'draw',\n    value: function draw() {\n      this.ctx.drawImage(this.preview, 0, 0, this.canvas.width, this.canvas.height);\n      return this;\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      var initial = new ImageData(this.srcData, this.canvas.width, this.canvas.height);\n      this.ctx.putImageData(initial, 0, 0);\n      this.imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n      this.average();\n      return this;\n    }\n  }, {\n    key: 'applyToRaw',\n    value: function applyToRaw(type) {\n      var canvasRaw = document.createElement('canvas');\n      canvasRaw.width = this.raw.width;\n      canvasRaw.height = this.raw.height;\n\n      var rawContext = canvasRaw.getContext('2d');\n      rawContext.drawImage(this.raw, 0, 0, this.raw.width, this.raw.height);\n\n      var rawData = rawContext.getImageData(0, 0, this.raw.width, this.raw.height);\n\n      if (this.rgbAverage.red - this.rgbDiff.red != 0) {\n        for (var i = 0; i < rawData.data.length; i += 4) {\n          rawData.data[i] += this.rgbAverage.red - this.rgbDiff.red;\n        }\n      }\n\n      if (this.rgbAverage.green - this.rgbDiff.green != 0) {\n        for (var j = 0; j < rawData.data.length; j += 4) {\n          rawData.data[j + 1] += this.rgbAverage.green - this.rgbDiff.green;\n        }\n      }\n\n      if (this.rgbAverage.blue - this.rgbDiff.blue != 0) {\n        for (var k = 0; k < rawData.data.length; k += 4) {\n          rawData.data[k + 2] += this.rgbAverage.blue - this.rgbDiff.blue;\n        }\n      }\n\n      rawContext.putImageData(rawData, 0, 0);\n\n      return canvasRaw.toDataURL('image/' + type);\n    }\n  }, {\n    key: 'resizePreviewDependingThanOutput',\n    value: function resizePreviewDependingThanOutput() {\n\n      var outputIsBiggerThanBoard = this.options.output.w > this.options.board.side || this.options.output.h > this.options.board.side;\n\n      if (outputIsBiggerThanBoard) {\n        if (this.options.output.r > 1) {\n          this.preview.width = this.options.board.side;\n          this.preview.height = this.preview.width / this.options.output.r;\n        } else if (this.options.output.r < 1) {\n          this.preview.height = this.options.board.side;\n          this.preview.width = this.preview.height * this.options.output.r;\n        } else {\n          this.preview.width = this.preview.height = this.options.board.side;\n        }\n      } else {\n        this.preview.width = this.options.output.w;\n        this.preview.height = this.options.output.h;\n      }\n    }\n  }, {\n    key: 'applyToNewestCanvas',\n    value: function applyToNewestCanvas(clip) {\n      var canvas = document.createElement('canvas');\n\n      clip = clip.selected;\n      console.log(clip);\n\n      var x = Math.round(this.raw.width / this.canvas.width * clip.sx);\n      var y = Math.round(this.raw.height / this.canvas.height * clip.sy);\n      var w = Math.round(this.raw.width / this.canvas.width * clip.sw);\n      var h = Math.round(this.raw.height / this.canvas.height * clip.sh);\n\n      canvas.width = this.options.output.w;\n      canvas.height = this.options.output.h;\n\n      this.resizePreviewDependingThanOutput();\n\n      var newest = new Image();\n      newest.src = this.applyToRaw('jpeg');\n\n      var context = canvas.getContext('2d');\n      context.drawImage(newest, x, y, w, h, 0, 0, this.options.output.w, this.options.output.h);\n\n      return canvas;\n    }\n  }, {\n    key: 'apply',\n    value: function apply(clip) {\n      var newestCanvas = this.applyToNewestCanvas(clip);\n      return newestCanvas.toDataURL('image/jpeg');\n    }\n  }, {\n    key: 'save',\n    value: function save() {\n      var xhr = (0, _request2.default)();\n      xhr.open('POST', this.options.dest, true);\n      xhr.setRequestHeader('X-Requested-With', 'xmlhttprequest');\n      if (this.options.csrf) xhr.setRequestHeader('X-CSRF-Token', this.options.csrf);\n      xhr.setRequestHeader('Content-Type', 'application/json');\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.setRequestHeader('Access-Control-Allow-Origin', '*');\n      xhr.send(JSON.stringify({\n        value: this.resultData\n      }));\n    }\n  }]);\n\n  return Background;\n}();\n\nexports.default = Background;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmFja2dyb3VuZC5qcz82NDBmIl0sIm5hbWVzIjpbIkJhY2tncm91bmQiLCJwcmV2aWV3IiwicmF3IiwiY2FudmFzIiwib3B0aW9ucyIsImNyb3NzT3JpZ2luIiwicmF0aW8iLCJ3aWR0aCIsImhlaWdodCIsIm91dHB1dCIsInIiLCJ3IiwiaCIsImNsaXAiLCJPYmplY3QiLCJhc3NpZ24iLCJyZ2JBdmVyYWdlIiwicmVkIiwiZ3JlZW4iLCJibHVlIiwicmdiRGlmZiIsImN0eCIsImdldENvbnRleHQiLCJyZXN1bHREYXRhIiwicG9zaXRpb24iLCJ4Iiwib2Zmc2V0VG9wIiwieSIsIm9mZnNldExlZnQiLCJkcmF3IiwiaW1hZ2VEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwic3JjRGF0YSIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiZGF0YSIsImF2ZXJhZ2UiLCJtIiwibGVuZ3RoIiwiaSIsIk1hdGgiLCJyb3VuZCIsImNvbG9yIiwicHV0SW1hZ2VEYXRhIiwiaiIsImsiLCJkcmF3SW1hZ2UiLCJpbml0aWFsIiwiSW1hZ2VEYXRhIiwidHlwZSIsImNhbnZhc1JhdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInJhd0NvbnRleHQiLCJyYXdEYXRhIiwidG9EYXRhVVJMIiwib3V0cHV0SXNCaWdnZXJUaGFuQm9hcmQiLCJib2FyZCIsInNpZGUiLCJzZWxlY3RlZCIsImNvbnNvbGUiLCJsb2ciLCJzeCIsInN5Iiwic3ciLCJzaCIsInJlc2l6ZVByZXZpZXdEZXBlbmRpbmdUaGFuT3V0cHV0IiwibmV3ZXN0IiwiSW1hZ2UiLCJzcmMiLCJhcHBseVRvUmF3IiwiY29udGV4dCIsIm5ld2VzdENhbnZhcyIsImFwcGx5VG9OZXdlc3RDYW52YXMiLCJ4aHIiLCJvcGVuIiwiZGVzdCIsInNldFJlcXVlc3RIZWFkZXIiLCJjc3JmIiwic2VuZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ2YWx1ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7SUFFcUJBLFU7QUFFbkIsc0JBQVlDLE9BQVosRUFBcUJDLEdBQXJCLEVBQTBCQyxNQUExQixFQUFrQ0MsT0FBbEMsRUFBMkM7QUFBQTs7QUFFekMsU0FBS0gsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBS0MsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsU0FBS0QsT0FBTCxDQUFhSSxXQUFiLEdBQTJCLFdBQTNCO0FBQ0EsU0FBS0osT0FBTCxDQUFhSyxLQUFiLEdBQXFCLEtBQUtMLE9BQUwsQ0FBYU0sS0FBYixHQUFxQixLQUFLTixPQUFMLENBQWFPLE1BQXZEOztBQUVBLFNBQUtKLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUtBLE9BQUwsQ0FBYUssTUFBYixDQUFvQkMsQ0FBcEIsR0FBd0IsS0FBS04sT0FBTCxDQUFhSyxNQUFiLENBQW9CRSxDQUFwQixHQUF3QixLQUFLUCxPQUFMLENBQWFLLE1BQWIsQ0FBb0JHLENBQXBFOztBQUVBLFNBQUtDLElBQUwsR0FBWUMsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0IsS0FBS1gsT0FBTCxDQUFhUyxJQUEvQixDQUFaOztBQUVBLFNBQUtWLE1BQUwsR0FBY0EsTUFBZDs7QUFFQSxTQUFLYSxVQUFMLEdBQWtCLEVBQUVDLEtBQUssQ0FBUCxFQUFVQyxPQUFPLENBQWpCLEVBQW9CQyxNQUFNLENBQTFCLEVBQWxCO0FBQ0EsU0FBS0MsT0FBTCxHQUFlLEVBQUVILEtBQUssQ0FBUCxFQUFVQyxPQUFPLENBQWpCLEVBQW9CQyxNQUFNLENBQTFCLEVBQWY7O0FBRUEsU0FBS0UsR0FBTCxHQUFXLEtBQUtsQixNQUFMLENBQVltQixVQUFaLENBQXVCLElBQXZCLENBQVg7O0FBRUEsU0FBS0MsVUFBTCxHQUFrQixJQUFsQjtBQUNBLFNBQUtDLFFBQUwsR0FBZ0I7QUFDZEMsU0FBRyxLQUFLdEIsTUFBTCxDQUFZdUIsU0FERDtBQUVkQyxTQUFHLEtBQUt4QixNQUFMLENBQVl5QjtBQUZELEtBQWhCOztBQUtBLFNBQUtDLElBQUw7O0FBRUEsU0FBS0MsU0FBTCxHQUFpQixLQUFLVCxHQUFMLENBQVNVLFlBQVQsQ0FBc0IsQ0FBdEIsRUFBeUIsQ0FBekIsRUFBNEIsS0FBSzVCLE1BQUwsQ0FBWUksS0FBeEMsRUFBK0MsS0FBS0osTUFBTCxDQUFZSyxNQUEzRCxDQUFqQjtBQUNBLFNBQUt3QixPQUFMLEdBQWUsSUFBSUMsaUJBQUosQ0FBc0IsS0FBS0gsU0FBTCxDQUFlSSxJQUFyQyxDQUFmOztBQUVBLFNBQUtDLE9BQUw7QUFDQSxTQUFLZixPQUFMLEdBQWUsS0FBS0osVUFBcEI7QUFFRDs7Ozs4QkFFUzs7QUFFUixVQUFNa0IsT0FBTyxLQUFLSixTQUFMLENBQWVJLElBQTVCO0FBQ0EsVUFBTUUsSUFBSUYsS0FBS0csTUFBTCxHQUFjLENBQXhCOztBQUVBLFVBQUlwQixNQUFNLENBQVY7QUFBQSxVQUFhQyxRQUFRLENBQXJCO0FBQUEsVUFBd0JDLE9BQU8sQ0FBL0I7O0FBRUEsV0FBSyxJQUFJbUIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJSixLQUFLRyxNQUF6QixFQUFpQ0MsS0FBSyxDQUF0QyxFQUF5QztBQUN2QyxZQUFJSixLQUFLSSxDQUFMLElBQVUsQ0FBZCxFQUFpQnJCLE9BQU9pQixLQUFLSSxDQUFMLENBQVA7QUFDakIsWUFBSUosS0FBS0ksSUFBSSxDQUFULElBQWMsQ0FBbEIsRUFBcUJwQixTQUFTZ0IsS0FBS0ksSUFBSSxDQUFULENBQVQ7QUFDckIsWUFBSUosS0FBS0ksSUFBSSxDQUFULElBQWMsQ0FBbEIsRUFBcUJuQixRQUFRZSxLQUFLSSxJQUFJLENBQVQsQ0FBUjtBQUN0Qjs7QUFFRCxXQUFLdEIsVUFBTCxHQUFrQjtBQUNoQkMsYUFBS3NCLEtBQUtDLEtBQUwsQ0FBV3ZCLE1BQU1tQixDQUFqQixDQURXO0FBRWhCbEIsZUFBT3FCLEtBQUtDLEtBQUwsQ0FBV3RCLFFBQVFrQixDQUFuQixDQUZTO0FBR2hCakIsY0FBTW9CLEtBQUtDLEtBQUwsQ0FBV3JCLE9BQU9pQixDQUFsQjtBQUhVLE9BQWxCOztBQU1BLGFBQU8sSUFBUDtBQUNEOztBQUVEOzs7O3FDQUVrQjFCLEMsRUFBRytCLEssRUFBTztBQUMxQixVQUFJLENBQUMsS0FBS1gsU0FBVixFQUFxQixPQUFPLElBQVA7O0FBRXJCLFVBQU1JLE9BQU8sS0FBS0osU0FBTCxDQUFlSSxJQUE1Qjs7QUFFQSxVQUFJTyxTQUFTLEtBQWIsRUFBb0I7QUFDbEIsYUFBSyxJQUFJSCxJQUFJLENBQWIsRUFBZ0JBLElBQUlKLEtBQUtHLE1BQXpCLEVBQWlDQyxLQUFLLENBQXRDLEVBQXlDO0FBQ3ZDSixlQUFLSSxDQUFMLElBQVUsS0FBS04sT0FBTCxDQUFhTSxDQUFiLElBQWtCQyxLQUFLQyxLQUFMLENBQVc5QixDQUFYLENBQWxCLEdBQWtDLEtBQUtNLFVBQUwsQ0FBZ0JDLEdBQTVEO0FBQ0Q7QUFDRCxhQUFLa0IsT0FBTCxHQUFlZCxHQUFmLENBQW1CcUIsWUFBbkIsQ0FBZ0MsS0FBS1osU0FBckMsRUFBZ0QsQ0FBaEQsRUFBbUQsQ0FBbkQ7QUFDRDs7QUFFRCxVQUFJVyxTQUFTLE9BQWIsRUFBc0I7QUFDcEIsYUFBSyxJQUFJRSxJQUFJLENBQWIsRUFBZ0JBLElBQUlULEtBQUtHLE1BQXpCLEVBQWlDTSxLQUFLLENBQXRDLEVBQXlDO0FBQ3ZDVCxlQUFLUyxJQUFJLENBQVQsSUFBYyxLQUFLWCxPQUFMLENBQWFXLElBQUksQ0FBakIsSUFBc0JKLEtBQUtDLEtBQUwsQ0FBVzlCLENBQVgsQ0FBdEIsR0FBc0MsS0FBS00sVUFBTCxDQUFnQkUsS0FBcEU7QUFDRDtBQUNELGFBQUtpQixPQUFMLEdBQWVkLEdBQWYsQ0FBbUJxQixZQUFuQixDQUFnQyxLQUFLWixTQUFyQyxFQUFnRCxDQUFoRCxFQUFtRCxDQUFuRDtBQUNEOztBQUVELFVBQUlXLFNBQVMsTUFBYixFQUFxQjtBQUNuQixhQUFLLElBQUlHLElBQUksQ0FBYixFQUFnQkEsSUFBSVYsS0FBS0csTUFBekIsRUFBaUNPLEtBQUssQ0FBdEMsRUFBeUM7QUFDdkNWLGVBQUtVLElBQUksQ0FBVCxJQUFjLEtBQUtaLE9BQUwsQ0FBYVksSUFBSSxDQUFqQixJQUFzQkwsS0FBS0MsS0FBTCxDQUFXOUIsQ0FBWCxDQUF0QixHQUFzQyxLQUFLTSxVQUFMLENBQWdCRyxJQUFwRTtBQUNEO0FBQ0QsYUFBS2dCLE9BQUwsR0FBZWQsR0FBZixDQUFtQnFCLFlBQW5CLENBQWdDLEtBQUtaLFNBQXJDLEVBQWdELENBQWhELEVBQW1ELENBQW5EO0FBQ0Q7O0FBRUQsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7OzJCQUdPO0FBQ0wsV0FBS1QsR0FBTCxDQUFTd0IsU0FBVCxDQUFtQixLQUFLNUMsT0FBeEIsRUFBaUMsQ0FBakMsRUFBb0MsQ0FBcEMsRUFBdUMsS0FBS0UsTUFBTCxDQUFZSSxLQUFuRCxFQUEwRCxLQUFLSixNQUFMLENBQVlLLE1BQXRFO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7Ozs0QkFFTztBQUNOLFVBQU1zQyxVQUFVLElBQUlDLFNBQUosQ0FBYyxLQUFLZixPQUFuQixFQUE0QixLQUFLN0IsTUFBTCxDQUFZSSxLQUF4QyxFQUErQyxLQUFLSixNQUFMLENBQVlLLE1BQTNELENBQWhCO0FBQ0EsV0FBS2EsR0FBTCxDQUFTcUIsWUFBVCxDQUFzQkksT0FBdEIsRUFBK0IsQ0FBL0IsRUFBa0MsQ0FBbEM7QUFDQSxXQUFLaEIsU0FBTCxHQUFpQixLQUFLVCxHQUFMLENBQVNVLFlBQVQsQ0FBc0IsQ0FBdEIsRUFBeUIsQ0FBekIsRUFBNEIsS0FBSzVCLE1BQUwsQ0FBWUksS0FBeEMsRUFBK0MsS0FBS0osTUFBTCxDQUFZSyxNQUEzRCxDQUFqQjtBQUNBLFdBQUsyQixPQUFMO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7OzsrQkFFVWEsSSxFQUFNO0FBQ2YsVUFBTUMsWUFBWUMsU0FBU0MsYUFBVCxDQUF1QixRQUF2QixDQUFsQjtBQUNBRixnQkFBVTFDLEtBQVYsR0FBa0IsS0FBS0wsR0FBTCxDQUFTSyxLQUEzQjtBQUNBMEMsZ0JBQVV6QyxNQUFWLEdBQW1CLEtBQUtOLEdBQUwsQ0FBU00sTUFBNUI7O0FBRUEsVUFBTTRDLGFBQWFILFVBQVUzQixVQUFWLENBQXFCLElBQXJCLENBQW5CO0FBQ0E4QixpQkFBV1AsU0FBWCxDQUFxQixLQUFLM0MsR0FBMUIsRUFBK0IsQ0FBL0IsRUFBa0MsQ0FBbEMsRUFBcUMsS0FBS0EsR0FBTCxDQUFTSyxLQUE5QyxFQUFxRCxLQUFLTCxHQUFMLENBQVNNLE1BQTlEOztBQUVBLFVBQU02QyxVQUFVRCxXQUFXckIsWUFBWCxDQUF3QixDQUF4QixFQUEyQixDQUEzQixFQUE4QixLQUFLN0IsR0FBTCxDQUFTSyxLQUF2QyxFQUE4QyxLQUFLTCxHQUFMLENBQVNNLE1BQXZELENBQWhCOztBQUVBLFVBQUksS0FBS1EsVUFBTCxDQUFnQkMsR0FBaEIsR0FBc0IsS0FBS0csT0FBTCxDQUFhSCxHQUFuQyxJQUEwQyxDQUE5QyxFQUFpRDtBQUMvQyxhQUFLLElBQUlxQixJQUFJLENBQWIsRUFBZ0JBLElBQUllLFFBQVFuQixJQUFSLENBQWFHLE1BQWpDLEVBQXlDQyxLQUFLLENBQTlDLEVBQWlEO0FBQy9DZSxrQkFBUW5CLElBQVIsQ0FBYUksQ0FBYixLQUFvQixLQUFLdEIsVUFBTCxDQUFnQkMsR0FBaEIsR0FBc0IsS0FBS0csT0FBTCxDQUFhSCxHQUF2RDtBQUNEO0FBQ0Y7O0FBRUQsVUFBSSxLQUFLRCxVQUFMLENBQWdCRSxLQUFoQixHQUF3QixLQUFLRSxPQUFMLENBQWFGLEtBQXJDLElBQThDLENBQWxELEVBQXFEO0FBQ25ELGFBQUssSUFBSXlCLElBQUksQ0FBYixFQUFnQkEsSUFBSVUsUUFBUW5CLElBQVIsQ0FBYUcsTUFBakMsRUFBeUNNLEtBQUssQ0FBOUMsRUFBaUQ7QUFDL0NVLGtCQUFRbkIsSUFBUixDQUFhUyxJQUFJLENBQWpCLEtBQXdCLEtBQUszQixVQUFMLENBQWdCRSxLQUFoQixHQUF3QixLQUFLRSxPQUFMLENBQWFGLEtBQTdEO0FBQ0Q7QUFDRjs7QUFFRCxVQUFJLEtBQUtGLFVBQUwsQ0FBZ0JHLElBQWhCLEdBQXVCLEtBQUtDLE9BQUwsQ0FBYUQsSUFBcEMsSUFBNEMsQ0FBaEQsRUFBbUQ7QUFDakQsYUFBSyxJQUFJeUIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJUyxRQUFRbkIsSUFBUixDQUFhRyxNQUFqQyxFQUF5Q08sS0FBSyxDQUE5QyxFQUFpRDtBQUMvQ1Msa0JBQVFuQixJQUFSLENBQWFVLElBQUksQ0FBakIsS0FBd0IsS0FBSzVCLFVBQUwsQ0FBZ0JHLElBQWhCLEdBQXVCLEtBQUtDLE9BQUwsQ0FBYUQsSUFBNUQ7QUFDRDtBQUNGOztBQUVEaUMsaUJBQVdWLFlBQVgsQ0FBd0JXLE9BQXhCLEVBQWlDLENBQWpDLEVBQW9DLENBQXBDOztBQUVBLGFBQU9KLFVBQVVLLFNBQVYsQ0FBb0IsV0FBV04sSUFBL0IsQ0FBUDtBQUNEOzs7dURBRWtDOztBQUVqQyxVQUFNTywwQkFDTixLQUFLbkQsT0FBTCxDQUFhSyxNQUFiLENBQW9CRSxDQUFwQixHQUF3QixLQUFLUCxPQUFMLENBQWFvRCxLQUFiLENBQW1CQyxJQUEzQyxJQUNBLEtBQUtyRCxPQUFMLENBQWFLLE1BQWIsQ0FBb0JHLENBQXBCLEdBQXdCLEtBQUtSLE9BQUwsQ0FBYW9ELEtBQWIsQ0FBbUJDLElBRjNDOztBQUlBLFVBQUlGLHVCQUFKLEVBQTZCO0FBQzNCLFlBQUksS0FBS25ELE9BQUwsQ0FBYUssTUFBYixDQUFvQkMsQ0FBcEIsR0FBd0IsQ0FBNUIsRUFBK0I7QUFDN0IsZUFBS1QsT0FBTCxDQUFhTSxLQUFiLEdBQXFCLEtBQUtILE9BQUwsQ0FBYW9ELEtBQWIsQ0FBbUJDLElBQXhDO0FBQ0EsZUFBS3hELE9BQUwsQ0FBYU8sTUFBYixHQUFzQixLQUFLUCxPQUFMLENBQWFNLEtBQWIsR0FBcUIsS0FBS0gsT0FBTCxDQUFhSyxNQUFiLENBQW9CQyxDQUEvRDtBQUNELFNBSEQsTUFHTyxJQUFJLEtBQUtOLE9BQUwsQ0FBYUssTUFBYixDQUFvQkMsQ0FBcEIsR0FBd0IsQ0FBNUIsRUFBK0I7QUFDcEMsZUFBS1QsT0FBTCxDQUFhTyxNQUFiLEdBQXNCLEtBQUtKLE9BQUwsQ0FBYW9ELEtBQWIsQ0FBbUJDLElBQXpDO0FBQ0EsZUFBS3hELE9BQUwsQ0FBYU0sS0FBYixHQUFxQixLQUFLTixPQUFMLENBQWFPLE1BQWIsR0FBc0IsS0FBS0osT0FBTCxDQUFhSyxNQUFiLENBQW9CQyxDQUEvRDtBQUNELFNBSE0sTUFHQTtBQUNMLGVBQUtULE9BQUwsQ0FBYU0sS0FBYixHQUFxQixLQUFLTixPQUFMLENBQWFPLE1BQWIsR0FBc0IsS0FBS0osT0FBTCxDQUFhb0QsS0FBYixDQUFtQkMsSUFBOUQ7QUFDRDtBQUNGLE9BVkQsTUFVTztBQUNMLGFBQUt4RCxPQUFMLENBQWFNLEtBQWIsR0FBcUIsS0FBS0gsT0FBTCxDQUFhSyxNQUFiLENBQW9CRSxDQUF6QztBQUNBLGFBQUtWLE9BQUwsQ0FBYU8sTUFBYixHQUFzQixLQUFLSixPQUFMLENBQWFLLE1BQWIsQ0FBb0JHLENBQTFDO0FBQ0Q7QUFFRjs7O3dDQUVtQkMsSSxFQUFNO0FBQ3hCLFVBQU1WLFNBQVMrQyxTQUFTQyxhQUFULENBQXVCLFFBQXZCLENBQWY7O0FBRUF0QyxhQUFPQSxLQUFLNkMsUUFBWjtBQUNBQyxjQUFRQyxHQUFSLENBQVkvQyxJQUFaOztBQUVBLFVBQU1ZLElBQUljLEtBQUtDLEtBQUwsQ0FBYSxLQUFLdEMsR0FBTCxDQUFTSyxLQUFULEdBQWlCLEtBQUtKLE1BQUwsQ0FBWUksS0FBL0IsR0FBeUNNLEtBQUtnRCxFQUF6RCxDQUFWO0FBQ0EsVUFBTWxDLElBQUlZLEtBQUtDLEtBQUwsQ0FBYSxLQUFLdEMsR0FBTCxDQUFTTSxNQUFULEdBQWtCLEtBQUtMLE1BQUwsQ0FBWUssTUFBaEMsR0FBMkNLLEtBQUtpRCxFQUEzRCxDQUFWO0FBQ0EsVUFBTW5ELElBQUk0QixLQUFLQyxLQUFMLENBQWEsS0FBS3RDLEdBQUwsQ0FBU0ssS0FBVCxHQUFpQixLQUFLSixNQUFMLENBQVlJLEtBQS9CLEdBQXlDTSxLQUFLa0QsRUFBekQsQ0FBVjtBQUNBLFVBQU1uRCxJQUFJMkIsS0FBS0MsS0FBTCxDQUFhLEtBQUt0QyxHQUFMLENBQVNNLE1BQVQsR0FBa0IsS0FBS0wsTUFBTCxDQUFZSyxNQUFoQyxHQUEyQ0ssS0FBS21ELEVBQTNELENBQVY7O0FBRUE3RCxhQUFPSSxLQUFQLEdBQWdCLEtBQUtILE9BQUwsQ0FBYUssTUFBYixDQUFvQkUsQ0FBcEM7QUFDQVIsYUFBT0ssTUFBUCxHQUFnQixLQUFLSixPQUFMLENBQWFLLE1BQWIsQ0FBb0JHLENBQXBDOztBQUVBLFdBQUtxRCxnQ0FBTDs7QUFFQSxVQUFNQyxTQUFTLElBQUlDLEtBQUosRUFBZjtBQUNBRCxhQUFPRSxHQUFQLEdBQWEsS0FBS0MsVUFBTCxDQUFnQixNQUFoQixDQUFiOztBQUVBLFVBQU1DLFVBQVVuRSxPQUFPbUIsVUFBUCxDQUFrQixJQUFsQixDQUFoQjtBQUNBZ0QsY0FBUXpCLFNBQVIsQ0FBa0JxQixNQUFsQixFQUEwQnpDLENBQTFCLEVBQTZCRSxDQUE3QixFQUFnQ2hCLENBQWhDLEVBQW1DQyxDQUFuQyxFQUFzQyxDQUF0QyxFQUF5QyxDQUF6QyxFQUE0QyxLQUFLUixPQUFMLENBQWFLLE1BQWIsQ0FBb0JFLENBQWhFLEVBQW1FLEtBQUtQLE9BQUwsQ0FBYUssTUFBYixDQUFvQkcsQ0FBdkY7O0FBRUEsYUFBT1QsTUFBUDtBQUNEOzs7MEJBRUtVLEksRUFBTTtBQUNWLFVBQU0wRCxlQUFlLEtBQUtDLG1CQUFMLENBQXlCM0QsSUFBekIsQ0FBckI7QUFDQSxhQUFPMEQsYUFBYWpCLFNBQWIsQ0FBdUIsWUFBdkIsQ0FBUDtBQUNEOzs7MkJBRU07QUFDTCxVQUFNbUIsTUFBTSx3QkFBWjtBQUNBQSxVQUFJQyxJQUFKLENBQVMsTUFBVCxFQUFpQixLQUFLdEUsT0FBTCxDQUFhdUUsSUFBOUIsRUFBb0MsSUFBcEM7QUFDQUYsVUFBSUcsZ0JBQUosQ0FBcUIsa0JBQXJCLEVBQXdDLGdCQUF4QztBQUNBLFVBQUksS0FBS3hFLE9BQUwsQ0FBYXlFLElBQWpCLEVBQXVCSixJQUFJRyxnQkFBSixDQUFxQixjQUFyQixFQUFxQyxLQUFLeEUsT0FBTCxDQUFheUUsSUFBbEQ7QUFDdkJKLFVBQUlHLGdCQUFKLENBQXFCLGNBQXJCLEVBQXFDLGtCQUFyQztBQUNBSCxVQUFJRyxnQkFBSixDQUFxQixRQUFyQixFQUErQixrQkFBL0I7QUFDQUgsVUFBSUcsZ0JBQUosQ0FBcUIsNkJBQXJCLEVBQW9ELEdBQXBEO0FBQ0FILFVBQUlLLElBQUosQ0FBU0MsS0FBS0MsU0FBTCxDQUFlO0FBQ3RCQyxlQUFPLEtBQUsxRDtBQURVLE9BQWYsQ0FBVDtBQUdEOzs7Ozs7a0JBM01rQnZCLFUiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCByZXF1ZXN0IGZyb20gJy4vcmVxdWVzdCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFja2dyb3VuZCB7XG5cbiAgY29uc3RydWN0b3IocHJldmlldywgcmF3LCBjYW52YXMsIG9wdGlvbnMpIHtcblxuICAgIHRoaXMucHJldmlldyA9IHByZXZpZXdcbiAgICB0aGlzLnJhdyA9IHJhd1xuICAgIHRoaXMucHJldmlldy5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnXG4gICAgdGhpcy5wcmV2aWV3LnJhdGlvID0gdGhpcy5wcmV2aWV3LndpZHRoIC8gdGhpcy5wcmV2aWV3LmhlaWdodFxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucy5vdXRwdXQuciA9IHRoaXMub3B0aW9ucy5vdXRwdXQudyAvIHRoaXMub3B0aW9ucy5vdXRwdXQuaFxuXG4gICAgdGhpcy5jbGlwID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLmNsaXApXG5cbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhc1xuXG4gICAgdGhpcy5yZ2JBdmVyYWdlID0geyByZWQ6IDAsIGdyZWVuOiAwLCBibHVlOiAwIH1cbiAgICB0aGlzLnJnYkRpZmYgPSB7IHJlZDogMCwgZ3JlZW46IDAsIGJsdWU6IDAgfVxuXG4gICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG5cbiAgICB0aGlzLnJlc3VsdERhdGEgPSBudWxsXG4gICAgdGhpcy5wb3NpdGlvbiA9IHtcbiAgICAgIHg6IHRoaXMuY2FudmFzLm9mZnNldFRvcCxcbiAgICAgIHk6IHRoaXMuY2FudmFzLm9mZnNldExlZnRcbiAgICB9XG5cbiAgICB0aGlzLmRyYXcoKVxuXG4gICAgdGhpcy5pbWFnZURhdGEgPSB0aGlzLmN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodClcbiAgICB0aGlzLnNyY0RhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkodGhpcy5pbWFnZURhdGEuZGF0YSlcblxuICAgIHRoaXMuYXZlcmFnZSgpXG4gICAgdGhpcy5yZ2JEaWZmID0gdGhpcy5yZ2JBdmVyYWdlXG5cbiAgfVxuXG4gIGF2ZXJhZ2UoKSB7XG5cbiAgICBjb25zdCBkYXRhID0gdGhpcy5pbWFnZURhdGEuZGF0YVxuICAgIGNvbnN0IG0gPSBkYXRhLmxlbmd0aCAvIDNcblxuICAgIGxldCByZWQgPSAwLCBncmVlbiA9IDAsIGJsdWUgPSAwXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGlmIChkYXRhW2ldID4gMCkgcmVkICs9IGRhdGFbaV1cbiAgICAgIGlmIChkYXRhW2kgKyAxXSA+IDApIGdyZWVuICs9IGRhdGFbaSArIDFdXG4gICAgICBpZiAoZGF0YVtpICsgMl0gPiAwKSBibHVlICs9IGRhdGFbaSArIDJdXG4gICAgfVxuXG4gICAgdGhpcy5yZ2JBdmVyYWdlID0ge1xuICAgICAgcmVkOiBNYXRoLnJvdW5kKHJlZCAvIG0pLFxuICAgICAgZ3JlZW46IE1hdGgucm91bmQoZ3JlZW4gLyBtKSxcbiAgICAgIGJsdWU6IE1hdGgucm91bmQoYmx1ZSAvIG0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PSAgY2hhbmdlIGNvbG9yIGxldmVsICA9PT09PT09PT09PT09PT09PVxuXG4gIGNoYW5nZUNvbG9yTGV2ZWwgKHIsIGNvbG9yKSB7XG4gICAgaWYgKCF0aGlzLmltYWdlRGF0YSkgcmV0dXJuIHRoaXNcblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmltYWdlRGF0YS5kYXRhXG5cbiAgICBpZiAoY29sb3IgPT0gJ3JlZCcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBkYXRhW2ldID0gdGhpcy5zcmNEYXRhW2ldICsgTWF0aC5yb3VuZChyKSAtIHRoaXMucmdiQXZlcmFnZS5yZWRcbiAgICAgIH1cbiAgICAgIHRoaXMuYXZlcmFnZSgpLmN0eC5wdXRJbWFnZURhdGEodGhpcy5pbWFnZURhdGEsIDAsIDApXG4gICAgfVxuXG4gICAgaWYgKGNvbG9yID09ICdncmVlbicpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YS5sZW5ndGg7IGogKz0gNCkge1xuICAgICAgICBkYXRhW2ogKyAxXSA9IHRoaXMuc3JjRGF0YVtqICsgMV0gKyBNYXRoLnJvdW5kKHIpIC0gdGhpcy5yZ2JBdmVyYWdlLmdyZWVuXG4gICAgICB9XG4gICAgICB0aGlzLmF2ZXJhZ2UoKS5jdHgucHV0SW1hZ2VEYXRhKHRoaXMuaW1hZ2VEYXRhLCAwLCAwKVxuICAgIH1cblxuICAgIGlmIChjb2xvciA9PSAnYmx1ZScpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGF0YS5sZW5ndGg7IGsgKz0gNCkge1xuICAgICAgICBkYXRhW2sgKyAyXSA9IHRoaXMuc3JjRGF0YVtrICsgMl0gKyBNYXRoLnJvdW5kKHIpIC0gdGhpcy5yZ2JBdmVyYWdlLmJsdWVcbiAgICAgIH1cbiAgICAgIHRoaXMuYXZlcmFnZSgpLmN0eC5wdXRJbWFnZURhdGEodGhpcy5pbWFnZURhdGEsIDAsIDApXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgZHJhdygpIHtcbiAgICB0aGlzLmN0eC5kcmF3SW1hZ2UodGhpcy5wcmV2aWV3LCAwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjbGVhcigpIHtcbiAgICBjb25zdCBpbml0aWFsID0gbmV3IEltYWdlRGF0YSh0aGlzLnNyY0RhdGEsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpXG4gICAgdGhpcy5jdHgucHV0SW1hZ2VEYXRhKGluaXRpYWwsIDAsIDApXG4gICAgdGhpcy5pbWFnZURhdGEgPSB0aGlzLmN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodClcbiAgICB0aGlzLmF2ZXJhZ2UoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBhcHBseVRvUmF3KHR5cGUpIHtcbiAgICBjb25zdCBjYW52YXNSYXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgIGNhbnZhc1Jhdy53aWR0aCA9IHRoaXMucmF3LndpZHRoXG4gICAgY2FudmFzUmF3LmhlaWdodCA9IHRoaXMucmF3LmhlaWdodFxuXG4gICAgY29uc3QgcmF3Q29udGV4dCA9IGNhbnZhc1Jhdy5nZXRDb250ZXh0KCcyZCcpXG4gICAgcmF3Q29udGV4dC5kcmF3SW1hZ2UodGhpcy5yYXcsIDAsIDAsIHRoaXMucmF3LndpZHRoLCB0aGlzLnJhdy5oZWlnaHQpXG5cbiAgICBjb25zdCByYXdEYXRhID0gcmF3Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy5yYXcud2lkdGgsIHRoaXMucmF3LmhlaWdodClcblxuICAgIGlmICh0aGlzLnJnYkF2ZXJhZ2UucmVkIC0gdGhpcy5yZ2JEaWZmLnJlZCAhPSAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0RhdGEuZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICByYXdEYXRhLmRhdGFbaV0gKz0gKHRoaXMucmdiQXZlcmFnZS5yZWQgLSB0aGlzLnJnYkRpZmYucmVkKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnJnYkF2ZXJhZ2UuZ3JlZW4gLSB0aGlzLnJnYkRpZmYuZ3JlZW4gIT0gMCkge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByYXdEYXRhLmRhdGEubGVuZ3RoOyBqICs9IDQpIHtcbiAgICAgICAgcmF3RGF0YS5kYXRhW2ogKyAxXSArPSAodGhpcy5yZ2JBdmVyYWdlLmdyZWVuIC0gdGhpcy5yZ2JEaWZmLmdyZWVuKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnJnYkF2ZXJhZ2UuYmx1ZSAtIHRoaXMucmdiRGlmZi5ibHVlICE9IDApIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmF3RGF0YS5kYXRhLmxlbmd0aDsgayArPSA0KSB7XG4gICAgICAgIHJhd0RhdGEuZGF0YVtrICsgMl0gKz0gKHRoaXMucmdiQXZlcmFnZS5ibHVlIC0gdGhpcy5yZ2JEaWZmLmJsdWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmF3Q29udGV4dC5wdXRJbWFnZURhdGEocmF3RGF0YSwgMCwgMClcblxuICAgIHJldHVybiBjYW52YXNSYXcudG9EYXRhVVJMKCdpbWFnZS8nICsgdHlwZSlcbiAgfVxuXG4gIHJlc2l6ZVByZXZpZXdEZXBlbmRpbmdUaGFuT3V0cHV0KCkge1xuXG4gICAgY29uc3Qgb3V0cHV0SXNCaWdnZXJUaGFuQm9hcmQgPVxuICAgIHRoaXMub3B0aW9ucy5vdXRwdXQudyA+IHRoaXMub3B0aW9ucy5ib2FyZC5zaWRlIHx8XG4gICAgdGhpcy5vcHRpb25zLm91dHB1dC5oID4gdGhpcy5vcHRpb25zLmJvYXJkLnNpZGVcblxuICAgIGlmIChvdXRwdXRJc0JpZ2dlclRoYW5Cb2FyZCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdXRwdXQuciA+IDEpIHtcbiAgICAgICAgdGhpcy5wcmV2aWV3LndpZHRoID0gdGhpcy5vcHRpb25zLmJvYXJkLnNpZGVcbiAgICAgICAgdGhpcy5wcmV2aWV3LmhlaWdodCA9IHRoaXMucHJldmlldy53aWR0aCAvIHRoaXMub3B0aW9ucy5vdXRwdXQuclxuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMub3V0cHV0LnIgPCAxKSB7XG4gICAgICAgIHRoaXMucHJldmlldy5oZWlnaHQgPSB0aGlzLm9wdGlvbnMuYm9hcmQuc2lkZVxuICAgICAgICB0aGlzLnByZXZpZXcud2lkdGggPSB0aGlzLnByZXZpZXcuaGVpZ2h0ICogdGhpcy5vcHRpb25zLm91dHB1dC5yXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZXZpZXcud2lkdGggPSB0aGlzLnByZXZpZXcuaGVpZ2h0ID0gdGhpcy5vcHRpb25zLmJvYXJkLnNpZGVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmV2aWV3LndpZHRoID0gdGhpcy5vcHRpb25zLm91dHB1dC53XG4gICAgICB0aGlzLnByZXZpZXcuaGVpZ2h0ID0gdGhpcy5vcHRpb25zLm91dHB1dC5oXG4gICAgfVxuXG4gIH1cblxuICBhcHBseVRvTmV3ZXN0Q2FudmFzKGNsaXApIHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuXG4gICAgY2xpcCA9IGNsaXAuc2VsZWN0ZWRcbiAgICBjb25zb2xlLmxvZyhjbGlwKVxuXG4gICAgY29uc3QgeCA9IE1hdGgucm91bmQoKCB0aGlzLnJhdy53aWR0aCAvIHRoaXMuY2FudmFzLndpZHRoICkgKiBjbGlwLnN4IClcbiAgICBjb25zdCB5ID0gTWF0aC5yb3VuZCgoIHRoaXMucmF3LmhlaWdodCAvIHRoaXMuY2FudmFzLmhlaWdodCApICogY2xpcC5zeSApXG4gICAgY29uc3QgdyA9IE1hdGgucm91bmQoKCB0aGlzLnJhdy53aWR0aCAvIHRoaXMuY2FudmFzLndpZHRoICkgKiBjbGlwLnN3IClcbiAgICBjb25zdCBoID0gTWF0aC5yb3VuZCgoIHRoaXMucmF3LmhlaWdodCAvIHRoaXMuY2FudmFzLmhlaWdodCApICogY2xpcC5zaCApXG5cbiAgICBjYW52YXMud2lkdGggID0gdGhpcy5vcHRpb25zLm91dHB1dC53XG4gICAgY2FudmFzLmhlaWdodCA9IHRoaXMub3B0aW9ucy5vdXRwdXQuaFxuXG4gICAgdGhpcy5yZXNpemVQcmV2aWV3RGVwZW5kaW5nVGhhbk91dHB1dCgpXG5cbiAgICBjb25zdCBuZXdlc3QgPSBuZXcgSW1hZ2UoKVxuICAgIG5ld2VzdC5zcmMgPSB0aGlzLmFwcGx5VG9SYXcoJ2pwZWcnKVxuXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgY29udGV4dC5kcmF3SW1hZ2UobmV3ZXN0LCB4LCB5LCB3LCBoLCAwLCAwLCB0aGlzLm9wdGlvbnMub3V0cHV0LncsIHRoaXMub3B0aW9ucy5vdXRwdXQuaClcblxuICAgIHJldHVybiBjYW52YXNcbiAgfVxuXG4gIGFwcGx5KGNsaXApIHtcbiAgICBjb25zdCBuZXdlc3RDYW52YXMgPSB0aGlzLmFwcGx5VG9OZXdlc3RDYW52YXMoY2xpcClcbiAgICByZXR1cm4gbmV3ZXN0Q2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycpXG4gIH1cblxuICBzYXZlKCkge1xuICAgIGNvbnN0IHhociA9IHJlcXVlc3QoKVxuICAgIHhoci5vcGVuKCdQT1NUJywgdGhpcy5vcHRpb25zLmRlc3QsIHRydWUpXG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1gtUmVxdWVzdGVkLVdpdGgnLCd4bWxodHRwcmVxdWVzdCcpXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jc3JmKSB4aHIuc2V0UmVxdWVzdEhlYWRlcignWC1DU1JGLVRva2VuJywgdGhpcy5vcHRpb25zLmNzcmYpXG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJylcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nLCAnKicpXG4gICAgeGhyLnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdmFsdWU6IHRoaXMucmVzdWx0RGF0YVxuICAgIH0pKVxuICB9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYWNrZ3JvdW5kLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Clip = function () {\n  function Clip(canvas, options) {\n    _classCallCheck(this, Clip);\n\n    this.selected = { sx: 0, sy: 0, sw: 0, sh: 0 };\n\n    this.canvas = canvas;\n    this.ctx = this.canvas.getContext('2d');\n    this.options = options;\n\n    this.clip = {};\n\n    this.output_ratio = options.output.w / options.output.h;\n\n    this.ctx.fillStyle = this.options.clip.s;\n\n    if (this.output_ratio > 1) {\n      this.clip.w = this.canvas.width * 0.8;\n      this.clip.h = this.clip.w / this.output_ratio;\n    } else if (this.output_ratio < 1) {\n      this.clip.h = this.canvas.height * 0.8;\n      this.clip.w = this.clip.h * this.output_ratio;\n    } else {\n      this.clip.w = this.clip.h = this.canvas.height * 0.8;\n    }\n\n    this.mousePos = {\n      x: this.canvas.width / 2,\n      y: this.canvas.height / 2\n    };\n\n    this.l = { x: 0, y: 0, w: 0, h: this.canvas.height };\n    this.r = { x: 0, y: 0, w: 0, h: this.canvas.height };\n    this.t = { x: 0, y: 0, w: 0, h: 0 };\n    this.b = { x: 0, y: 0, w: 0, h: 0 };\n\n    this.dragging = false;\n\n    // ========= event ================>\n    this.canvas.addEventListener('mousedown', this.onDown.bind(this), false);\n    this.canvas.addEventListener('mouseup', this.onUp.bind(this), false);\n    this.canvas.addEventListener('mousemove', this.onMove.bind(this), false);\n    this.canvas.addEventListener('wheel', this.onWheel.bind(this), false);\n    this.canvas.addEventListener('mouseleave', this.onLeave.bind(this), false);\n\n    this.draw();\n  }\n\n  _createClass(Clip, [{\n    key: 'draw',\n    value: function draw() {\n\n      this.l.w = this.mousePos.x - this.clip.w / 2;\n\n      this.r.x = this.mousePos.x + this.clip.w / 2;\n      this.r.w = this.canvas.width - this.clip.w - this.l.w;\n\n      this.t.x = this.l.w;\n      this.t.w = this.clip.w;\n\n      this.t.h = this.mousePos.y - this.clip.h / 2;\n\n      this.b.x = this.l.w;\n      this.b.w = this.clip.w;\n      this.b.y = this.t.h + this.clip.h;\n      this.b.h = this.canvas.height - this.b.y;\n\n      // left limit\n      if (this.l.w < 0) {\n        this.l.w = this.t.x = this.b.x = 0;\n        this.r.x = this.t.w = this.b.w = this.clip.w;\n      }\n\n      // right limit\n      if (this.r.w < 0) {\n        this.r.x = 0;\n        this.l.w = this.t.x = this.b.x = this.canvas.width - this.clip.w;\n      }\n\n      // top limit\n      if (this.t.h < 0) {\n        this.t.h = 0;\n        this.b.y = this.clip.h;\n        this.b.h = this.canvas.height - this.clip.h;\n      }\n\n      // bottom limit\n      if (this.b.h < 0) {\n        this.b.h = 0;\n        this.t.h = this.canvas.height - this.clip.h;\n      }\n\n      this.selected = {\n        sx: this.t.x,\n        sy: this.t.h,\n        sw: this.clip.w,\n        sh: this.clip.h\n      };\n\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n      this.ctx.fillRect(this.l.x, this.l.y, this.l.w, this.l.h);\n      this.ctx.fillRect(this.r.x, this.r.y, this.r.w, this.r.h);\n      this.ctx.fillRect(this.t.x, this.t.y, this.t.w, this.t.h);\n      this.ctx.fillRect(this.b.x, this.b.y, this.b.w, this.b.h);\n    }\n  }, {\n    key: 'onLeave',\n    value: function onLeave() {\n      this.dragging = false;\n    }\n  }, {\n    key: 'positioning',\n    value: function positioning(x, y) {\n      this.mousePos.x = x;\n      this.mousePos.y = y;\n      console.log(this.mousePos);\n      this.draw();\n    }\n  }, {\n    key: 'onWheel',\n    value: function onWheel(event) {\n      if (event.deltaY < 0) this.zIn();else this.zOut();\n      this.draw();\n      event.preventDefault();\n    }\n  }, {\n    key: 'onUp',\n    value: function onUp() {\n      this.dragging = false;\n    }\n  }, {\n    key: 'onDown',\n    value: function onDown(event) {\n      this.dragging = true;\n      var reposition = this.canvas.getBoundingClientRect();\n      this.positioning(event.pageX - reposition.left, event.pageY - reposition.top);\n    }\n  }, {\n    key: 'onMove',\n    value: function onMove(event) {\n      if (this.dragging) {\n        this.dragging = true;\n        var reposition = this.canvas.getBoundingClientRect();\n        this.positioning(event.pageX - reposition.left, event.pageY - reposition.top);\n      }\n    }\n  }, {\n    key: 'zIn',\n    value: function zIn() {\n      this.clip.w -= 1;\n      this.clip.h = this.clip.w / this.output_ratio;\n    }\n  }, {\n    key: 'zOut',\n    value: function zOut() {\n      this.clip.w += 1;\n      this.clip.h = this.clip.w / this.output_ratio;\n    }\n  }]);\n\n  return Clip;\n}();\n\nexports.default = Clip;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2xpcC5qcz80ZDExIl0sIm5hbWVzIjpbIkNsaXAiLCJjYW52YXMiLCJvcHRpb25zIiwic2VsZWN0ZWQiLCJzeCIsInN5Iiwic3ciLCJzaCIsImN0eCIsImdldENvbnRleHQiLCJjbGlwIiwib3V0cHV0X3JhdGlvIiwib3V0cHV0IiwidyIsImgiLCJmaWxsU3R5bGUiLCJzIiwid2lkdGgiLCJoZWlnaHQiLCJtb3VzZVBvcyIsIngiLCJ5IiwibCIsInIiLCJ0IiwiYiIsImRyYWdnaW5nIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uRG93biIsImJpbmQiLCJvblVwIiwib25Nb3ZlIiwib25XaGVlbCIsIm9uTGVhdmUiLCJkcmF3IiwiY2xlYXJSZWN0IiwiZmlsbFJlY3QiLCJjb25zb2xlIiwibG9nIiwiZXZlbnQiLCJkZWx0YVkiLCJ6SW4iLCJ6T3V0IiwicHJldmVudERlZmF1bHQiLCJyZXBvc2l0aW9uIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicG9zaXRpb25pbmciLCJwYWdlWCIsImxlZnQiLCJwYWdlWSIsInRvcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztJQUFxQkEsSTtBQUVuQixnQkFBWUMsTUFBWixFQUFvQkMsT0FBcEIsRUFBNkI7QUFBQTs7QUFFM0IsU0FBS0MsUUFBTCxHQUFnQixFQUFFQyxJQUFJLENBQU4sRUFBU0MsSUFBSSxDQUFiLEVBQWdCQyxJQUFJLENBQXBCLEVBQXVCQyxJQUFHLENBQTFCLEVBQWhCOztBQUVBLFNBQUtOLE1BQUwsR0FBY0EsTUFBZDtBQUNBLFNBQUtPLEdBQUwsR0FBVyxLQUFLUCxNQUFMLENBQVlRLFVBQVosQ0FBdUIsSUFBdkIsQ0FBWDtBQUNBLFNBQUtQLE9BQUwsR0FBZUEsT0FBZjs7QUFFQSxTQUFLUSxJQUFMLEdBQVksRUFBWjs7QUFFQSxTQUFLQyxZQUFMLEdBQW9CVCxRQUFRVSxNQUFSLENBQWVDLENBQWYsR0FBbUJYLFFBQVFVLE1BQVIsQ0FBZUUsQ0FBdEQ7O0FBRUEs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O0FBQ0FLLFlBQU1JLGNBQU47QUFDRDs7OzJCQUVNO0FBQ0wsV0FBS2pCLFFBQUwsR0FBZ0IsS0FBaEI7QUFDRDs7OzJCQUVNYSxLLEVBQU87QUFDWixXQUFLYixRQUFMLEdBQWdCLElBQWhCO0FBQ0EsVUFBTWtCLGFBQWEsS0FBSzNDLE1BQUwsQ0FBWTRDLHFCQUFaLEVBQW5CO0FBQ0EsV0FBS0MsV0FBTCxDQUFpQlAsTUFBTVEsS0FBTixHQUFjSCxXQUFXSSxJQUExQyxFQUFnRFQsTUFBTVUsS0FBTixHQUFjTCxXQUFXTSxHQUF6RTtBQUNEOzs7MkJBRU1YLEssRUFBTztBQUNaLFVBQUksS0FBS2IsUUFBVCxFQUFtQjtBQUNqQixhQUFLQSxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsWUFBTWtCLGFBQWEsS0FBSzNDLE1BQUwsQ0FBWTRDLHFCQUFaLEVBQW5CO0FBQ0EsYUFBS0MsV0FBTCxDQUFpQlAsTUFBTVEsS0FBTixHQUFjSCxXQUFXSSxJQUExQyxFQUFnRFQsTUFBTVUsS0FBTixHQUFjTCxXQUFXTSxHQUF6RTtBQUNEO0FBQ0Y7OzswQkFFSztBQUNKLFdBQUt4QyxJQUFMLENBQVVHLENBQVYsSUFBZSxDQUFmO0FBQ0EsV0FBS0gsSUFBTCxDQUFVSSxDQUFWLEdBQWMsS0FBS0osSUFBTCxDQUFVRyxDQUFWLEdBQWMsS0FBS0YsWUFBakM7QUFDRDs7OzJCQUVNO0FBQ0wsV0FBS0QsSUFBTCxDQUFVRyxDQUFWLElBQWUsQ0FBZjtBQUNBLFdBQUtILElBQUwsQ0FBVUksQ0FBVixHQUFjLEtBQUtKLElBQUwsQ0FBVUcsQ0FBVixHQUFjLEtBQUtGLFlBQWpDO0FBQ0Q7Ozs7OztrQkFySmtCWCxJIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBDbGlwIHtcblxuICBjb25zdHJ1Y3RvcihjYW52YXMsIG9wdGlvbnMpIHtcblxuICAgIHRoaXMuc2VsZWN0ZWQgPSB7IHN4OiAwLCBzeTogMCwgc3c6IDAsIHNoOjAgfVxuXG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXNcbiAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG5cbiAgICB0aGlzLmNsaXAgPSB7fVxuXG4gICAgdGhpcy5vdXRwdXRfcmF0aW8gPSBvcHRpb25zLm91dHB1dC53IC8gb3B0aW9ucy5vdXRwdXQuaFxuXG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5vcHRpb25zLmNsaXAuc1xuXG4gICAgaWYgKHRoaXMub3V0cHV0X3JhdGlvID4gMSkge1xuICAgICAgdGhpcy5jbGlwLncgPSB0aGlzLmNhbnZhcy53aWR0aCAqIDAuOFxuICAgICAgdGhpcy5jbGlwLmggPSB0aGlzLmNsaXAudyAvIHRoaXMub3V0cHV0X3JhdGlvXG4gICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dF9yYXRpbyA8IDEpIHtcbiAgICAgIHRoaXMuY2xpcC5oID0gdGhpcy5jYW52YXMuaGVpZ2h0ICogMC44XG4gICAgICB0aGlzLmNsaXAudyA9IHRoaXMuY2xpcC5oICogdGhpcy5vdXRwdXRfcmF0aW9cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGlwLncgPSB0aGlzLmNsaXAuaCA9IHRoaXMuY2FudmFzLmhlaWdodCAqIDAuOFxuICAgIH1cblxuICAgIHRoaXMubW91c2VQb3MgPSB7XG4gICAgICB4OiB0aGlzLmNhbnZhcy53aWR0aCAvIDIsXG4gICAgICB5OiB0aGlzLmNhbnZhcy5oZWlnaHQgLyAyXG4gICAgfVxuXG4gICAgdGhpcy5sID0geyB4OiAwLCB5OiAwLCB3OiAwLCBoOiB0aGlzLmNhbnZhcy5oZWlnaHQgfVxuICAgIHRoaXMuciA9IHsgeDogMCwgeTogMCwgdzogMCwgaDogdGhpcy5jYW52YXMuaGVpZ2h0IH1cbiAgICB0aGlzLnQgPSB7IHg6IDAsIHk6IDAsIHc6IDAsIGg6IDAgfVxuICAgIHRoaXMuYiA9IHsgeDogMCwgeTogMCwgdzogMCwgaDogMCB9XG5cbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2VcblxuICAgIC8vID09PT09PT09PSBldmVudCA9PT09PT09PT09PT09PT09PlxuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Eb3duLmJpbmQodGhpcyksIGZhbHNlKVxuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uVXAuYmluZCh0aGlzKSwgZmFsc2UpXG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdmUuYmluZCh0aGlzKSwgZmFsc2UpXG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uV2hlZWwuYmluZCh0aGlzKSwgZmFsc2UpXG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25MZWF2ZS5iaW5kKHRoaXMpLCBmYWxzZSlcblxuICAgIHRoaXMuZHJhdygpXG4gIH1cblxuICBkcmF3KCkge1xuXG4gICAgdGhpcy5sLncgPSB0aGlzLm1vdXNlUG9zLnggLSB0aGlzLmNsaXAudyAvIDJcblxuICAgIHRoaXMuci54ID0gdGhpcy5tb3VzZVBvcy54ICsgdGhpcy5jbGlwLncgLyAyXG4gICAgdGhpcy5yLncgPSB0aGlzLmNhbnZhcy53aWR0aCAtIHRoaXMuY2xpcC53IC0gdGhpcy5sLndcblxuICAgIHRoaXMudC54ID0gdGhpcy5sLndcbiAgICB0aGlzLnQudyA9IHRoaXMuY2xpcC53XG5cbiAgICB0aGlzLnQuaCA9IHRoaXMubW91c2VQb3MueSAtICh0aGlzLmNsaXAuaCAvIDIpXG5cbiAgICB0aGlzLmIueCA9IHRoaXMubC53XG4gICAgdGhpcy5iLncgPSB0aGlzLmNsaXAud1xuICAgIHRoaXMuYi55ID0gdGhpcy50LmggKyB0aGlzLmNsaXAuaFxuICAgIHRoaXMuYi5oID0gdGhpcy5jYW52YXMuaGVpZ2h0IC0gdGhpcy5iLnlcblxuICAgIC8vIGxlZnQgbGltaXRcbiAgICBpZiAodGhpcy5sLncgPCAwKSB7XG4gICAgICB0aGlzLmwudyA9IHRoaXMudC54ID0gdGhpcy5iLnggPSAwXG4gICAgICB0aGlzLnIueCA9IHRoaXMudC53ID0gdGhpcy5iLncgPSB0aGlzLmNsaXAud1xuICAgIH1cblxuICAgIC8vIHJpZ2h0IGxpbWl0XG4gICAgaWYgKHRoaXMuci53IDwgMCkge1xuICAgICAgdGhpcy5yLnggPSAwXG4gICAgICB0aGlzLmwudyA9IHRoaXMudC54ID0gdGhpcy5iLnggPSB0aGlzLmNhbnZhcy53aWR0aCAtIHRoaXMuY2xpcC53XG4gICAgfVxuXG4gICAgLy8gdG9wIGxpbWl0XG4gICAgaWYgKHRoaXMudC5oIDwgMCkge1xuICAgICAgdGhpcy50LmggPSAwXG4gICAgICB0aGlzLmIueSA9IHRoaXMuY2xpcC5oXG4gICAgICB0aGlzLmIuaCA9IHRoaXMuY2FudmFzLmhlaWdodCAtIHRoaXMuY2xpcC5oXG4gICAgfVxuXG4gICAgLy8gYm90dG9tIGxpbWl0XG4gICAgaWYgKHRoaXMuYi5oIDwgMCkge1xuICAgICAgdGhpcy5iLmggPSAwXG4gICAgICB0aGlzLnQuaCA9IHRoaXMuY2FudmFzLmhlaWdodCAtIHRoaXMuY2xpcC5oXG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3RlZCA9IHtcbiAgICAgIHN4OiB0aGlzLnQueCxcbiAgICAgIHN5OiB0aGlzLnQuaCxcbiAgICAgIHN3OiB0aGlzLmNsaXAudyxcbiAgICAgIHNoOiB0aGlzLmNsaXAuaFxuICAgIH1cblxuICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KVxuXG4gICAgdGhpcy5jdHguZmlsbFJlY3QodGhpcy5sLngsIHRoaXMubC55LCB0aGlzLmwudywgdGhpcy5sLmgpXG4gICAgdGhpcy5jdHguZmlsbFJlY3QodGhpcy5yLngsIHRoaXMuci55LCB0aGlzLnIudywgdGhpcy5yLmgpXG4gICAgdGhpcy5jdHguZmlsbFJlY3QodGhpcy50LngsIHRoaXMudC55LCB0aGlzLnQudywgdGhpcy50LmgpXG4gICAgdGhpcy5jdHguZmlsbFJlY3QodGhpcy5iLngsIHRoaXMuYi55LCB0aGlzLmIudywgdGhpcy5iLmgpXG4gIH1cblxuICBvbkxlYXZlKCkge1xuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZVxuICB9XG5cbiAgcG9zaXRpb25pbmcoeCx5KSB7XG4gICAgdGhpcy5tb3VzZVBvcy54ID0geFxuICAgIHRoaXMubW91c2VQb3MueSA9IHlcbiAgICBjb25zb2xlLmxvZyh0aGlzLm1vdXNlUG9zKVxuICAgIHRoaXMuZHJhdygpXG4gIH1cblxuICBvbldoZWVsKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmRlbHRhWSA8IDApIHRoaXMuekluKClcbiAgICBlbHNlIHRoaXMuek91dCgpXG4gICAgdGhpcy5kcmF3KClcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBvblVwKCkge1xuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZVxuICB9XG5cbiAgb25Eb3duKGV2ZW50KSB7XG4gICAgdGhpcy5kcmFnZ2luZyA9IHRydWVcbiAgICBjb25zdCByZXBvc2l0aW9uID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICB0aGlzLnBvc2l0aW9uaW5nKGV2ZW50LnBhZ2VYIC0gcmVwb3NpdGlvbi5sZWZ0LCBldmVudC5wYWdlWSAtIHJlcG9zaXRpb24udG9wKVxuICB9XG5cbiAgb25Nb3ZlKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlXG4gICAgICBjb25zdCByZXBvc2l0aW9uID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIHRoaXMucG9zaXRpb25pbmcoZXZlbnQucGFnZVggLSByZXBvc2l0aW9uLmxlZnQsIGV2ZW50LnBhZ2VZIC0gcmVwb3NpdGlvbi50b3ApXG4gICAgfVxuICB9XG5cbiAgekluKCkge1xuICAgIHRoaXMuY2xpcC53IC09IDFcbiAgICB0aGlzLmNsaXAuaCA9IHRoaXMuY2xpcC53IC8gdGhpcy5vdXRwdXRfcmF0aW9cbiAgfVxuXG4gIHpPdXQoKSB7XG4gICAgdGhpcy5jbGlwLncgKz0gMVxuICAgIHRoaXMuY2xpcC5oID0gdGhpcy5jbGlwLncgLyB0aGlzLm91dHB1dF9yYXRpb1xuICB9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jbGlwLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _debug = __webpack_require__(6);\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar create = (0, _debug2.default)('getElement:create');\nvar skip = (0, _debug2.default)('getElement:skip');\n\nexports.default = function (obj, options) {\n  var className = options.className,\n      id = options.id,\n      type = options.type,\n      alt = options.alt,\n      text = options.text;\n\n\n  var el = id ? document.getElementById(id) : document.getElementsByClassName(className)[0];\n  var info = '';\n\n  if (id) info += ' id: ' + id + ' ';\n  if (className) info += ' className: ' + className + ' ';\n  if (type) info += ' type: ' + type + ' ';\n  if (alt) info += ' alt: ' + alt + ' ';\n\n  if (!el) {\n    el = document.createElement(obj);\n\n    if (id) el.id = id;\n    if (className) el.className = className;\n    if (type) el.type = type;\n    if (alt) el.alt = alt;\n\n    if (text) el.appendChild(document.createTextNode(text));\n\n    create('create a new ' + obj + ' ' + info);\n  } else {\n    skip(info + ' - ' + obj + ' exist => skip');\n  }\n\n  return el;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZ2V0RWxlbWVudC5qcz8zOWM3Il0sIm5hbWVzIjpbImNyZWF0ZSIsInNraXAiLCJvYmoiLCJvcHRpb25zIiwiY2xhc3NOYW1lIiwiaWQiLCJ0eXBlIiwiYWx0IiwidGV4dCIsImVsIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJpbmZvIiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7QUFDQSxJQUFNQSxTQUFTLHFCQUFNLG1CQUFOLENBQWY7QUFDQSxJQUFNQyxPQUFPLHFCQUFNLGlCQUFOLENBQWI7O2tCQUVlLFVBQUNDLEdBQUQsRUFBTUMsT0FBTixFQUFrQjtBQUFBLE1BQ3ZCQyxTQUR1QixHQUNZRCxPQURaLENBQ3ZCQyxTQUR1QjtBQUFBLE1BQ1pDLEVBRFksR0FDWUYsT0FEWixDQUNaRSxFQURZO0FBQUEsTUFDUkMsSUFEUSxHQUNZSCxPQURaLENBQ1JHLElBRFE7QUFBQSxNQUNGQyxHQURFLEdBQ1lKLE9BRFosQ0FDRkksR0FERTtBQUFBLE1BQ0dDLElBREgsR0FDWUwsT0FEWixDQUNHSyxJQURIOzs7QUFHL0IsTUFBSUMsS0FBTUosRUFBRCxHQUFPSyxTQUFTQyxjQUFULENBQXdCTixFQUF4QixDQUFQLEdBQXFDSyxTQUFTRSxzQkFBVCxDQUFnQ1IsU0FBaEMsRUFBMkMsQ0FBM0MsQ0FBOUM7QUFDQSxNQUFJUyxPQUFPLEVBQVg7O0FBRUEsTUFBSVIsRUFBSixFQUFRUSxrQkFBZ0JSLEVBQWhCO0FBQ1IsTUFBSUQsU0FBSixFQUFlUyx5QkFBdUJULFNBQXZCO0FBQ2YsTUFBSUUsSUFBSixFQUFVTyxvQkFBa0JQLElBQWxCO0FBQ1YsTUFBSUMsR0FBSixFQUFTTSxtQkFBaUJOLEdBQWpCOztBQUVULE1BQUksQ0FBQ0UsRUFBTCxFQUFTO0FBQ1BBLFNBQUtDLFNBQVNJLGFBQVQsQ0FBdUJaLEdBQXZCLENBQUw7O0FBRUEsUUFBSUcsRUFBSixFQUFRSSxHQUFHSixFQUFILEdBQVFBLEVBQVI7QUFDUixRQUFJRCxTQUFKLEVBQWVLLEdBQUdMLFNBQUgsR0FBZUEsU0FBZjtBQUNmLFFBQUlFLElBQUosRUFBVUcsR0FBR0gsSUFBSCxHQUFVQSxJQUFWO0FBQ1YsUUFBSUMsR0FBSixFQUFTRSxHQUFHRixHQUFILEdBQVNBLEdBQVQ7O0FBRVQsUUFBSUMsSUFBSixFQUFVQyxHQUFHTSxXQUFILENBQWVMLFNBQVNNLGNBQVQsQ0FBd0JSLElBQXhCLENBQWY7O0FBRVZSLDZCQUF1QkUsR0FBdkIsU0FBOEJXLElBQTlCO0FBQ0QsR0FYRCxNQVdPO0FBQ0xaLFNBQVFZLElBQVIsV0FBa0JYLEdBQWxCO0FBQ0Q7O0FBRUQsU0FBT08sRUFBUDtBQUNELEMiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1ZydcbmNvbnN0IGNyZWF0ZSA9IGRlYnVnKCdnZXRFbGVtZW50OmNyZWF0ZScpXG5jb25zdCBza2lwID0gZGVidWcoJ2dldEVsZW1lbnQ6c2tpcCcpXG5cbmV4cG9ydCBkZWZhdWx0IChvYmosIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgeyBjbGFzc05hbWUsIGlkLCB0eXBlLCBhbHQsIHRleHQgfSA9IG9wdGlvbnNcblxuICBsZXQgZWwgPSAoaWQpID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWUpWzBdXG4gIGxldCBpbmZvID0gJydcblxuICBpZiAoaWQpIGluZm8gKz0gYCBpZDogJHtpZH0gYFxuICBpZiAoY2xhc3NOYW1lKSBpbmZvICs9IGAgY2xhc3NOYW1lOiAke2NsYXNzTmFtZX0gYFxuICBpZiAodHlwZSkgaW5mbyArPSBgIHR5cGU6ICR7dHlwZX0gYFxuICBpZiAoYWx0KSBpbmZvICs9IGAgYWx0OiAke2FsdH0gYFxuXG4gIGlmICghZWwpIHtcbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQob2JqKVxuXG4gICAgaWYgKGlkKSBlbC5pZCA9IGlkXG4gICAgaWYgKGNsYXNzTmFtZSkgZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lXG4gICAgaWYgKHR5cGUpIGVsLnR5cGUgPSB0eXBlXG4gICAgaWYgKGFsdCkgZWwuYWx0ID0gYWx0XG5cbiAgICBpZiAodGV4dCkgZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpXG5cbiAgICBjcmVhdGUoYGNyZWF0ZSBhIG5ldyAke29ian0gJHtpbmZvfWApXG4gIH0gZWxzZSB7XG4gICAgc2tpcChgJHtpbmZvfSAtICR7b2JqfSBleGlzdCA9PiBza2lwYClcbiAgfVxuXG4gIHJldHVybiBlbFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2dldEVsZW1lbnQuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar getHttpRequest = function getHttpRequest() {\n  var httpRequest = false;\n\n  if (window.XMLHttpRequest) {\n    httpRequest = new XMLHttpRequest();\n    if (httpRequest.overrideMimeType) {\n      httpRequest.overrideMimeType('text/xml');\n    }\n  }\n\n  if (!httpRequest) {\n    alert('Abort, unable to create an XMLHTTP instance');\n    return false;\n  }\n\n  return httpRequest;\n};\n\nexports.default = getHttpRequest;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVxdWVzdC5qcz9lYzhkIl0sIm5hbWVzIjpbImdldEh0dHBSZXF1ZXN0IiwiaHR0cFJlcXVlc3QiLCJ3aW5kb3ciLCJYTUxIdHRwUmVxdWVzdCIsIm92ZXJyaWRlTWltZVR5cGUiLCJhbGVydCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxJQUFNQSxpQkFBaUIsU0FBakJBLGNBQWlCLEdBQU07QUFDM0IsTUFBSUMsY0FBYyxLQUFsQjs7QUFFQSxNQUFJQyxPQUFPQyxjQUFYLEVBQTJCO0FBQ3pCRixrQkFBYyxJQUFJRSxjQUFKLEVBQWQ7QUFDQSxRQUFJRixZQUFZRyxnQkFBaEIsRUFBa0M7QUFDaENILGtCQUFZRyxnQkFBWixDQUE2QixVQUE3QjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSSxDQUFDSCxXQUFMLEVBQWtCO0FBQ2hCSSxVQUFNLDZDQUFOO0FBQ0EsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsU0FBT0osV0FBUDtBQUNELENBaEJEOztrQkFrQmVELGMiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGdldEh0dHBSZXF1ZXN0ID0gKCkgPT4ge1xuICBsZXQgaHR0cFJlcXVlc3QgPSBmYWxzZVxuXG4gIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICBodHRwUmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gICAgaWYgKGh0dHBSZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUpIHtcbiAgICAgIGh0dHBSZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUoJ3RleHQveG1sJylcbiAgICB9XG4gIH1cblxuICBpZiAoIWh0dHBSZXF1ZXN0KSB7XG4gICAgYWxlcnQoJ0Fib3J0LCB1bmFibGUgdG8gY3JlYXRlIGFuIFhNTEhUVFAgaW5zdGFuY2UnKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIGh0dHBSZXF1ZXN0XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldEh0dHBSZXF1ZXN0XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVxdWVzdC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(7);\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2RlYnVnL3NyYy9icm93c2VyLmpzPzEzZjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyAmJiB0eXBlb2Ygd2luZG93LnByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudCAmJiAnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93ICYmIHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZGVidWcvc3JjL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(8);\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2RlYnVnL3NyYy9kZWJ1Zy5qcz8yZDhlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kZWJ1Zy9zcmMvZGVidWcuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000\nvar m = s * 60\nvar h = m * 60\nvar d = h * 24\nvar y = d * 365.25\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {}\n  var type = typeof val\n  if (type === 'string' && val.length > 0) {\n    return parse(val)\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ?\n\t\t\tfmtLong(val) :\n\t\t\tfmtShort(val)\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\n}\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str)\n  if (str.length > 10000) {\n    return\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\n  if (!match) {\n    return\n  }\n  var n = parseFloat(match[1])\n  var type = (match[2] || 'ms').toLowerCase()\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n\n    default:\n      return undefined\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd'\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h'\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm'\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's'\n  }\n  return ms + 'ms'\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms'\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's'\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21zL2luZGV4LmpzPzZkMzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksTUFBTTtBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwXG52YXIgbSA9IHMgKiA2MFxudmFyIGggPSBtICogNjBcbnZhciBkID0gaCAqIDI0XG52YXIgeSA9IGQgKiAzNjUuMjVcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWxcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbClcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgP1xuXHRcdFx0Zm10TG9uZyh2YWwpIDpcblx0XHRcdGZtdFNob3J0KHZhbClcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArIEpTT04uc3RyaW5naWZ5KHZhbCkpXG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKVxuICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pXG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKClcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZFxuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaFxuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbVxuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogc1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCdcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCdcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSdcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncydcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnXG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnXG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWVcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! nouislider - 9.2.0 - 2017-01-11 10:35:34 */\r\n\r\n(function (factory) {\r\n\r\n    if ( true ) {\r\n\r\n        // AMD. Register as an anonymous module.\r\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n    } else if ( typeof exports === 'object' ) {\r\n\r\n        // Node/CommonJS\r\n        module.exports = factory();\r\n\r\n    } else {\r\n\r\n        // Browser globals\r\n        window.noUiSlider = factory();\r\n    }\r\n\r\n}(function( ){\r\n\r\n\t'use strict';\r\n\r\n\tvar VERSION = '9.2.0';\r\n\r\n\r\n\t// Creates a node, adds it to target, returns the new node.\r\n\tfunction addNodeTo ( target, className ) {\r\n\t\tvar div = document.createElement('div');\r\n\t\taddClass(div, className);\r\n\t\ttarget.appendChild(div);\r\n\t\treturn div;\r\n\t}\r\n\r\n\t// Removes duplicates from an array.\r\n\tfunction unique ( array ) {\r\n\t\treturn array.filter(function(a){\r\n\t\t\treturn !this[a] ? this[a] = true : false;\r\n\t\t}, {});\r\n\t}\r\n\r\n\t// Round a value to the closest 'to'.\r\n\tfunction closest ( value, to ) {\r\n\t\treturn Math.round(value / to) * to;\r\n\t}\r\n\r\n\t// Current position of an element relative to the document.\r\n\tfunction offset ( elem, orientation ) {\r\n\r\n\tvar rect = elem.getBoundingClientRect(),\r\n\t\tdoc = elem.ownerDocument,\r\n\t\tdocElem = doc.documentElement,\r\n\t\tpageOffset = getPageOffset();\r\n\r\n\t\t// getBoundingClientRect contains left scroll in Chrome on Android.\r\n\t\t// I haven't found a feature detection that proves this. Worst case\r\n\t\t// scenario on mis-match: the 'tap' feature on horizontal sliders breaks.\r\n\t\tif ( /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) ) {\r\n\t\t\tpageOffset.x = 0;\r\n\t\t}\r\n\r\n\t\treturn orientation ? (rect.top + pageOffset.y - docElem.clientTop) : (rect.left + pageOffset.x - docElem.clientLeft);\r\n\t}\r\n\r\n\t// Checks whether a value is numerical.\r\n\tfunction isNumeric ( a ) {\r\n\t\treturn typeof a === 'number' && !isNaN( a ) && isFinite( a );\r\n\t}\r\n\r\n\t// Sets a class and removes it after [duration] ms.\r\n\tfunction addClassFor ( element, className, duration ) {\r\n\t\tif (duration > 0) {\r\n\t\taddClass(element, className);\r\n\t\t\tsetTimeout(function(){\r\n\t\t\t\tremoveClass(element, className);\r\n\t\t\t}, duration);\r\n\t\t}\r\n\t}\r\n\r\n\t// Limits a value to 0 - 100\r\n\tfunction limit ( a ) {\r\n\t\treturn Math.max(Math.min(a, 100), 0);\r\n\t}\r\n\r\n\t// Wraps a variable as an array, if it isn't one yet.\r\n\t// Note that an input array is returned by reference!\r\n\tfunction asArray ( a ) {\r\n\t\treturn Array.isArray(a) ? a : [a];\r\n\t}\r\n\r\n\t// Counts decimals\r\n\tfunction countDecimals ( numStr ) {\r\n\t\tnumStr = String(numStr);\r\n\t\tvar pieces = numStr.split(\".\");\r\n\t\treturn pieces.length > 1 ? pieces[1].length : 0;\r\n\t}\r\n\r\n\t// http://youmightnotneedjquery.com/#add_class\r\n\tfunction addClass ( el, className ) {\r\n\t\tif ( el.classList ) {\r\n\t\t\tel.classList.add(className);\r\n\t\t} else {\r\n\t\t\tel.className += ' ' + className;\r\n\t\t}\r\n\t}\r\n\r\n\t// http://youmightnotneedjquery.com/#remove_class\r\n\tfunction removeClass ( el, className ) {\r\n\t\tif ( el.classList ) {\r\n\t\t\tel.classList.remove(className);\r\n\t\t} else {\r\n\t\t\tel.className = el.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\r\n\t\t}\r\n\t}\r\n\r\n\t// https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/\r\n\tfunction hasClass ( el, className ) {\r\n\t\treturn el.classList ? el.classList.contains(className) : new RegExp('\\\\b' + className + '\\\\b').test(el.className);\r\n\t}\r\n\r\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes\r\n\tfunction getPageOffset ( ) {\r\n\r\n\t\tvar supportPageOffset = window.pageXOffset !== undefined,\r\n\t\t\tisCSS1Compat = ((document.compatMode || \"\") === \"CSS1Compat\"),\r\n\t\t\tx = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft,\r\n\t\t\ty = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;\r\n\r\n\t\treturn {\r\n\t\t\tx: x,\r\n\t\t\ty: y\r\n\t\t};\r\n\t}\r\n\r\n\t// we provide a function to compute constants instead\r\n\t// of accessing window.* as soon as the module needs it\r\n\t// so that we do not compute anything if not needed\r\n\tfunction getActions ( ) {\r\n\r\n\t\t// Determine the events to bind. IE11 implements pointerEvents without\r\n\t\t// a prefix, which breaks compatibility with the IE10 implementation.\r\n\t\treturn window.navigator.pointerEnabled ? {\r\n\t\t\tstart: 'pointerdown',\r\n\t\t\tmove: 'pointermove',\r\n\t\t\tend: 'pointerup'\r\n\t\t} : window.navigator.msPointerEnabled ? {\r\n\t\t\tstart: 'MSPointerDown',\r\n\t\t\tmove: 'MSPointerMove',\r\n\t\t\tend: 'MSPointerUp'\r\n\t\t} : {\r\n\t\t\tstart: 'mousedown touchstart',\r\n\t\t\tmove: 'mousemove touchmove',\r\n\t\t\tend: 'mouseup touchend'\r\n\t\t};\r\n\t}\r\n\r\n\r\n// Value calculation\r\n\r\n\t// Determine the size of a sub-range in relation to a full range.\r\n\tfunction subRangeRatio ( pa, pb ) {\r\n\t\treturn (100 / (pb - pa));\r\n\t}\r\n\r\n\t// (percentage) How many percent is this value of this range?\r\n\tfunction fromPercentage ( range, value ) {\r\n\t\treturn (value * 100) / ( range[1] - range[0] );\r\n\t}\r\n\r\n\t// (percentage) Where is this value on this range?\r\n\tfunction toPercentage ( range, value ) {\r\n\t\treturn fromPercentage( range, range[0] < 0 ?\r\n\t\t\tvalue + Math.abs(range[0]) :\r\n\t\t\t\tvalue - range[0] );\r\n\t}\r\n\r\n\t// (value) How much is this percentage on this range?\r\n\tfunction isPercentage ( range, value ) {\r\n\t\treturn ((value * ( range[1] - range[0] )) / 100) + range[0];\r\n\t}\r\n\r\n\r\n// Range conversion\r\n\r\n\tfunction getJ ( value, arr ) {\r\n\r\n\t\tvar j = 1;\r\n\r\n\t\twhile ( value >= arr[j] ){\r\n\t\t\tj += 1;\r\n\t\t}\r\n\r\n\t\treturn j;\r\n\t}\r\n\r\n\t// (percentage) Input a value, find where, on a scale of 0-100, it applies.\r\n\tfunction toStepping ( xVal, xPct, value ) {\r\n\r\n\t\tif ( value >= xVal.slice(-1)[0] ){\r\n\t\t\treturn 100;\r\n\t\t}\r\n\r\n\t\tvar j = getJ( value, xVal ), va, vb, pa, pb;\r\n\r\n\t\tva = xVal[j-1];\r\n\t\tvb = xVal[j];\r\n\t\tpa = xPct[j-1];\r\n\t\tpb = xPct[j];\r\n\r\n\t\treturn pa + (toPercentage([va, vb], value) / subRangeRatio (pa, pb));\r\n\t}\r\n\r\n\t// (value) Input a percentage, find where it is on the specified range.\r\n\tfunction fromStepping ( xVal, xPct, value ) {\r\n\r\n\t\t// There is no range group that fits 100\r\n\t\tif ( value >= 100 ){\r\n\t\t\treturn xVal.slice(-1)[0];\r\n\t\t}\r\n\r\n\t\tvar j = getJ( value, xPct ), va, vb, pa, pb;\r\n\r\n\t\tva = xVal[j-1];\r\n\t\tvb = xVal[j];\r\n\t\tpa = xPct[j-1];\r\n\t\tpb = xPct[j];\r\n\r\n\t\treturn isPercentage([va, vb], (value - pa) * subRangeRatio (pa, pb));\r\n\t}\r\n\r\n\t// (percentage) Get the step that applies at a certain value.\r\n\tfunction getStep ( xPct, xSteps, snap, value ) {\r\n\r\n\t\tif ( value === 100 ) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tvar j = getJ( value, xPct ), a, b;\r\n\r\n\t\t// If 'snap' is set, steps are used as fixed points on the slider.\r\n\t\tif ( snap ) {\r\n\r\n\t\t\ta = xPct[j-1];\r\n\t\t\tb = xPct[j];\r\n\r\n\t\t\t// Find the closest position, a or b.\r\n\t\t\tif ((value - a) > ((b-a)/2)){\r\n\t\t\t\treturn b;\r\n\t\t\t}\r\n\r\n\t\t\treturn a;\r\n\t\t}\r\n\r\n\t\tif ( !xSteps[j-1] ){\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\treturn xPct[j-1] + closest(\r\n\t\t\tvalue - xPct[j-1],\r\n\t\t\txSteps[j-1]\r\n\t\t);\r\n\t}\r\n\r\n\r\n// Entry parsing\r\n\r\n\tfunction handleEntryPoint ( index, value, that ) {\r\n\r\n\t\tvar percentage;\r\n\r\n\t\t// Wrap numerical input in an array.\r\n\t\tif ( typeof value === \"number\" ) {\r\n\t\t\tvalue = [value];\r\n\t\t}\r\n\r\n\t\t// Reject any invalid input, by testing whether value is an array.\r\n\t\tif ( Object.prototype.toString.call( value ) !== '[object Array]' ){\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'range' contains invalid value.\");\r\n\t\t}\r\n\r\n\t\t// Covert min/max syntax to 0 and 100.\r\n\t\tif ( index === 'min' ) {\r\n\t\t\tpercentage = 0;\r\n\t\t} else if ( index === 'max' ) {\r\n\t\t\tpercentage = 100;\r\n\t\t} else {\r\n\t\t\tpercentage = parseFloat( index );\r\n\t\t}\r\n\r\n\t\t// Check for correct input.\r\n\t\tif ( !isNumeric( percentage ) || !isNumeric( value[0] ) ) {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'range' value isn't numeric.\");\r\n\t\t}\r\n\r\n\t\t// Store values.\r\n\t\tthat.xPct.push( percentage );\r\n\t\tthat.xVal.push( value[0] );\r\n\r\n\t\t// NaN will evaluate to false too, but to keep\r\n\t\t// logging clear, set step explicitly. Make sure\r\n\t\t// not to override the 'step' setting with false.\r\n\t\tif ( !percentage ) {\r\n\t\t\tif ( !isNaN( value[1] ) ) {\r\n\t\t\t\tthat.xSteps[0] = value[1];\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthat.xSteps.push( isNaN(value[1]) ? false : value[1] );\r\n\t\t}\r\n\r\n\t\tthat.xHighestCompleteStep.push(0);\r\n\t}\r\n\r\n\tfunction handleStepPoint ( i, n, that ) {\r\n\r\n\t\t// Ignore 'false' stepping.\r\n\t\tif ( !n ) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Factor to range ratio\r\n\t\tthat.xSteps[i] = fromPercentage([\r\n\t\t\t that.xVal[i]\r\n\t\t\t,that.xVal[i+1]\r\n\t\t], n) / subRangeRatio (\r\n\t\t\tthat.xPct[i],\r\n\t\t\tthat.xPct[i+1] );\r\n\r\n\t\tvar totalSteps = (that.xVal[i+1] - that.xVal[i]) / that.xNumSteps[i];\r\n\t\tvar highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);\r\n\t\tvar step = that.xVal[i] + (that.xNumSteps[i] * highestStep);\r\n\r\n\t\tthat.xHighestCompleteStep[i] = step;\r\n\t}\r\n\r\n\r\n// Interface\r\n\r\n\t// The interface to Spectrum handles all direction-based\r\n\t// conversions, so the above values are unaware.\r\n\r\n\tfunction Spectrum ( entry, snap, direction, singleStep ) {\r\n\r\n\t\tthis.xPct = [];\r\n\t\tthis.xVal = [];\r\n\t\tthis.xSteps = [ singleStep || false ];\r\n\t\tthis.xNumSteps = [ false ];\r\n\t\tthis.xHighestCompleteStep = [];\r\n\r\n\t\tthis.snap = snap;\r\n\t\tthis.direction = direction;\r\n\r\n\t\tvar index, ordered = [ /* [0, 'min'], [1, '50%'], [2, 'max'] */ ];\r\n\r\n\t\t// Map the object keys to an array.\r\n\t\tfor ( index in entry ) {\r\n\t\t\tif ( entry.hasOwnProperty(index) ) {\r\n\t\t\t\tordered.push([entry[index], index]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Sort all entries by value (numeric sort).\r\n\t\tif ( ordered.length && typeof ordered[0][0] === \"object\" ) {\r\n\t\t\tordered.sort(function(a, b) { return a[0][0] - b[0][0]; });\r\n\t\t} else {\r\n\t\t\tordered.sort(function(a, b) { return a[0] - b[0]; });\r\n\t\t}\r\n\r\n\r\n\t\t// Convert all entries to subranges.\r\n\t\tfor ( index = 0; index < ordered.length; index++ ) {\r\n\t\t\thandleEntryPoint(ordered[index][1], ordered[index][0], this);\r\n\t\t}\r\n\r\n\t\t// Store the actual step values.\r\n\t\t// xSteps is sorted in the same order as xPct and xVal.\r\n\t\tthis.xNumSteps = this.xSteps.slice(0);\r\n\r\n\t\t// Convert all numeric steps to the percentage of the subrange they represent.\r\n\t\tfor ( index = 0; index < this.xNumSteps.length; index++ ) {\r\n\t\t\thandleStepPoint(index, this.xNumSteps[index], this);\r\n\t\t}\r\n\t}\r\n\r\n\tSpectrum.prototype.getMargin = function ( value ) {\r\n\r\n\t\tvar step = this.xNumSteps[0];\r\n\r\n\t\tif ( step && ((value / step) % 1) !== 0 ) {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'limit', 'margin' and 'padding' must be divisible by step.\");\r\n\t\t}\r\n\r\n\t\treturn this.xPct.length === 2 ? fromPercentage(this.xVal, value) : false;\r\n\t};\r\n\r\n\tSpectrum.prototype.toStepping = function ( value ) {\r\n\r\n\t\tvalue = toStepping( this.xVal, this.xPct, value );\r\n\r\n\t\treturn value;\r\n\t};\r\n\r\n\tSpectrum.prototype.fromStepping = function ( value ) {\r\n\r\n\t\treturn fromStepping( this.xVal, this.xPct, value );\r\n\t};\r\n\r\n\tSpectrum.prototype.getStep = function ( value ) {\r\n\r\n\t\tvalue = getStep(this.xPct, this.xSteps, this.snap, value );\r\n\r\n\t\treturn value;\r\n\t};\r\n\r\n\tSpectrum.prototype.getNearbySteps = function ( value ) {\r\n\r\n\t\tvar j = getJ(value, this.xPct);\r\n\r\n\t\treturn {\r\n\t\t\tstepBefore: { startValue: this.xVal[j-2], step: this.xNumSteps[j-2], highestStep: this.xHighestCompleteStep[j-2] },\r\n\t\t\tthisStep: { startValue: this.xVal[j-1], step: this.xNumSteps[j-1], highestStep: this.xHighestCompleteStep[j-1] },\r\n\t\t\tstepAfter: { startValue: this.xVal[j-0], step: this.xNumSteps[j-0], highestStep: this.xHighestCompleteStep[j-0] }\r\n\t\t};\r\n\t};\r\n\r\n\tSpectrum.prototype.countStepDecimals = function () {\r\n\t\tvar stepDecimals = this.xNumSteps.map(countDecimals);\r\n\t\treturn Math.max.apply(null, stepDecimals);\r\n \t};\r\n\r\n\t// Outside testing\r\n\tSpectrum.prototype.convert = function ( value ) {\r\n\t\treturn this.getStep(this.toStepping(value));\r\n\t};\r\n\r\n/*\tEvery input option is tested and parsed. This'll prevent\r\n\tendless validation in internal methods. These tests are\r\n\tstructured with an item for every option available. An\r\n\toption can be marked as required by setting the 'r' flag.\r\n\tThe testing function is provided with three arguments:\r\n\t\t- The provided value for the option;\r\n\t\t- A reference to the options object;\r\n\t\t- The name for the option;\r\n\r\n\tThe testing function returns false when an error is detected,\r\n\tor true when everything is OK. It can also modify the option\r\n\tobject, to make sure all values can be correctly looped elsewhere. */\r\n\r\n\tvar defaultFormatter = { 'to': function( value ){\r\n\t\treturn value !== undefined && value.toFixed(2);\r\n\t}, 'from': Number };\r\n\r\n\tfunction testStep ( parsed, entry ) {\r\n\r\n\t\tif ( !isNumeric( entry ) ) {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'step' is not numeric.\");\r\n\t\t}\r\n\r\n\t\t// The step option can still be used to set stepping\r\n\t\t// for linear sliders. Overwritten if set in 'range'.\r\n\t\tparsed.singleStep = entry;\r\n\t}\r\n\r\n\tfunction testRange ( parsed, entry ) {\r\n\r\n\t\t// Filter incorrect input.\r\n\t\tif ( typeof entry !== 'object' || Array.isArray(entry) ) {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'range' is not an object.\");\r\n\t\t}\r\n\r\n\t\t// Catch missing start or end.\r\n\t\tif ( entry.min === undefined || entry.max === undefined ) {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): Missing 'min' or 'max' in 'range'.\");\r\n\t\t}\r\n\r\n\t\t// Catch equal start or end.\r\n\t\tif ( entry.min === entry.max ) {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'range' 'min' and 'max' cannot be equal.\");\r\n\t\t}\r\n\r\n\t\tparsed.spectrum = new Spectrum(entry, parsed.snap, parsed.dir, parsed.singleStep);\r\n\t}\r\n\r\n\tfunction testStart ( parsed, entry ) {\r\n\r\n\t\tentry = asArray(entry);\r\n\r\n\t\t// Validate input. Values aren't tested, as the public .val method\r\n\t\t// will always provide a valid location.\r\n\t\tif ( !Array.isArray( entry ) || !entry.length ) {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'start' option is incorrect.\");\r\n\t\t}\r\n\r\n\t\t// Store the number of handles.\r\n\t\tparsed.handles = entry.length;\r\n\r\n\t\t// When the slider is initialized, the .val method will\r\n\t\t// be called with the start options.\r\n\t\tparsed.start = entry;\r\n\t}\r\n\r\n\tfunction testSnap ( parsed, entry ) {\r\n\r\n\t\t// Enforce 100% stepping within subranges.\r\n\t\tparsed.snap = entry;\r\n\r\n\t\tif ( typeof entry !== 'boolean' ){\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'snap' option must be a boolean.\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testAnimate ( parsed, entry ) {\r\n\r\n\t\t// Enforce 100% stepping within subranges.\r\n\t\tparsed.animate = entry;\r\n\r\n\t\tif ( typeof entry !== 'boolean' ){\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'animate' option must be a boolean.\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testAnimationDuration ( parsed, entry ) {\r\n\r\n\t\tparsed.animationDuration = entry;\r\n\r\n\t\tif ( typeof entry !== 'number' ){\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'animationDuration' option must be a number.\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testConnect ( parsed, entry ) {\r\n\r\n\t\tvar connect = [false];\r\n\t\tvar i;\r\n\r\n\t\t// Map legacy options\r\n\t\tif ( entry === 'lower' ) {\r\n\t\t\tentry = [true, false];\r\n\t\t}\r\n\r\n\t\telse if ( entry === 'upper' ) {\r\n\t\t\tentry = [false, true];\r\n\t\t}\r\n\r\n\t\t// Handle boolean options\r\n\t\tif ( entry === true || entry === false ) {\r\n\r\n\t\t\tfor ( i = 1; i < parsed.handles; i++ ) {\r\n\t\t\t\tconnect.push(entry);\r\n\t\t\t}\r\n\r\n\t\t\tconnect.push(false);\r\n\t\t}\r\n\r\n\t\t// Reject invalid input\r\n\t\telse if ( !Array.isArray( entry ) || !entry.length || entry.length !== parsed.handles + 1 ) {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'connect' option doesn't match handle count.\");\r\n\t\t}\r\n\r\n\t\telse {\r\n\t\t\tconnect = entry;\r\n\t\t}\r\n\r\n\t\tparsed.connect = connect;\r\n\t}\r\n\r\n\tfunction testOrientation ( parsed, entry ) {\r\n\r\n\t\t// Set orientation to an a numerical value for easy\r\n\t\t// array selection.\r\n\t\tswitch ( entry ){\r\n\t\t  case 'horizontal':\r\n\t\t\tparsed.ort = 0;\r\n\t\t\tbreak;\r\n\t\t  case 'vertical':\r\n\t\t\tparsed.ort = 1;\r\n\t\t\tbreak;\r\n\t\t  default:\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'orientation' option is invalid.\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testMargin ( parsed, entry ) {\r\n\r\n\t\tif ( !isNumeric(entry) ){\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'margin' option must be numeric.\");\r\n\t\t}\r\n\r\n\t\t// Issue #582\r\n\t\tif ( entry === 0 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tparsed.margin = parsed.spectrum.getMargin(entry);\r\n\r\n\t\tif ( !parsed.margin ) {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'margin' option is only supported on linear sliders.\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testLimit ( parsed, entry ) {\r\n\r\n\t\tif ( !isNumeric(entry) ){\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'limit' option must be numeric.\");\r\n\t\t}\r\n\r\n\t\tparsed.limit = parsed.spectrum.getMargin(entry);\r\n\r\n\t\tif ( !parsed.limit || parsed.handles < 2 ) {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'limit' option is only supported on linear sliders with 2 or more handles.\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testPadding ( parsed, entry ) {\r\n\r\n\t\tif ( !isNumeric(entry) ){\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option must be numeric.\");\r\n\t\t}\r\n\r\n\t\tif ( entry === 0 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tparsed.padding = parsed.spectrum.getMargin(entry);\r\n\r\n\t\tif ( !parsed.padding ) {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option is only supported on linear sliders.\");\r\n\t\t}\r\n\r\n\t\tif ( parsed.padding < 0 ) {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option must be a positive number.\");\r\n\t\t}\r\n\r\n\t\tif ( parsed.padding >= 50 ) {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option must be less than half the range.\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testDirection ( parsed, entry ) {\r\n\r\n\t\t// Set direction as a numerical value for easy parsing.\r\n\t\t// Invert connection for RTL sliders, so that the proper\r\n\t\t// handles get the connect/background classes.\r\n\t\tswitch ( entry ) {\r\n\t\t  case 'ltr':\r\n\t\t\tparsed.dir = 0;\r\n\t\t\tbreak;\r\n\t\t  case 'rtl':\r\n\t\t\tparsed.dir = 1;\r\n\t\t\tbreak;\r\n\t\t  default:\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'direction' option was not recognized.\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testBehaviour ( parsed, entry ) {\r\n\r\n\t\t// Make sure the input is a string.\r\n\t\tif ( typeof entry !== 'string' ) {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'behaviour' must be a string containing options.\");\r\n\t\t}\r\n\r\n\t\t// Check if the string contains any keywords.\r\n\t\t// None are required.\r\n\t\tvar tap = entry.indexOf('tap') >= 0;\r\n\t\tvar drag = entry.indexOf('drag') >= 0;\r\n\t\tvar fixed = entry.indexOf('fixed') >= 0;\r\n\t\tvar snap = entry.indexOf('snap') >= 0;\r\n\t\tvar hover = entry.indexOf('hover') >= 0;\r\n\r\n\t\tif ( fixed ) {\r\n\r\n\t\t\tif ( parsed.handles !== 2 ) {\r\n\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'fixed' behaviour must be used with 2 handles\");\r\n\t\t\t}\r\n\r\n\t\t\t// Use margin to enforce fixed state\r\n\t\t\ttestMargin(parsed, parsed.start[1] - parsed.start[0]);\r\n\t\t}\r\n\r\n\t\tparsed.events = {\r\n\t\t\ttap: tap || snap,\r\n\t\t\tdrag: drag,\r\n\t\t\tfixed: fixed,\r\n\t\t\tsnap: snap,\r\n\t\t\thover: hover\r\n\t\t};\r\n\t}\r\n\r\n\tfunction testTooltips ( parsed, entry ) {\r\n\r\n\t\tif ( entry === false ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\telse if ( entry === true ) {\r\n\r\n\t\t\tparsed.tooltips = [];\r\n\r\n\t\t\tfor ( var i = 0; i < parsed.handles; i++ ) {\r\n\t\t\t\tparsed.tooltips.push(true);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\telse {\r\n\r\n\t\t\tparsed.tooltips = asArray(entry);\r\n\r\n\t\t\tif ( parsed.tooltips.length !== parsed.handles ) {\r\n\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): must pass a formatter for all handles.\");\r\n\t\t\t}\r\n\r\n\t\t\tparsed.tooltips.forEach(function(formatter){\r\n\t\t\t\tif ( typeof formatter !== 'boolean' && (typeof formatter !== 'object' || typeof formatter.to !== 'function') ) {\r\n\t\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'tooltips' must be passed a formatter or 'false'.\");\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testFormat ( parsed, entry ) {\r\n\r\n\t\tparsed.format = entry;\r\n\r\n\t\t// Any object with a to and from method is supported.\r\n\t\tif ( typeof entry.to === 'function' && typeof entry.from === 'function' ) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'format' requires 'to' and 'from' methods.\");\r\n\t}\r\n\r\n\tfunction testCssPrefix ( parsed, entry ) {\r\n\r\n\t\tif ( entry !== undefined && typeof entry !== 'string' && entry !== false ) {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'cssPrefix' must be a string or `false`.\");\r\n\t\t}\r\n\r\n\t\tparsed.cssPrefix = entry;\r\n\t}\r\n\r\n\tfunction testCssClasses ( parsed, entry ) {\r\n\r\n\t\tif ( entry !== undefined && typeof entry !== 'object' ) {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'cssClasses' must be an object.\");\r\n\t\t}\r\n\r\n\t\tif ( typeof parsed.cssPrefix === 'string' ) {\r\n\t\t\tparsed.cssClasses = {};\r\n\r\n\t\t\tfor ( var key in entry ) {\r\n\t\t\t\tif ( !entry.hasOwnProperty(key) ) { continue; }\r\n\r\n\t\t\t\tparsed.cssClasses[key] = parsed.cssPrefix + entry[key];\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tparsed.cssClasses = entry;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testUseRaf ( parsed, entry ) {\r\n\t\tif ( entry === true || entry === false ) {\r\n\t\t\tparsed.useRequestAnimationFrame = entry;\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'useRequestAnimationFrame' option should be true (default) or false.\");\r\n\t\t}\r\n\t}\r\n\r\n\t// Test all developer settings and parse to assumption-safe values.\r\n\tfunction testOptions ( options ) {\r\n\r\n\t\t// To prove a fix for #537, freeze options here.\r\n\t\t// If the object is modified, an error will be thrown.\r\n\t\t// Object.freeze(options);\r\n\r\n\t\tvar parsed = {\r\n\t\t\tmargin: 0,\r\n\t\t\tlimit: 0,\r\n\t\t\tpadding: 0,\r\n\t\t\tanimate: true,\r\n\t\t\tanimationDuration: 300,\r\n\t\t\tformat: defaultFormatter\r\n\t\t};\r\n\r\n\t\t// Tests are executed in the order they are presented here.\r\n\t\tvar tests = {\r\n\t\t\t'step': { r: false, t: testStep },\r\n\t\t\t'start': { r: true, t: testStart },\r\n\t\t\t'connect': { r: true, t: testConnect },\r\n\t\t\t'direction': { r: true, t: testDirection },\r\n\t\t\t'snap': { r: false, t: testSnap },\r\n\t\t\t'animate': { r: false, t: testAnimate },\r\n\t\t\t'animationDuration': { r: false, t: testAnimationDuration },\r\n\t\t\t'range': { r: true, t: testRange },\r\n\t\t\t'orientation': { r: false, t: testOrientation },\r\n\t\t\t'margin': { r: false, t: testMargin },\r\n\t\t\t'limit': { r: false, t: testLimit },\r\n\t\t\t'padding': { r: false, t: testPadding },\r\n\t\t\t'behaviour': { r: true, t: testBehaviour },\r\n\t\t\t'format': { r: false, t: testFormat },\r\n\t\t\t'tooltips': { r: false, t: testTooltips },\r\n\t\t\t'cssPrefix': { r: false, t: testCssPrefix },\r\n\t\t\t'cssClasses': { r: false, t: testCssClasses },\r\n\t\t\t'useRequestAnimationFrame': { r: false, t: testUseRaf }\r\n\t\t};\r\n\r\n\t\tvar defaults = {\r\n\t\t\t'connect': false,\r\n\t\t\t'direction': 'ltr',\r\n\t\t\t'behaviour': 'tap',\r\n\t\t\t'orientation': 'horizontal',\r\n\t\t\t'cssPrefix' : 'noUi-',\r\n\t\t\t'cssClasses': {\r\n\t\t\t\ttarget: 'target',\r\n\t\t\t\tbase: 'base',\r\n\t\t\t\torigin: 'origin',\r\n\t\t\t\thandle: 'handle',\r\n\t\t\t\thandleLower: 'handle-lower',\r\n\t\t\t\thandleUpper: 'handle-upper',\r\n\t\t\t\thorizontal: 'horizontal',\r\n\t\t\t\tvertical: 'vertical',\r\n\t\t\t\tbackground: 'background',\r\n\t\t\t\tconnect: 'connect',\r\n\t\t\t\tltr: 'ltr',\r\n\t\t\t\trtl: 'rtl',\r\n\t\t\t\tdraggable: 'draggable',\r\n\t\t\t\tdrag: 'state-drag',\r\n\t\t\t\ttap: 'state-tap',\r\n\t\t\t\tactive: 'active',\r\n\t\t\t\ttooltip: 'tooltip',\r\n\t\t\t\tpips: 'pips',\r\n\t\t\t\tpipsHorizontal: 'pips-horizontal',\r\n\t\t\t\tpipsVertical: 'pips-vertical',\r\n\t\t\t\tmarker: 'marker',\r\n\t\t\t\tmarkerHorizontal: 'marker-horizontal',\r\n\t\t\t\tmarkerVertical: 'marker-vertical',\r\n\t\t\t\tmarkerNormal: 'marker-normal',\r\n\t\t\t\tmarkerLarge: 'marker-large',\r\n\t\t\t\tmarkerSub: 'marker-sub',\r\n\t\t\t\tvalue: 'value',\r\n\t\t\t\tvalueHorizontal: 'value-horizontal',\r\n\t\t\t\tvalueVertical: 'value-vertical',\r\n\t\t\t\tvalueNormal: 'value-normal',\r\n\t\t\t\tvalueLarge: 'value-large',\r\n\t\t\t\tvalueSub: 'value-sub'\r\n\t\t\t},\r\n\t\t\t'useRequestAnimationFrame': true\r\n\t\t};\r\n\r\n\t\t// Run all options through a testing mechanism to ensure correct\r\n\t\t// input. It should be noted that options might get modified to\r\n\t\t// be handled properly. E.g. wrapping integers in arrays.\r\n\t\tObject.keys(tests).forEach(function( name ){\r\n\r\n\t\t\t// If the option isn't set, but it is required, throw an error.\r\n\t\t\tif ( options[name] === undefined && defaults[name] === undefined ) {\r\n\r\n\t\t\t\tif ( tests[name].r ) {\r\n\t\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): '\" + name + \"' is required.\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\ttests[name].t( parsed, options[name] === undefined ? defaults[name] : options[name] );\r\n\t\t});\r\n\r\n\t\t// Forward pips options\r\n\t\tparsed.pips = options.pips;\r\n\r\n\t\tvar styles = [['left', 'top'], ['right', 'bottom']];\r\n\r\n\t\t// Pre-define the styles.\r\n\t\tparsed.style = styles[parsed.dir][parsed.ort];\r\n\t\tparsed.styleOposite = styles[parsed.dir?0:1][parsed.ort];\r\n\r\n\t\treturn parsed;\r\n\t}\r\n\r\n\r\nfunction closure ( target, options, originalOptions ){\r\n\r\n\tvar actions = getActions( );\r\n\r\n\t// All variables local to 'closure' are prefixed with 'scope_'\r\n\tvar scope_Target = target;\r\n\tvar scope_Locations = [];\r\n\tvar scope_Base;\r\n\tvar scope_Handles;\r\n\tvar scope_HandleNumbers = [];\r\n\tvar scope_ActiveHandle = false;\r\n\tvar scope_Connects;\r\n\tvar scope_Spectrum = options.spectrum;\r\n\tvar scope_Values = [];\r\n\tvar scope_Events = {};\r\n\tvar scope_Self;\r\n\r\n\r\n\t// Append a origin to the base\r\n\tfunction addOrigin ( base, handleNumber ) {\r\n\r\n\t\tvar origin = addNodeTo(base, options.cssClasses.origin);\r\n\t\tvar handle = addNodeTo(origin, options.cssClasses.handle);\r\n\r\n\t\thandle.setAttribute('data-handle', handleNumber);\r\n\r\n\t\tif ( handleNumber === 0 ) {\r\n\t\t\taddClass(handle, options.cssClasses.handleLower);\r\n\t\t}\r\n\r\n\t\telse if ( handleNumber === options.handles - 1 ) {\r\n\t\t\taddClass(handle, options.cssClasses.handleUpper);\r\n\t\t}\r\n\r\n\t\treturn origin;\r\n\t}\r\n\r\n\t// Insert nodes for connect elements\r\n\tfunction addConnect ( base, add ) {\r\n\r\n\t\tif ( !add ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn addNodeTo(base, options.cssClasses.connect);\r\n\t}\r\n\r\n\t// Add handles to the slider base.\r\n\tfunction addElements ( connectOptions, base ) {\r\n\r\n\t\tscope_Handles = [];\r\n\t\tscope_Connects = [];\r\n\r\n\t\tscope_Connects.push(addConnect(base, connectOptions[0]));\r\n\r\n\t\t// [::::O====O====O====]\r\n\t\t// connectOptions = [0, 1, 1, 1]\r\n\r\n\t\tfor ( var i = 0; i < options.handles; i++ ) {\r\n\t\t\t// Keep a list of all added handles.\r\n\t\t\tscope_Handles.push(addOrigin(base, i));\r\n\t\t\tscope_HandleNumbers[i] = i;\r\n\t\t\tscope_Connects.push(addConnect(base, connectOptions[i + 1]));\r\n\t\t}\r\n\t}\r\n\r\n\t// Initialize a single slider.\r\n\tfunction addSlider ( target ) {\r\n\r\n\t\t// Apply classes and data to the target.\r\n\t\taddClass(target, options.cssClasses.target);\r\n\r\n\t\tif ( options.dir === 0 ) {\r\n\t\t\taddClass(target, options.cssClasses.ltr);\r\n\t\t} else {\r\n\t\t\taddClass(target, options.cssClasses.rtl);\r\n\t\t}\r\n\r\n\t\tif ( options.ort === 0 ) {\r\n\t\t\taddClass(target, options.cssClasses.horizontal);\r\n\t\t} else {\r\n\t\t\taddClass(target, options.cssClasses.vertical);\r\n\t\t}\r\n\r\n\t\tscope_Base = addNodeTo(target, options.cssClasses.base);\r\n\t}\r\n\r\n\r\n\tfunction addTooltip ( handle, handleNumber ) {\r\n\r\n\t\tif ( !options.tooltips[handleNumber] ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn addNodeTo(handle.firstChild, options.cssClasses.tooltip);\r\n\t}\r\n\r\n\t// The tooltips option is a shorthand for using the 'update' event.\r\n\tfunction tooltips ( ) {\r\n\r\n\t\t// Tooltips are added with options.tooltips in original order.\r\n\t\tvar tips = scope_Handles.map(addTooltip);\r\n\r\n\t\tbindEvent('update', function(values, handleNumber, unencoded) {\r\n\r\n\t\t\tif ( !tips[handleNumber] ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar formattedValue = values[handleNumber];\r\n\r\n\t\t\tif ( options.tooltips[handleNumber] !== true ) {\r\n\t\t\t\tformattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);\r\n\t\t\t}\r\n\r\n\t\t\ttips[handleNumber].innerHTML = formattedValue;\r\n\t\t});\r\n\t}\r\n\r\n\r\n\tfunction getGroup ( mode, values, stepped ) {\r\n\r\n\t\t// Use the range.\r\n\t\tif ( mode === 'range' || mode === 'steps' ) {\r\n\t\t\treturn scope_Spectrum.xVal;\r\n\t\t}\r\n\r\n\t\tif ( mode === 'count' ) {\r\n\r\n\t\t\tif ( !values ) {\r\n\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'values' required for mode 'count'.\");\r\n\t\t\t}\r\n\r\n\t\t\t// Divide 0 - 100 in 'count' parts.\r\n\t\t\tvar spread = ( 100 / (values - 1) );\r\n\t\t\tvar v;\r\n\t\t\tvar i = 0;\r\n\r\n\t\t\tvalues = [];\r\n\r\n\t\t\t// List these parts and have them handled as 'positions'.\r\n\t\t\twhile ( (v = i++ * spread) <= 100 ) {\r\n\t\t\t\tvalues.push(v);\r\n\t\t\t}\r\n\r\n\t\t\tmode = 'positions';\r\n\t\t}\r\n\r\n\t\tif ( mode === 'positions' ) {\r\n\r\n\t\t\t// Map all percentages to on-range values.\r\n\t\t\treturn values.map(function( value ){\r\n\t\t\t\treturn scope_Spectrum.fromStepping( stepped ? scope_Spectrum.getStep( value ) : value );\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif ( mode === 'values' ) {\r\n\r\n\t\t\t// If the value must be stepped, it needs to be converted to a percentage first.\r\n\t\t\tif ( stepped ) {\r\n\r\n\t\t\t\treturn values.map(function( value ){\r\n\r\n\t\t\t\t\t// Convert to percentage, apply step, return to value.\r\n\t\t\t\t\treturn scope_Spectrum.fromStepping( scope_Spectrum.getStep( scope_Spectrum.toStepping( value ) ) );\r\n\t\t\t\t});\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Otherwise, we can simply use the values.\r\n\t\t\treturn values;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction generateSpread ( density, mode, group ) {\r\n\r\n\t\tfunction safeIncrement(value, increment) {\r\n\t\t\t// Avoid floating point variance by dropping the smallest decimal places.\r\n\t\t\treturn (value + increment).toFixed(7) / 1;\r\n\t\t}\r\n\r\n\t\tvar indexes = {};\r\n\t\tvar firstInRange = scope_Spectrum.xVal[0];\r\n\t\tvar lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length-1];\r\n\t\tvar ignoreFirst = false;\r\n\t\tvar ignoreLast = false;\r\n\t\tvar prevPct = 0;\r\n\r\n\t\t// Create a copy of the group, sort it and filter away all duplicates.\r\n\t\tgroup = unique(group.slice().sort(function(a, b){ return a - b; }));\r\n\r\n\t\t// Make sure the range starts with the first element.\r\n\t\tif ( group[0] !== firstInRange ) {\r\n\t\t\tgroup.unshift(firstInRange);\r\n\t\t\tignoreFirst = true;\r\n\t\t}\r\n\r\n\t\t// Likewise for the last one.\r\n\t\tif ( group[group.length - 1] !== lastInRange ) {\r\n\t\t\tgroup.push(lastInRange);\r\n\t\t\tignoreLast = true;\r\n\t\t}\r\n\r\n\t\tgroup.forEach(function ( current, index ) {\r\n\r\n\t\t\t// Get the current step and the lower + upper positions.\r\n\t\t\tvar step;\r\n\t\t\tvar i;\r\n\t\t\tvar q;\r\n\t\t\tvar low = current;\r\n\t\t\tvar high = group[index+1];\r\n\t\t\tvar newPct;\r\n\t\t\tvar pctDifference;\r\n\t\t\tvar pctPos;\r\n\t\t\tvar type;\r\n\t\t\tvar steps;\r\n\t\t\tvar realSteps;\r\n\t\t\tvar stepsize;\r\n\r\n\t\t\t// When using 'steps' mode, use the provided steps.\r\n\t\t\t// Otherwise, we'll step on to the next subrange.\r\n\t\t\tif ( mode === 'steps' ) {\r\n\t\t\t\tstep = scope_Spectrum.xNumSteps[ index ];\r\n\t\t\t}\r\n\r\n\t\t\t// Default to a 'full' step.\r\n\t\t\tif ( !step ) {\r\n\t\t\t\tstep = high-low;\r\n\t\t\t}\r\n\r\n\t\t\t// Low can be 0, so test for false. If high is undefined,\r\n\t\t\t// we are at the last subrange. Index 0 is already handled.\r\n\t\t\tif ( low === false || high === undefined ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Make sure step isn't 0, which would cause an infinite loop (#654)\r\n\t\t\tstep = Math.max(step, 0.0000001);\r\n\r\n\t\t\t// Find all steps in the subrange.\r\n\t\t\tfor ( i = low; i <= high; i = safeIncrement(i, step) ) {\r\n\r\n\t\t\t\t// Get the percentage value for the current step,\r\n\t\t\t\t// calculate the size for the subrange.\r\n\t\t\t\tnewPct = scope_Spectrum.toStepping( i );\r\n\t\t\t\tpctDifference = newPct - prevPct;\r\n\r\n\t\t\t\tsteps = pctDifference / density;\r\n\t\t\t\trealSteps = Math.round(steps);\r\n\r\n\t\t\t\t// This ratio represents the ammount of percentage-space a point indicates.\r\n\t\t\t\t// For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-devided.\r\n\t\t\t\t// Round the percentage offset to an even number, then divide by two\r\n\t\t\t\t// to spread the offset on both sides of the range.\r\n\t\t\t\tstepsize = pctDifference/realSteps;\r\n\r\n\t\t\t\t// Divide all points evenly, adding the correct number to this subrange.\r\n\t\t\t\t// Run up to <= so that 100% gets a point, event if ignoreLast is set.\r\n\t\t\t\tfor ( q = 1; q <= realSteps; q += 1 ) {\r\n\r\n\t\t\t\t\t// The ratio between the rounded value and the actual size might be ~1% off.\r\n\t\t\t\t\t// Correct the percentage offset by the number of points\r\n\t\t\t\t\t// per subrange. density = 1 will result in 100 points on the\r\n\t\t\t\t\t// full range, 2 for 50, 4 for 25, etc.\r\n\t\t\t\t\tpctPos = prevPct + ( q * stepsize );\r\n\t\t\t\t\tindexes[pctPos.toFixed(5)] = ['x', 0];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Determine the point type.\r\n\t\t\t\ttype = (group.indexOf(i) > -1) ? 1 : ( mode === 'steps' ? 2 : 0 );\r\n\r\n\t\t\t\t// Enforce the 'ignoreFirst' option by overwriting the type for 0.\r\n\t\t\t\tif ( !index && ignoreFirst ) {\r\n\t\t\t\t\ttype = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( !(i === high && ignoreLast)) {\r\n\t\t\t\t\t// Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.\r\n\t\t\t\t\tindexes[newPct.toFixed(5)] = [i, type];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Update the percentage count.\r\n\t\t\t\tprevPct = newPct;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn indexes;\r\n\t}\r\n\r\n\tfunction addMarking ( spread, filterFunc, formatter ) {\r\n\r\n\t\tvar element = document.createElement('div');\r\n\t\tvar out = '';\r\n\t\tvar valueSizeClasses = [\r\n\t\t\toptions.cssClasses.valueNormal,\r\n\t\t\toptions.cssClasses.valueLarge,\r\n\t\t\toptions.cssClasses.valueSub\r\n\t\t];\r\n\t\tvar markerSizeClasses = [\r\n\t\t\toptions.cssClasses.markerNormal,\r\n\t\t\toptions.cssClasses.markerLarge,\r\n\t\t\toptions.cssClasses.markerSub\r\n\t\t];\r\n\t\tvar valueOrientationClasses = [\r\n\t\t\toptions.cssClasses.valueHorizontal,\r\n\t\t\toptions.cssClasses.valueVertical\r\n\t\t];\r\n\t\tvar markerOrientationClasses = [\r\n\t\t\toptions.cssClasses.markerHorizontal,\r\n\t\t\toptions.cssClasses.markerVertical\r\n\t\t];\r\n\r\n\t\taddClass(element, options.cssClasses.pips);\r\n\t\taddClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);\r\n\r\n\t\tfunction getClasses( type, source ){\r\n\t\t\tvar a = source === options.cssClasses.value;\r\n\t\t\tvar orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;\r\n\t\t\tvar sizeClasses = a ? valueSizeClasses : markerSizeClasses;\r\n\r\n\t\t\treturn source + ' ' + orientationClasses[options.ort] + ' ' + sizeClasses[type];\r\n\t\t}\r\n\r\n\t\tfunction getTags( offset, source, values ) {\r\n\t\t\treturn 'class=\"' + getClasses(values[1], source) + '\" style=\"' + options.style + ': ' + offset + '%\"';\r\n\t\t}\r\n\r\n\t\tfunction addSpread ( offset, values ){\r\n\r\n\t\t\t// Apply the filter function, if it is set.\r\n\t\t\tvalues[1] = (values[1] && filterFunc) ? filterFunc(values[0], values[1]) : values[1];\r\n\r\n\t\t\t// Add a marker for every point\r\n\t\t\tout += '<div ' + getTags(offset, options.cssClasses.marker, values) + '></div>';\r\n\r\n\t\t\t// Values are only appended for points marked '1' or '2'.\r\n\t\t\tif ( values[1] ) {\r\n\t\t\t\tout += '<div ' + getTags(offset, options.cssClasses.value, values) + '>' + formatter.to(values[0]) + '</div>';\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Append all points.\r\n\t\tObject.keys(spread).forEach(function(a){\r\n\t\t\taddSpread(a, spread[a]);\r\n\t\t});\r\n\r\n\t\telement.innerHTML = out;\r\n\r\n\t\treturn element;\r\n\t}\r\n\r\n\tfunction pips ( grid ) {\r\n\r\n\t\tvar mode = grid.mode;\r\n\t\tvar density = grid.density || 1;\r\n\t\tvar filter = grid.filter || false;\r\n\t\tvar values = grid.values || false;\r\n\t\tvar stepped = grid.stepped || false;\r\n\t\tvar group = getGroup( mode, values, stepped );\r\n\t\tvar spread = generateSpread( density, mode, group );\r\n\t\tvar format = grid.format || {\r\n\t\t\tto: Math.round\r\n\t\t};\r\n\r\n\t\treturn scope_Target.appendChild(addMarking(\r\n\t\t\tspread,\r\n\t\t\tfilter,\r\n\t\t\tformat\r\n\t\t));\r\n\t}\r\n\r\n\r\n\t// Shorthand for base dimensions.\r\n\tfunction baseSize ( ) {\r\n\t\tvar rect = scope_Base.getBoundingClientRect(), alt = 'offset' + ['Width', 'Height'][options.ort];\r\n\t\treturn options.ort === 0 ? (rect.width||scope_Base[alt]) : (rect.height||scope_Base[alt]);\r\n\t}\r\n\r\n\t// Handler for attaching events trough a proxy.\r\n\tfunction attachEvent ( events, element, callback, data ) {\r\n\r\n\t\t// This function can be used to 'filter' events to the slider.\r\n\t\t// element is a node, not a nodeList\r\n\r\n\t\tvar method = function ( e ){\r\n\r\n\t\t\tif ( scope_Target.hasAttribute('disabled') ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Stop if an active 'tap' transition is taking place.\r\n\t\t\tif ( hasClass(scope_Target, options.cssClasses.tap) ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\te = fixEvent(e, data.pageOffset);\r\n\r\n\t\t\t// Handle reject of multitouch\r\n\t\t\tif ( !e ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Ignore right or middle clicks on start #454\r\n\t\t\tif ( events === actions.start && e.buttons !== undefined && e.buttons > 1 ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Ignore right or middle clicks on start #454\r\n\t\t\tif ( data.hover && e.buttons ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\te.calcPoint = e.points[ options.ort ];\r\n\r\n\t\t\t// Call the event handler with the event [ and additional data ].\r\n\t\t\tcallback ( e, data );\r\n\t\t};\r\n\r\n\t\tvar methods = [];\r\n\r\n\t\t// Bind a closure on the target for every event type.\r\n\t\tevents.split(' ').forEach(function( eventName ){\r\n\t\t\telement.addEventListener(eventName, method, false);\r\n\t\t\tmethods.push([eventName, method]);\r\n\t\t});\r\n\r\n\t\treturn methods;\r\n\t}\r\n\r\n\t// Provide a clean event with standardized offset values.\r\n\tfunction fixEvent ( e, pageOffset ) {\r\n\r\n\t\t// Prevent scrolling and panning on touch events, while\r\n\t\t// attempting to slide. The tap event also depends on this.\r\n\t\te.preventDefault();\r\n\r\n\t\t// Filter the event to register the type, which can be\r\n\t\t// touch, mouse or pointer. Offset changes need to be\r\n\t\t// made on an event specific basis.\r\n\t\tvar touch = e.type.indexOf('touch') === 0;\r\n\t\tvar mouse = e.type.indexOf('mouse') === 0;\r\n\t\tvar pointer = e.type.indexOf('pointer') === 0;\r\n\t\tvar x;\r\n\t\tvar y;\r\n\r\n\t\t// IE10 implemented pointer events with a prefix;\r\n\t\tif ( e.type.indexOf('MSPointer') === 0 ) {\r\n\t\t\tpointer = true;\r\n\t\t}\r\n\r\n\t\tif ( touch ) {\r\n\r\n\t\t\t// Fix bug when user touches with two or more fingers on mobile devices.\r\n\t\t\t// It's useful when you have two or more sliders on one page,\r\n\t\t\t// that can be touched simultaneously.\r\n\t\t\t// #649, #663, #668\r\n\t\t\tif ( e.touches.length > 1 ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// noUiSlider supports one movement at a time,\r\n\t\t\t// so we can select the first 'changedTouch'.\r\n\t\t\tx = e.changedTouches[0].pageX;\r\n\t\t\ty = e.changedTouches[0].pageY;\r\n\t\t}\r\n\r\n\t\tpageOffset = pageOffset || getPageOffset();\r\n\r\n\t\tif ( mouse || pointer ) {\r\n\t\t\tx = e.clientX + pageOffset.x;\r\n\t\t\ty = e.clientY + pageOffset.y;\r\n\t\t}\r\n\r\n\t\te.pageOffset = pageOffset;\r\n\t\te.points = [x, y];\r\n\t\te.cursor = mouse || pointer; // Fix #435\r\n\r\n\t\treturn e;\r\n\t}\r\n\r\n\t// Translate a coordinate in the document to a percentage on the slider\r\n\tfunction calcPointToPercentage ( calcPoint ) {\r\n\t\tvar location = calcPoint - offset(scope_Base, options.ort);\r\n\t\tvar proposal = ( location * 100 ) / baseSize();\r\n\t\treturn options.dir ? 100 - proposal : proposal;\r\n\t}\r\n\r\n\t// Find handle closest to a certain percentage on the slider\r\n\tfunction getClosestHandle ( proposal ) {\r\n\r\n\t\tvar closest = 100;\r\n\t\tvar handleNumber = false;\r\n\r\n\t\tscope_Handles.forEach(function(handle, index){\r\n\r\n\t\t\t// Disabled handles are ignored\r\n\t\t\tif ( handle.hasAttribute('disabled') ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar pos = Math.abs(scope_Locations[index] - proposal);\r\n\r\n\t\t\tif ( pos < closest ) {\r\n\t\t\t\thandleNumber = index;\r\n\t\t\t\tclosest = pos;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn handleNumber;\r\n\t}\r\n\r\n\t// Moves handle(s) by a percentage\r\n\t// (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])\r\n\tfunction moveHandles ( upward, proposal, locations, handleNumbers ) {\r\n\r\n\t\tvar proposals = locations.slice();\r\n\r\n\t\tvar b = [!upward, upward];\r\n\t\tvar f = [upward, !upward];\r\n\r\n\t\t// Copy handleNumbers so we don't change the dataset\r\n\t\thandleNumbers = handleNumbers.slice();\r\n\r\n\t\t// Check to see which handle is 'leading'.\r\n\t\t// If that one can't move the second can't either.\r\n\t\tif ( upward ) {\r\n\t\t\thandleNumbers.reverse();\r\n\t\t}\r\n\r\n\t\t// Step 1: get the maximum percentage that any of the handles can move\r\n\t\tif ( handleNumbers.length > 1 ) {\r\n\r\n\t\t\thandleNumbers.forEach(function(handleNumber, o) {\r\n\r\n\t\t\t\tvar to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o]);\r\n\r\n\t\t\t\t// Stop if one of the handles can't move.\r\n\t\t\t\tif ( to === false ) {\r\n\t\t\t\t\tproposal = 0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tproposal = to - proposals[handleNumber];\r\n\t\t\t\t\tproposals[handleNumber] = to;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// If using one handle, check backward AND forward\r\n\t\telse {\r\n\t\t\tb = f = [true];\r\n\t\t}\r\n\r\n\t\tvar state = false;\r\n\r\n\t\t// Step 2: Try to set the handles with the found percentage\r\n\t\thandleNumbers.forEach(function(handleNumber, o) {\r\n\t\t\tstate = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state;\r\n\t\t});\r\n\r\n\t\t// Step 3: If a handle moved, fire events\r\n\t\tif ( state ) {\r\n\t\t\thandleNumbers.forEach(function(handleNumber){\r\n\t\t\t\tfireEvent('update', handleNumber);\r\n\t\t\t\tfireEvent('slide', handleNumber);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t// External event handling\r\n\tfunction fireEvent ( eventName, handleNumber, tap ) {\r\n\r\n\t\tObject.keys(scope_Events).forEach(function( targetEvent ) {\r\n\r\n\t\t\tvar eventType = targetEvent.split('.')[0];\r\n\r\n\t\t\tif ( eventName === eventType ) {\r\n\t\t\t\tscope_Events[targetEvent].forEach(function( callback ) {\r\n\r\n\t\t\t\t\tcallback.call(\r\n\t\t\t\t\t\t// Use the slider public API as the scope ('this')\r\n\t\t\t\t\t\tscope_Self,\r\n\t\t\t\t\t\t// Return values as array, so arg_1[arg_2] is always valid.\r\n\t\t\t\t\t\tscope_Values.map(options.format.to),\r\n\t\t\t\t\t\t// Handle index, 0 or 1\r\n\t\t\t\t\t\thandleNumber,\r\n\t\t\t\t\t\t// Unformatted slider values\r\n\t\t\t\t\t\tscope_Values.slice(),\r\n\t\t\t\t\t\t// Event is fired by tap, true or false\r\n\t\t\t\t\t\ttap || false,\r\n\t\t\t\t\t\t// Left offset of the handle, in relation to the slider\r\n\t\t\t\t\t\tscope_Locations.slice()\r\n\t\t\t\t\t);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\r\n\t// Fire 'end' when a mouse or pen leaves the document.\r\n\tfunction documentLeave ( event, data ) {\r\n\t\tif ( event.type === \"mouseout\" && event.target.nodeName === \"HTML\" && event.relatedTarget === null ){\r\n\t\t\teventEnd (event, data);\r\n\t\t}\r\n\t}\r\n\r\n\t// Handle movement on document for handle and range drag.\r\n\tfunction eventMove ( event, data ) {\r\n\r\n\t\t// Fix #498\r\n\t\t// Check value of .buttons in 'start' to work around a bug in IE10 mobile (data.buttonsProperty).\r\n\t\t// https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero\r\n\t\t// IE9 has .buttons and .which zero on mousemove.\r\n\t\t// Firefox breaks the spec MDN defines.\r\n\t\tif ( navigator.appVersion.indexOf(\"MSIE 9\") === -1 && event.buttons === 0 && data.buttonsProperty !== 0 ) {\r\n\t\t\treturn eventEnd(event, data);\r\n\t\t}\r\n\r\n\t\t// Check if we are moving up or down\r\n\t\tvar movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);\r\n\r\n\t\t// Convert the movement into a percentage of the slider width/height\r\n\t\tvar proposal = (movement * 100) / data.baseSize;\r\n\r\n\t\tmoveHandles(movement > 0, proposal, data.locations, data.handleNumbers);\r\n\t}\r\n\r\n\t// Unbind move events on document, call callbacks.\r\n\tfunction eventEnd ( event, data ) {\r\n\r\n\t\t// The handle is no longer active, so remove the class.\r\n\t\tif ( scope_ActiveHandle ) {\r\n\t\t\tremoveClass(scope_ActiveHandle, options.cssClasses.active);\r\n\t\t\tscope_ActiveHandle = false;\r\n\t\t}\r\n\r\n\t\t// Remove cursor styles and text-selection events bound to the body.\r\n\t\tif ( event.cursor ) {\r\n\t\t\tdocument.body.style.cursor = '';\r\n\t\t\tdocument.body.removeEventListener('selectstart', document.body.noUiListener);\r\n\t\t}\r\n\r\n\t\t// Unbind the move and end events, which are added on 'start'.\r\n\t\tdocument.documentElement.noUiListeners.forEach(function( c ) {\r\n\t\t\tdocument.documentElement.removeEventListener(c[0], c[1]);\r\n\t\t});\r\n\r\n\t\t// Remove dragging class.\r\n\t\tremoveClass(scope_Target, options.cssClasses.drag);\r\n\r\n\t\tsetZindex();\r\n\r\n\t\tdata.handleNumbers.forEach(function(handleNumber){\r\n\t\t\tfireEvent('set', handleNumber);\r\n\t\t\tfireEvent('change', handleNumber);\r\n\t\t\tfireEvent('end', handleNumber);\r\n\t\t});\r\n\t}\r\n\r\n\t// Bind move events on document.\r\n\tfunction eventStart ( event, data ) {\r\n\r\n\t\tif ( data.handleNumbers.length === 1 ) {\r\n\r\n\t\t\tvar handle = scope_Handles[data.handleNumbers[0]];\r\n\r\n\t\t\t// Ignore 'disabled' handles\r\n\t\t\tif ( handle.hasAttribute('disabled') ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Mark the handle as 'active' so it can be styled.\r\n\t\t\tscope_ActiveHandle = handle.children[0];\r\n\t\t\taddClass(scope_ActiveHandle, options.cssClasses.active);\r\n\t\t}\r\n\r\n\t\t// Fix #551, where a handle gets selected instead of dragged.\r\n\t\tevent.preventDefault();\r\n\r\n\t\t// A drag should never propagate up to the 'tap' event.\r\n\t\tevent.stopPropagation();\r\n\r\n\t\t// Attach the move and end events.\r\n\t\tvar moveEvent = attachEvent(actions.move, document.documentElement, eventMove, {\r\n\t\t\tstartCalcPoint: event.calcPoint,\r\n\t\t\tbaseSize: baseSize(),\r\n\t\t\tpageOffset: event.pageOffset,\r\n\t\t\thandleNumbers: data.handleNumbers,\r\n\t\t\tbuttonsProperty: event.buttons,\r\n\t\t\tlocations: scope_Locations.slice()\r\n\t\t});\r\n\r\n\t\tvar endEvent = attachEvent(actions.end, document.documentElement, eventEnd, {\r\n\t\t\thandleNumbers: data.handleNumbers\r\n\t\t});\r\n\r\n\t\tvar outEvent = attachEvent(\"mouseout\", document.documentElement, documentLeave, {\r\n\t\t\thandleNumbers: data.handleNumbers\r\n\t\t});\r\n\r\n\t\tdocument.documentElement.noUiListeners = moveEvent.concat(endEvent, outEvent);\r\n\r\n\t\t// Text selection isn't an issue on touch devices,\r\n\t\t// so adding cursor styles can be skipped.\r\n\t\tif ( event.cursor ) {\r\n\r\n\t\t\t// Prevent the 'I' cursor and extend the range-drag cursor.\r\n\t\t\tdocument.body.style.cursor = getComputedStyle(event.target).cursor;\r\n\r\n\t\t\t// Mark the target with a dragging state.\r\n\t\t\tif ( scope_Handles.length > 1 ) {\r\n\t\t\t\taddClass(scope_Target, options.cssClasses.drag);\r\n\t\t\t}\r\n\r\n\t\t\tvar f = function(){\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\r\n\t\t\tdocument.body.noUiListener = f;\r\n\r\n\t\t\t// Prevent text selection when dragging the handles.\r\n\t\t\tdocument.body.addEventListener('selectstart', f, false);\r\n\t\t}\r\n\r\n\t\tdata.handleNumbers.forEach(function(handleNumber){\r\n\t\t\tfireEvent('start', handleNumber);\r\n\t\t});\r\n\t}\r\n\r\n\t// Move closest handle to tapped location.\r\n\tfunction eventTap ( event ) {\r\n\r\n\t\t// The tap event shouldn't propagate up\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tvar proposal = calcPointToPercentage(event.calcPoint);\r\n\t\tvar handleNumber = getClosestHandle(proposal);\r\n\r\n\t\t// Tackle the case that all handles are 'disabled'.\r\n\t\tif ( handleNumber === false ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Flag the slider as it is now in a transitional state.\r\n\t\t// Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.\r\n\t\tif ( !options.events.snap ) {\r\n\t\t\taddClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\r\n\t\t}\r\n\r\n\t\tsetHandle(handleNumber, proposal, true, true);\r\n\r\n\t\tsetZindex();\r\n\r\n\t\tfireEvent('slide', handleNumber, true);\r\n\t\tfireEvent('set', handleNumber, true);\r\n\t\tfireEvent('change', handleNumber, true);\r\n\t\tfireEvent('update', handleNumber, true);\r\n\r\n\t\tif ( options.events.snap ) {\r\n\t\t\teventStart(event, { handleNumbers: [handleNumber] });\r\n\t\t}\r\n\t}\r\n\r\n\t// Fires a 'hover' event for a hovered mouse/pen position.\r\n\tfunction eventHover ( event ) {\r\n\r\n\t\tvar proposal = calcPointToPercentage(event.calcPoint);\r\n\r\n\t\tvar to = scope_Spectrum.getStep(proposal);\r\n\t\tvar value = scope_Spectrum.fromStepping(to);\r\n\r\n\t\tObject.keys(scope_Events).forEach(function( targetEvent ) {\r\n\t\t\tif ( 'hover' === targetEvent.split('.')[0] ) {\r\n\t\t\t\tscope_Events[targetEvent].forEach(function( callback ) {\r\n\t\t\t\t\tcallback.call( scope_Self, value );\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// Attach events to several slider parts.\r\n\tfunction bindSliderEvents ( behaviour ) {\r\n\r\n\t\t// Attach the standard drag event to the handles.\r\n\t\tif ( !behaviour.fixed ) {\r\n\r\n\t\t\tscope_Handles.forEach(function( handle, index ){\r\n\r\n\t\t\t\t// These events are only bound to the visual handle\r\n\t\t\t\t// element, not the 'real' origin element.\r\n\t\t\t\tattachEvent ( actions.start, handle.children[0], eventStart, {\r\n\t\t\t\t\thandleNumbers: [index]\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Attach the tap event to the slider base.\r\n\t\tif ( behaviour.tap ) {\r\n\t\t\tattachEvent (actions.start, scope_Base, eventTap, {});\r\n\t\t}\r\n\r\n\t\t// Fire hover events\r\n\t\tif ( behaviour.hover ) {\r\n\t\t\tattachEvent (actions.move, scope_Base, eventHover, { hover: true });\r\n\t\t}\r\n\r\n\t\t// Make the range draggable.\r\n\t\tif ( behaviour.drag ){\r\n\r\n\t\t\tscope_Connects.forEach(function( connect, index ){\r\n\r\n\t\t\t\tif ( connect === false || index === 0 || index === scope_Connects.length - 1 ) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar handleBefore = scope_Handles[index - 1];\r\n\t\t\t\tvar handleAfter = scope_Handles[index];\r\n\t\t\t\tvar eventHolders = [connect];\r\n\r\n\t\t\t\taddClass(connect, options.cssClasses.draggable);\r\n\r\n\t\t\t\t// When the range is fixed, the entire range can\r\n\t\t\t\t// be dragged by the handles. The handle in the first\r\n\t\t\t\t// origin will propagate the start event upward,\r\n\t\t\t\t// but it needs to be bound manually on the other.\r\n\t\t\t\tif ( behaviour.fixed ) {\r\n\t\t\t\t\teventHolders.push(handleBefore.children[0]);\r\n\t\t\t\t\teventHolders.push(handleAfter.children[0]);\r\n\t\t\t\t}\r\n\r\n\t\t\t\teventHolders.forEach(function( eventHolder ) {\r\n\t\t\t\t\tattachEvent ( actions.start, eventHolder, eventStart, {\r\n\t\t\t\t\t\thandles: [handleBefore, handleAfter],\r\n\t\t\t\t\t\thandleNumbers: [index - 1, index]\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// Split out the handle positioning logic so the Move event can use it, too\r\n\tfunction checkHandlePosition ( reference, handleNumber, to, lookBackward, lookForward ) {\r\n\r\n\t\t// For sliders with multiple handles, limit movement to the other handle.\r\n\t\t// Apply the margin option by adding it to the handle positions.\r\n\t\tif ( scope_Handles.length > 1 ) {\r\n\r\n\t\t\tif ( lookBackward && handleNumber > 0 ) {\r\n\t\t\t\tto = Math.max(to, reference[handleNumber - 1] + options.margin);\r\n\t\t\t}\r\n\r\n\t\t\tif ( lookForward && handleNumber < scope_Handles.length - 1 ) {\r\n\t\t\t\tto = Math.min(to, reference[handleNumber + 1] - options.margin);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// The limit option has the opposite effect, limiting handles to a\r\n\t\t// maximum distance from another. Limit must be > 0, as otherwise\r\n\t\t// handles would be unmoveable.\r\n\t\tif ( scope_Handles.length > 1 && options.limit ) {\r\n\r\n\t\t\tif ( lookBackward && handleNumber > 0 ) {\r\n\t\t\t\tto = Math.min(to, reference[handleNumber - 1] + options.limit);\r\n\t\t\t}\r\n\r\n\t\t\tif ( lookForward && handleNumber < scope_Handles.length - 1 ) {\r\n\t\t\t\tto = Math.max(to, reference[handleNumber + 1] - options.limit);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// The padding option keeps the handles a certain distance from the\r\n\t\t// edges of the slider. Padding must be > 0.\r\n\t\tif ( options.padding ) {\r\n\r\n\t\t\tif ( handleNumber === 0 ) {\r\n\t\t\t\tto = Math.max(to, options.padding);\r\n\t\t\t}\r\n\r\n\t\t\tif ( handleNumber === scope_Handles.length - 1 ) {\r\n\t\t\t\tto = Math.min(to, 100 - options.padding);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tto = scope_Spectrum.getStep(to);\r\n\r\n\t\t// Limit percentage to the 0 - 100 range\r\n\t\tto = limit(to);\r\n\r\n\t\t// Return false if handle can't move\r\n\t\tif ( to === reference[handleNumber] ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn to;\r\n\t}\r\n\r\n\tfunction toPct ( pct ) {\r\n\t\treturn pct + '%';\r\n\t}\r\n\r\n\t// Updates scope_Locations and scope_Values, updates visual state\r\n\tfunction updateHandlePosition ( handleNumber, to ) {\r\n\r\n\t\t// Update locations.\r\n\t\tscope_Locations[handleNumber] = to;\r\n\r\n\t\t// Convert the value to the slider stepping/range.\r\n\t\tscope_Values[handleNumber] = scope_Spectrum.fromStepping(to);\r\n\r\n\t\t// Called synchronously or on the next animationFrame\r\n\t\tvar stateUpdate = function() {\r\n\t\t\tscope_Handles[handleNumber].style[options.style] = toPct(to);\r\n\t\t\tupdateConnect(handleNumber);\r\n\t\t\tupdateConnect(handleNumber + 1);\r\n\t\t};\r\n\r\n\t\t// Set the handle to the new position.\r\n\t\t// Use requestAnimationFrame for efficient painting.\r\n\t\t// No significant effect in Chrome, Edge sees dramatic performace improvements.\r\n\t\t// Option to disable is useful for unit tests, and single-step debugging.\r\n\t\tif ( window.requestAnimationFrame && options.useRequestAnimationFrame ) {\r\n\t\t\twindow.requestAnimationFrame(stateUpdate);\r\n\t\t} else {\r\n\t\t\tstateUpdate();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setZindex ( ) {\r\n\r\n\t\tscope_HandleNumbers.forEach(function(handleNumber){\r\n\t\t\t// Handles before the slider middle are stacked later = higher,\r\n\t\t\t// Handles after the middle later is lower\r\n\t\t\t// [[7] [8] .......... | .......... [5] [4]\r\n\t\t\tvar dir = (scope_Locations[handleNumber] > 50 ? -1 : 1);\r\n\t\t\tvar zIndex = 3 + (scope_Handles.length + (dir * handleNumber));\r\n\t\t\tscope_Handles[handleNumber].childNodes[0].style.zIndex = zIndex;\r\n\t\t});\r\n\t}\r\n\r\n\t// Test suggested values and apply margin, step.\r\n\tfunction setHandle ( handleNumber, to, lookBackward, lookForward ) {\r\n\r\n\t\tto = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward);\r\n\r\n\t\tif ( to === false ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tupdateHandlePosition(handleNumber, to);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Updates style attribute for connect nodes\r\n\tfunction updateConnect ( index ) {\r\n\r\n\t\t// Skip connects set to false\r\n\t\tif ( !scope_Connects[index] ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar l = 0;\r\n\t\tvar h = 100;\r\n\r\n\t\tif ( index !== 0 ) {\r\n\t\t\tl = scope_Locations[index - 1];\r\n\t\t}\r\n\r\n\t\tif ( index !== scope_Connects.length - 1 ) {\r\n\t\t\th = scope_Locations[index];\r\n\t\t}\r\n\r\n\t\tscope_Connects[index].style[options.style] = toPct(l);\r\n\t\tscope_Connects[index].style[options.styleOposite] = toPct(100 - h);\r\n\t}\r\n\r\n\t// ...\r\n\tfunction setValue ( to, handleNumber ) {\r\n\r\n\t\t// Setting with null indicates an 'ignore'.\r\n\t\t// Inputting 'false' is invalid.\r\n\t\tif ( to === null || to === false ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// If a formatted number was passed, attemt to decode it.\r\n\t\tif ( typeof to === 'number' ) {\r\n\t\t\tto = String(to);\r\n\t\t}\r\n\r\n\t\tto = options.format.from(to);\r\n\r\n\t\t// Request an update for all links if the value was invalid.\r\n\t\t// Do so too if setting the handle fails.\r\n\t\tif ( to !== false && !isNaN(to) ) {\r\n\t\t\tsetHandle(handleNumber, scope_Spectrum.toStepping(to), false, false);\r\n\t\t}\r\n\t}\r\n\r\n\t// Set the slider value.\r\n\tfunction valueSet ( input, fireSetEvent ) {\r\n\r\n\t\tvar values = asArray(input);\r\n\t\tvar isInit = scope_Locations[0] === undefined;\r\n\r\n\t\t// Event fires by default\r\n\t\tfireSetEvent = (fireSetEvent === undefined ? true : !!fireSetEvent);\r\n\r\n\t\tvalues.forEach(setValue);\r\n\r\n\t\t// Animation is optional.\r\n\t\t// Make sure the initial values were set before using animated placement.\r\n\t\tif ( options.animate && !isInit ) {\r\n\t\t\taddClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\r\n\t\t}\r\n\r\n\t\t// Now that all base values are set, apply constraints\r\n\t\tscope_HandleNumbers.forEach(function(handleNumber){\r\n\t\t\tsetHandle(handleNumber, scope_Locations[handleNumber], true, false);\r\n\t\t});\r\n\r\n\t\tsetZindex();\r\n\r\n\t\tscope_HandleNumbers.forEach(function(handleNumber){\r\n\r\n\t\t\tfireEvent('update', handleNumber);\r\n\r\n\t\t\t// Fire the event only for handles that received a new value, as per #579\r\n\t\t\tif ( values[handleNumber] !== null && fireSetEvent ) {\r\n\t\t\t\tfireEvent('set', handleNumber);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// Reset slider to initial values\r\n\tfunction valueReset ( fireSetEvent ) {\r\n\t\tvalueSet(options.start, fireSetEvent);\r\n\t}\r\n\r\n\t// Get the slider value.\r\n\tfunction valueGet ( ) {\r\n\r\n\t\tvar values = scope_Values.map(options.format.to);\r\n\r\n\t\t// If only one handle is used, return a single value.\r\n\t\tif ( values.length === 1 ){\r\n\t\t\treturn values[0];\r\n\t\t}\r\n\r\n\t\treturn values;\r\n\t}\r\n\r\n\t// Removes classes from the root and empties it.\r\n\tfunction destroy ( ) {\r\n\r\n\t\tfor ( var key in options.cssClasses ) {\r\n\t\t\tif ( !options.cssClasses.hasOwnProperty(key) ) { continue; }\r\n\t\t\tremoveClass(scope_Target, options.cssClasses[key]);\r\n\t\t}\r\n\r\n\t\twhile (scope_Target.firstChild) {\r\n\t\t\tscope_Target.removeChild(scope_Target.firstChild);\r\n\t\t}\r\n\r\n\t\tdelete scope_Target.noUiSlider;\r\n\t}\r\n\r\n\t// Get the current step size for the slider.\r\n\tfunction getCurrentStep ( ) {\r\n\r\n\t\t// Check all locations, map them to their stepping point.\r\n\t\t// Get the step point, then find it in the input list.\r\n\t\treturn scope_Locations.map(function( location, index ){\r\n\r\n\t\t\tvar nearbySteps = scope_Spectrum.getNearbySteps( location );\r\n\t\t\tvar value = scope_Values[index];\r\n\t\t\tvar increment = nearbySteps.thisStep.step;\r\n\t\t\tvar decrement = null;\r\n\r\n\t\t\t// If the next value in this step moves into the next step,\r\n\t\t\t// the increment is the start of the next step - the current value\r\n\t\t\tif ( increment !== false ) {\r\n\t\t\t\tif ( value + increment > nearbySteps.stepAfter.startValue ) {\r\n\t\t\t\t\tincrement = nearbySteps.stepAfter.startValue - value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// If the value is beyond the starting point\r\n\t\t\tif ( value > nearbySteps.thisStep.startValue ) {\r\n\t\t\t\tdecrement = nearbySteps.thisStep.step;\r\n\t\t\t}\r\n\r\n\t\t\telse if ( nearbySteps.stepBefore.step === false ) {\r\n\t\t\t\tdecrement = false;\r\n\t\t\t}\r\n\r\n\t\t\t// If a handle is at the start of a step, it always steps back into the previous step first\r\n\t\t\telse {\r\n\t\t\t\tdecrement = value - nearbySteps.stepBefore.highestStep;\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// Now, if at the slider edges, there is not in/decrement\r\n\t\t\tif ( location === 100 ) {\r\n\t\t\t\tincrement = null;\r\n\t\t\t}\r\n\r\n\t\t\telse if ( location === 0 ) {\r\n\t\t\t\tdecrement = null;\r\n\t\t\t}\r\n\r\n\t\t\t// As per #391, the comparison for the decrement step can have some rounding issues.\r\n\t\t\tvar stepDecimals = scope_Spectrum.countStepDecimals();\r\n\r\n\t\t\t// Round per #391\r\n\t\t\tif ( increment !== null && increment !== false ) {\r\n\t\t\t\tincrement = Number(increment.toFixed(stepDecimals));\r\n\t\t\t}\r\n\r\n\t\t\tif ( decrement !== null && decrement !== false ) {\r\n\t\t\t\tdecrement = Number(decrement.toFixed(stepDecimals));\r\n\t\t\t}\r\n\r\n\t\t\treturn [decrement, increment];\r\n\t\t});\r\n\t}\r\n\r\n\t// Attach an event to this slider, possibly including a namespace\r\n\tfunction bindEvent ( namespacedEvent, callback ) {\r\n\t\tscope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];\r\n\t\tscope_Events[namespacedEvent].push(callback);\r\n\r\n\t\t// If the event bound is 'update,' fire it immediately for all handles.\r\n\t\tif ( namespacedEvent.split('.')[0] === 'update' ) {\r\n\t\t\tscope_Handles.forEach(function(a, index){\r\n\t\t\t\tfireEvent('update', index);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t// Undo attachment of event\r\n\tfunction removeEvent ( namespacedEvent ) {\r\n\r\n\t\tvar event = namespacedEvent && namespacedEvent.split('.')[0];\r\n\t\tvar namespace = event && namespacedEvent.substring(event.length);\r\n\r\n\t\tObject.keys(scope_Events).forEach(function( bind ){\r\n\r\n\t\t\tvar tEvent = bind.split('.')[0],\r\n\t\t\t\ttNamespace = bind.substring(tEvent.length);\r\n\r\n\t\t\tif ( (!event || event === tEvent) && (!namespace || namespace === tNamespace) ) {\r\n\t\t\t\tdelete scope_Events[bind];\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// Updateable: margin, limit, padding, step, range, animate, snap\r\n\tfunction updateOptions ( optionsToUpdate, fireSetEvent ) {\r\n\r\n\t\t// Spectrum is created using the range, snap, direction and step options.\r\n\t\t// 'snap' and 'step' can be updated, 'direction' cannot, due to event binding.\r\n\t\t// If 'snap' and 'step' are not passed, they should remain unchanged.\r\n\t\tvar v = valueGet();\r\n\r\n\t\tvar updateAble = ['margin', 'limit', 'padding', 'range', 'animate', 'snap', 'step', 'format'];\r\n\r\n\t\t// Only change options that we're actually passed to update.\r\n\t\tupdateAble.forEach(function(name){\r\n\t\t\tif ( optionsToUpdate[name] !== undefined ) {\r\n\t\t\t\toriginalOptions[name] = optionsToUpdate[name];\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tvar newOptions = testOptions(originalOptions);\r\n\r\n\t\t// Load new options into the slider state\r\n\t\tupdateAble.forEach(function(name){\r\n\t\t\tif ( optionsToUpdate[name] !== undefined ) {\r\n\t\t\t\toptions[name] = newOptions[name];\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Save current spectrum direction as testOptions in testRange call\r\n\t\t// doesn't rely on current direction\r\n\t\tnewOptions.spectrum.direction = scope_Spectrum.direction;\r\n\t\tscope_Spectrum = newOptions.spectrum;\r\n\r\n\t\t// Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)\r\n\t\toptions.margin = newOptions.margin;\r\n\t\toptions.limit = newOptions.limit;\r\n\t\toptions.padding = newOptions.padding;\r\n\r\n\t\t// Invalidate the current positioning so valueSet forces an update.\r\n\t\tscope_Locations = [];\r\n\t\tvalueSet(optionsToUpdate.start || v, fireSetEvent);\r\n\t}\r\n\r\n\t// Throw an error if the slider was already initialized.\r\n\tif ( scope_Target.noUiSlider ) {\r\n\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): Slider was already initialized.\");\r\n\t}\r\n\r\n\t// Create the base element, initialise HTML and set classes.\r\n\t// Add handles and connect elements.\r\n\taddSlider(scope_Target);\r\n\taddElements(options.connect, scope_Base);\r\n\r\n\tscope_Self = {\r\n\t\tdestroy: destroy,\r\n\t\tsteps: getCurrentStep,\r\n\t\ton: bindEvent,\r\n\t\toff: removeEvent,\r\n\t\tget: valueGet,\r\n\t\tset: valueSet,\r\n\t\treset: valueReset,\r\n\t\t// Exposed for unit testing, don't use this in your application.\r\n\t\t__moveHandles: function(a, b, c) { moveHandles(a, b, scope_Locations, c); },\r\n\t\toptions: originalOptions, // Issue #600, #678\r\n\t\tupdateOptions: updateOptions,\r\n\t\ttarget: scope_Target, // Issue #597\r\n\t\tpips: pips // Issue #594\r\n\t};\r\n\r\n\t// Attach user events.\r\n\tbindSliderEvents(options.events);\r\n\r\n\t// Use the public value method to set the start values.\r\n\tvalueSet(options.start);\r\n\r\n\tif ( options.pips ) {\r\n\t\tpips(options.pips);\r\n\t}\r\n\r\n\tif ( options.tooltips ) {\r\n\t\ttooltips();\r\n\t}\r\n\r\n\treturn scope_Self;\r\n\r\n}\r\n\r\n\r\n\t// Run the standard initializer\r\n\tfunction initialize ( target, originalOptions ) {\r\n\r\n\t\tif ( !target.nodeName ) {\r\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): create requires a single element.\");\r\n\t\t}\r\n\r\n\t\t// Test the options and create the slider environment;\r\n\t\tvar options = testOptions( originalOptions, target );\r\n\t\tvar api = closure( target, options, originalOptions );\r\n\r\n\t\ttarget.noUiSlider = api;\r\n\r\n\t\treturn api;\r\n\t}\r\n\r\n\t// Use an object instead of a function for future expansibility;\r\n\treturn {\r\n\t\tversion: VERSION,\r\n\t\tcreate: initialize\r\n\t};\r\n\r\n}));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L25vdWlzbGlkZXIvZGlzdHJpYnV0ZS9ub3Vpc2xpZGVyLmpzPzgxMDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCLEVBQUU7QUFDNUQsR0FBRztBQUNILGdDQUFnQyxvQkFBb0IsRUFBRTtBQUN0RDs7O0FBR0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLCtCQUErQjtBQUNq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QUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsY0FBYyxFQUFFOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsV0FBVzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsVUFBVTtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1Q0FBdUMsRUFBRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBub3Vpc2xpZGVyIC0gOS4yLjAgLSAyMDE3LTAxLTExIDEwOjM1OjM0ICovXHJcblxyXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuXHJcbiAgICBpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcclxuXHJcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG4gICAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XHJcblxyXG4gICAgfSBlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICkge1xyXG5cclxuICAgICAgICAvLyBOb2RlL0NvbW1vbkpTXHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzXHJcbiAgICAgICAgd2luZG93Lm5vVWlTbGlkZXIgPSBmYWN0b3J5KCk7XHJcbiAgICB9XHJcblxyXG59KGZ1bmN0aW9uKCApe1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdHZhciBWRVJTSU9OID0gJzkuMi4wJztcclxuXHJcblxyXG5cdC8vIENyZWF0ZXMgYSBub2RlLCBhZGRzIGl0IHRvIHRhcmdldCwgcmV0dXJucyB0aGUgbmV3IG5vZGUuXHJcblx0ZnVuY3Rpb24gYWRkTm9kZVRvICggdGFyZ2V0LCBjbGFzc05hbWUgKSB7XHJcblx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRhZGRDbGFzcyhkaXYsIGNsYXNzTmFtZSk7XHJcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoZGl2KTtcclxuXHRcdHJldHVybiBkaXY7XHJcblx0fVxyXG5cclxuXHQvLyBSZW1vdmVzIGR1cGxpY2F0ZXMgZnJvbSBhbiBhcnJheS5cclxuXHRmdW5jdGlvbiB1bmlxdWUgKCBhcnJheSApIHtcclxuXHRcdHJldHVybiBhcnJheS5maWx0ZXIoZnVuY3Rpb24oYSl7XHJcblx0XHRcdHJldHVybiAhdGhpc1thXSA/IHRoaXNbYV0gPSB0cnVlIDogZmFsc2U7XHJcblx0XHR9LCB7fSk7XHJcblx0fVxyXG5cclxuXHQvLyBSb3VuZCBhIHZhbHVlIHRvIHRoZSBjbG9zZXN0ICd0bycuXHJcblx0ZnVuY3Rpb24gY2xvc2VzdCAoIHZhbHVlLCB0byApIHtcclxuXHRcdHJldHVybiBNYXRoLnJvdW5kKHZhbHVlIC8gdG8pICogdG87XHJcblx0fVxyXG5cclxuXHQvLyBDdXJyZW50IHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50LlxyXG5cdGZ1bmN0aW9uIG9mZnNldCAoIGVsZW0sIG9yaWVudGF0aW9uICkge1xyXG5cclxuXHR2YXIgcmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXHJcblx0XHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudCxcclxuXHRcdHBhZ2VPZmZzZXQgPSBnZXRQYWdlT2Zmc2V0KCk7XHJcblxyXG5cdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGNvbnRhaW5zIGxlZnQgc2Nyb2xsIGluIENocm9tZSBvbiBBbmRyb2lkLlxyXG5cdFx0Ly8gSSBoYXZlbid0IGZvdW5kIGEgZmVhdHVyZSBkZXRlY3Rpb24gdGhhdCBwcm92ZXMgdGhpcy4gV29yc3QgY2FzZVxyXG5cdFx0Ly8gc2NlbmFyaW8gb24gbWlzLW1hdGNoOiB0aGUgJ3RhcCcgZmVhdHVyZSBvbiBob3Jpem9udGFsIHNsaWRlcnMgYnJlYWtzLlxyXG5cdFx0aWYgKCAvd2Via2l0LipDaHJvbWUuKk1vYmlsZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgKSB7XHJcblx0XHRcdHBhZ2VPZmZzZXQueCA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9yaWVudGF0aW9uID8gKHJlY3QudG9wICsgcGFnZU9mZnNldC55IC0gZG9jRWxlbS5jbGllbnRUb3ApIDogKHJlY3QubGVmdCArIHBhZ2VPZmZzZXQueCAtIGRvY0VsZW0uY2xpZW50TGVmdCk7XHJcblx0fVxyXG5cclxuXHQvLyBDaGVja3Mgd2hldGhlciBhIHZhbHVlIGlzIG51bWVyaWNhbC5cclxuXHRmdW5jdGlvbiBpc051bWVyaWMgKCBhICkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBhID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oIGEgKSAmJiBpc0Zpbml0ZSggYSApO1xyXG5cdH1cclxuXHJcblx0Ly8gU2V0cyBhIGNsYXNzIGFuZCByZW1vdmVzIGl0IGFmdGVyIFtkdXJhdGlvbl0gbXMuXHJcblx0ZnVuY3Rpb24gYWRkQ2xhc3NGb3IgKCBlbGVtZW50LCBjbGFzc05hbWUsIGR1cmF0aW9uICkge1xyXG5cdFx0aWYgKGR1cmF0aW9uID4gMCkge1xyXG5cdFx0YWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKTtcclxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xyXG5cdFx0XHRcdHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XHJcblx0XHRcdH0sIGR1cmF0aW9uKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIExpbWl0cyBhIHZhbHVlIHRvIDAgLSAxMDBcclxuXHRmdW5jdGlvbiBsaW1pdCAoIGEgKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oYSwgMTAwKSwgMCk7XHJcblx0fVxyXG5cclxuXHQvLyBXcmFwcyBhIHZhcmlhYmxlIGFzIGFuIGFycmF5LCBpZiBpdCBpc24ndCBvbmUgeWV0LlxyXG5cdC8vIE5vdGUgdGhhdCBhbiBpbnB1dCBhcnJheSBpcyByZXR1cm5lZCBieSByZWZlcmVuY2UhXHJcblx0ZnVuY3Rpb24gYXNBcnJheSAoIGEgKSB7XHJcblx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheShhKSA/IGEgOiBbYV07XHJcblx0fVxyXG5cclxuXHQvLyBDb3VudHMgZGVjaW1hbHNcclxuXHRmdW5jdGlvbiBjb3VudERlY2ltYWxzICggbnVtU3RyICkge1xyXG5cdFx0bnVtU3RyID0gU3RyaW5nKG51bVN0cik7XHJcblx0XHR2YXIgcGllY2VzID0gbnVtU3RyLnNwbGl0KFwiLlwiKTtcclxuXHRcdHJldHVybiBwaWVjZXMubGVuZ3RoID4gMSA/IHBpZWNlc1sxXS5sZW5ndGggOiAwO1xyXG5cdH1cclxuXHJcblx0Ly8gaHR0cDovL3lvdW1pZ2h0bm90bmVlZGpxdWVyeS5jb20vI2FkZF9jbGFzc1xyXG5cdGZ1bmN0aW9uIGFkZENsYXNzICggZWwsIGNsYXNzTmFtZSApIHtcclxuXHRcdGlmICggZWwuY2xhc3NMaXN0ICkge1xyXG5cdFx0XHRlbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlbC5jbGFzc05hbWUgKz0gJyAnICsgY2xhc3NOYW1lO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gaHR0cDovL3lvdW1pZ2h0bm90bmVlZGpxdWVyeS5jb20vI3JlbW92ZV9jbGFzc1xyXG5cdGZ1bmN0aW9uIHJlbW92ZUNsYXNzICggZWwsIGNsYXNzTmFtZSApIHtcclxuXHRcdGlmICggZWwuY2xhc3NMaXN0ICkge1xyXG5cdFx0XHRlbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZShuZXcgUmVnRXhwKCcoXnxcXFxcYiknICsgY2xhc3NOYW1lLnNwbGl0KCcgJykuam9pbignfCcpICsgJyhcXFxcYnwkKScsICdnaScpLCAnICcpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gaHR0cHM6Ly9wbGFpbmpzLmNvbS9qYXZhc2NyaXB0L2F0dHJpYnV0ZXMvYWRkaW5nLXJlbW92aW5nLWFuZC10ZXN0aW5nLWZvci1jbGFzc2VzLTkvXHJcblx0ZnVuY3Rpb24gaGFzQ2xhc3MgKCBlbCwgY2xhc3NOYW1lICkge1xyXG5cdFx0cmV0dXJuIGVsLmNsYXNzTGlzdCA/IGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpIDogbmV3IFJlZ0V4cCgnXFxcXGInICsgY2xhc3NOYW1lICsgJ1xcXFxiJykudGVzdChlbC5jbGFzc05hbWUpO1xyXG5cdH1cclxuXHJcblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9zY3JvbGxZI05vdGVzXHJcblx0ZnVuY3Rpb24gZ2V0UGFnZU9mZnNldCAoICkge1xyXG5cclxuXHRcdHZhciBzdXBwb3J0UGFnZU9mZnNldCA9IHdpbmRvdy5wYWdlWE9mZnNldCAhPT0gdW5kZWZpbmVkLFxyXG5cdFx0XHRpc0NTUzFDb21wYXQgPSAoKGRvY3VtZW50LmNvbXBhdE1vZGUgfHwgXCJcIikgPT09IFwiQ1NTMUNvbXBhdFwiKSxcclxuXHRcdFx0eCA9IHN1cHBvcnRQYWdlT2Zmc2V0ID8gd2luZG93LnBhZ2VYT2Zmc2V0IDogaXNDU1MxQ29tcGF0ID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgOiBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQsXHJcblx0XHRcdHkgPSBzdXBwb3J0UGFnZU9mZnNldCA/IHdpbmRvdy5wYWdlWU9mZnNldCA6IGlzQ1NTMUNvbXBhdCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiB4LFxyXG5cdFx0XHR5OiB5XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0Ly8gd2UgcHJvdmlkZSBhIGZ1bmN0aW9uIHRvIGNvbXB1dGUgY29uc3RhbnRzIGluc3RlYWRcclxuXHQvLyBvZiBhY2Nlc3Npbmcgd2luZG93LiogYXMgc29vbiBhcyB0aGUgbW9kdWxlIG5lZWRzIGl0XHJcblx0Ly8gc28gdGhhdCB3ZSBkbyBub3QgY29tcHV0ZSBhbnl0aGluZyBpZiBub3QgbmVlZGVkXHJcblx0ZnVuY3Rpb24gZ2V0QWN0aW9ucyAoICkge1xyXG5cclxuXHRcdC8vIERldGVybWluZSB0aGUgZXZlbnRzIHRvIGJpbmQuIElFMTEgaW1wbGVtZW50cyBwb2ludGVyRXZlbnRzIHdpdGhvdXRcclxuXHRcdC8vIGEgcHJlZml4LCB3aGljaCBicmVha3MgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBJRTEwIGltcGxlbWVudGF0aW9uLlxyXG5cdFx0cmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgPyB7XHJcblx0XHRcdHN0YXJ0OiAncG9pbnRlcmRvd24nLFxyXG5cdFx0XHRtb3ZlOiAncG9pbnRlcm1vdmUnLFxyXG5cdFx0XHRlbmQ6ICdwb2ludGVydXAnXHJcblx0XHR9IDogd2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkID8ge1xyXG5cdFx0XHRzdGFydDogJ01TUG9pbnRlckRvd24nLFxyXG5cdFx0XHRtb3ZlOiAnTVNQb2ludGVyTW92ZScsXHJcblx0XHRcdGVuZDogJ01TUG9pbnRlclVwJ1xyXG5cdFx0fSA6IHtcclxuXHRcdFx0c3RhcnQ6ICdtb3VzZWRvd24gdG91Y2hzdGFydCcsXHJcblx0XHRcdG1vdmU6ICdtb3VzZW1vdmUgdG91Y2htb3ZlJyxcclxuXHRcdFx0ZW5kOiAnbW91c2V1cCB0b3VjaGVuZCdcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHJcbi8vIFZhbHVlIGNhbGN1bGF0aW9uXHJcblxyXG5cdC8vIERldGVybWluZSB0aGUgc2l6ZSBvZiBhIHN1Yi1yYW5nZSBpbiByZWxhdGlvbiB0byBhIGZ1bGwgcmFuZ2UuXHJcblx0ZnVuY3Rpb24gc3ViUmFuZ2VSYXRpbyAoIHBhLCBwYiApIHtcclxuXHRcdHJldHVybiAoMTAwIC8gKHBiIC0gcGEpKTtcclxuXHR9XHJcblxyXG5cdC8vIChwZXJjZW50YWdlKSBIb3cgbWFueSBwZXJjZW50IGlzIHRoaXMgdmFsdWUgb2YgdGhpcyByYW5nZT9cclxuXHRmdW5jdGlvbiBmcm9tUGVyY2VudGFnZSAoIHJhbmdlLCB2YWx1ZSApIHtcclxuXHRcdHJldHVybiAodmFsdWUgKiAxMDApIC8gKCByYW5nZVsxXSAtIHJhbmdlWzBdICk7XHJcblx0fVxyXG5cclxuXHQvLyAocGVyY2VudGFnZSkgV2hlcmUgaXMgdGhpcyB2YWx1ZSBvbiB0aGlzIHJhbmdlP1xyXG5cdGZ1bmN0aW9uIHRvUGVyY2VudGFnZSAoIHJhbmdlLCB2YWx1ZSApIHtcclxuXHRcdHJldHVybiBmcm9tUGVyY2VudGFnZSggcmFuZ2UsIHJhbmdlWzBdIDwgMCA/XHJcblx0XHRcdHZhbHVlICsgTWF0aC5hYnMocmFuZ2VbMF0pIDpcclxuXHRcdFx0XHR2YWx1ZSAtIHJhbmdlWzBdICk7XHJcblx0fVxyXG5cclxuXHQvLyAodmFsdWUpIEhvdyBtdWNoIGlzIHRoaXMgcGVyY2VudGFnZSBvbiB0aGlzIHJhbmdlP1xyXG5cdGZ1bmN0aW9uIGlzUGVyY2VudGFnZSAoIHJhbmdlLCB2YWx1ZSApIHtcclxuXHRcdHJldHVybiAoKHZhbHVlICogKCByYW5nZVsxXSAtIHJhbmdlWzBdICkpIC8gMTAwKSArIHJhbmdlWzBdO1xyXG5cdH1cclxuXHJcblxyXG4vLyBSYW5nZSBjb252ZXJzaW9uXHJcblxyXG5cdGZ1bmN0aW9uIGdldEogKCB2YWx1ZSwgYXJyICkge1xyXG5cclxuXHRcdHZhciBqID0gMTtcclxuXHJcblx0XHR3aGlsZSAoIHZhbHVlID49IGFycltqXSApe1xyXG5cdFx0XHRqICs9IDE7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGo7XHJcblx0fVxyXG5cclxuXHQvLyAocGVyY2VudGFnZSkgSW5wdXQgYSB2YWx1ZSwgZmluZCB3aGVyZSwgb24gYSBzY2FsZSBvZiAwLTEwMCwgaXQgYXBwbGllcy5cclxuXHRmdW5jdGlvbiB0b1N0ZXBwaW5nICggeFZhbCwgeFBjdCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSA+PSB4VmFsLnNsaWNlKC0xKVswXSApe1xyXG5cdFx0XHRyZXR1cm4gMTAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBqID0gZ2V0SiggdmFsdWUsIHhWYWwgKSwgdmEsIHZiLCBwYSwgcGI7XHJcblxyXG5cdFx0dmEgPSB4VmFsW2otMV07XHJcblx0XHR2YiA9IHhWYWxbal07XHJcblx0XHRwYSA9IHhQY3Rbai0xXTtcclxuXHRcdHBiID0geFBjdFtqXTtcclxuXHJcblx0XHRyZXR1cm4gcGEgKyAodG9QZXJjZW50YWdlKFt2YSwgdmJdLCB2YWx1ZSkgLyBzdWJSYW5nZVJhdGlvIChwYSwgcGIpKTtcclxuXHR9XHJcblxyXG5cdC8vICh2YWx1ZSkgSW5wdXQgYSBwZXJjZW50YWdlLCBmaW5kIHdoZXJlIGl0IGlzIG9uIHRoZSBzcGVjaWZpZWQgcmFuZ2UuXHJcblx0ZnVuY3Rpb24gZnJvbVN0ZXBwaW5nICggeFZhbCwgeFBjdCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0Ly8gVGhlcmUgaXMgbm8gcmFuZ2UgZ3JvdXAgdGhhdCBmaXRzIDEwMFxyXG5cdFx0aWYgKCB2YWx1ZSA+PSAxMDAgKXtcclxuXHRcdFx0cmV0dXJuIHhWYWwuc2xpY2UoLTEpWzBdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBqID0gZ2V0SiggdmFsdWUsIHhQY3QgKSwgdmEsIHZiLCBwYSwgcGI7XHJcblxyXG5cdFx0dmEgPSB4VmFsW2otMV07XHJcblx0XHR2YiA9IHhWYWxbal07XHJcblx0XHRwYSA9IHhQY3Rbai0xXTtcclxuXHRcdHBiID0geFBjdFtqXTtcclxuXHJcblx0XHRyZXR1cm4gaXNQZXJjZW50YWdlKFt2YSwgdmJdLCAodmFsdWUgLSBwYSkgKiBzdWJSYW5nZVJhdGlvIChwYSwgcGIpKTtcclxuXHR9XHJcblxyXG5cdC8vIChwZXJjZW50YWdlKSBHZXQgdGhlIHN0ZXAgdGhhdCBhcHBsaWVzIGF0IGEgY2VydGFpbiB2YWx1ZS5cclxuXHRmdW5jdGlvbiBnZXRTdGVwICggeFBjdCwgeFN0ZXBzLCBzbmFwLCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlID09PSAxMDAgKSB7XHJcblx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaiA9IGdldEooIHZhbHVlLCB4UGN0ICksIGEsIGI7XHJcblxyXG5cdFx0Ly8gSWYgJ3NuYXAnIGlzIHNldCwgc3RlcHMgYXJlIHVzZWQgYXMgZml4ZWQgcG9pbnRzIG9uIHRoZSBzbGlkZXIuXHJcblx0XHRpZiAoIHNuYXAgKSB7XHJcblxyXG5cdFx0XHRhID0geFBjdFtqLTFdO1xyXG5cdFx0XHRiID0geFBjdFtqXTtcclxuXHJcblx0XHRcdC8vIEZpbmQgdGhlIGNsb3Nlc3QgcG9zaXRpb24sIGEgb3IgYi5cclxuXHRcdFx0aWYgKCh2YWx1ZSAtIGEpID4gKChiLWEpLzIpKXtcclxuXHRcdFx0XHRyZXR1cm4gYjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGE7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAheFN0ZXBzW2otMV0gKXtcclxuXHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB4UGN0W2otMV0gKyBjbG9zZXN0KFxyXG5cdFx0XHR2YWx1ZSAtIHhQY3Rbai0xXSxcclxuXHRcdFx0eFN0ZXBzW2otMV1cclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHJcbi8vIEVudHJ5IHBhcnNpbmdcclxuXHJcblx0ZnVuY3Rpb24gaGFuZGxlRW50cnlQb2ludCAoIGluZGV4LCB2YWx1ZSwgdGhhdCApIHtcclxuXHJcblx0XHR2YXIgcGVyY2VudGFnZTtcclxuXHJcblx0XHQvLyBXcmFwIG51bWVyaWNhbCBpbnB1dCBpbiBhbiBhcnJheS5cclxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICkge1xyXG5cdFx0XHR2YWx1ZSA9IFt2YWx1ZV07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUmVqZWN0IGFueSBpbnZhbGlkIGlucHV0LCBieSB0ZXN0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYW4gYXJyYXkuXHJcblx0XHRpZiAoIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCggdmFsdWUgKSAhPT0gJ1tvYmplY3QgQXJyYXldJyApe1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdyYW5nZScgY29udGFpbnMgaW52YWxpZCB2YWx1ZS5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ292ZXJ0IG1pbi9tYXggc3ludGF4IHRvIDAgYW5kIDEwMC5cclxuXHRcdGlmICggaW5kZXggPT09ICdtaW4nICkge1xyXG5cdFx0XHRwZXJjZW50YWdlID0gMDtcclxuXHRcdH0gZWxzZSBpZiAoIGluZGV4ID09PSAnbWF4JyApIHtcclxuXHRcdFx0cGVyY2VudGFnZSA9IDEwMDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBlcmNlbnRhZ2UgPSBwYXJzZUZsb2F0KCBpbmRleCApO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENoZWNrIGZvciBjb3JyZWN0IGlucHV0LlxyXG5cdFx0aWYgKCAhaXNOdW1lcmljKCBwZXJjZW50YWdlICkgfHwgIWlzTnVtZXJpYyggdmFsdWVbMF0gKSApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncmFuZ2UnIHZhbHVlIGlzbid0IG51bWVyaWMuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFN0b3JlIHZhbHVlcy5cclxuXHRcdHRoYXQueFBjdC5wdXNoKCBwZXJjZW50YWdlICk7XHJcblx0XHR0aGF0LnhWYWwucHVzaCggdmFsdWVbMF0gKTtcclxuXHJcblx0XHQvLyBOYU4gd2lsbCBldmFsdWF0ZSB0byBmYWxzZSB0b28sIGJ1dCB0byBrZWVwXHJcblx0XHQvLyBsb2dnaW5nIGNsZWFyLCBzZXQgc3RlcCBleHBsaWNpdGx5LiBNYWtlIHN1cmVcclxuXHRcdC8vIG5vdCB0byBvdmVycmlkZSB0aGUgJ3N0ZXAnIHNldHRpbmcgd2l0aCBmYWxzZS5cclxuXHRcdGlmICggIXBlcmNlbnRhZ2UgKSB7XHJcblx0XHRcdGlmICggIWlzTmFOKCB2YWx1ZVsxXSApICkge1xyXG5cdFx0XHRcdHRoYXQueFN0ZXBzWzBdID0gdmFsdWVbMV07XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoYXQueFN0ZXBzLnB1c2goIGlzTmFOKHZhbHVlWzFdKSA/IGZhbHNlIDogdmFsdWVbMV0gKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGF0LnhIaWdoZXN0Q29tcGxldGVTdGVwLnB1c2goMCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBoYW5kbGVTdGVwUG9pbnQgKCBpLCBuLCB0aGF0ICkge1xyXG5cclxuXHRcdC8vIElnbm9yZSAnZmFsc2UnIHN0ZXBwaW5nLlxyXG5cdFx0aWYgKCAhbiApIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmFjdG9yIHRvIHJhbmdlIHJhdGlvXHJcblx0XHR0aGF0LnhTdGVwc1tpXSA9IGZyb21QZXJjZW50YWdlKFtcclxuXHRcdFx0IHRoYXQueFZhbFtpXVxyXG5cdFx0XHQsdGhhdC54VmFsW2krMV1cclxuXHRcdF0sIG4pIC8gc3ViUmFuZ2VSYXRpbyAoXHJcblx0XHRcdHRoYXQueFBjdFtpXSxcclxuXHRcdFx0dGhhdC54UGN0W2krMV0gKTtcclxuXHJcblx0XHR2YXIgdG90YWxTdGVwcyA9ICh0aGF0LnhWYWxbaSsxXSAtIHRoYXQueFZhbFtpXSkgLyB0aGF0LnhOdW1TdGVwc1tpXTtcclxuXHRcdHZhciBoaWdoZXN0U3RlcCA9IE1hdGguY2VpbChOdW1iZXIodG90YWxTdGVwcy50b0ZpeGVkKDMpKSAtIDEpO1xyXG5cdFx0dmFyIHN0ZXAgPSB0aGF0LnhWYWxbaV0gKyAodGhhdC54TnVtU3RlcHNbaV0gKiBoaWdoZXN0U3RlcCk7XHJcblxyXG5cdFx0dGhhdC54SGlnaGVzdENvbXBsZXRlU3RlcFtpXSA9IHN0ZXA7XHJcblx0fVxyXG5cclxuXHJcbi8vIEludGVyZmFjZVxyXG5cclxuXHQvLyBUaGUgaW50ZXJmYWNlIHRvIFNwZWN0cnVtIGhhbmRsZXMgYWxsIGRpcmVjdGlvbi1iYXNlZFxyXG5cdC8vIGNvbnZlcnNpb25zLCBzbyB0aGUgYWJvdmUgdmFsdWVzIGFyZSB1bmF3YXJlLlxyXG5cclxuXHRmdW5jdGlvbiBTcGVjdHJ1bSAoIGVudHJ5LCBzbmFwLCBkaXJlY3Rpb24sIHNpbmdsZVN0ZXAgKSB7XHJcblxyXG5cdFx0dGhpcy54UGN0ID0gW107XHJcblx0XHR0aGlzLnhWYWwgPSBbXTtcclxuXHRcdHRoaXMueFN0ZXBzID0gWyBzaW5nbGVTdGVwIHx8IGZhbHNlIF07XHJcblx0XHR0aGlzLnhOdW1TdGVwcyA9IFsgZmFsc2UgXTtcclxuXHRcdHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXAgPSBbXTtcclxuXHJcblx0XHR0aGlzLnNuYXAgPSBzbmFwO1xyXG5cdFx0dGhpcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XHJcblxyXG5cdFx0dmFyIGluZGV4LCBvcmRlcmVkID0gWyAvKiBbMCwgJ21pbiddLCBbMSwgJzUwJSddLCBbMiwgJ21heCddICovIF07XHJcblxyXG5cdFx0Ly8gTWFwIHRoZSBvYmplY3Qga2V5cyB0byBhbiBhcnJheS5cclxuXHRcdGZvciAoIGluZGV4IGluIGVudHJ5ICkge1xyXG5cdFx0XHRpZiAoIGVudHJ5Lmhhc093blByb3BlcnR5KGluZGV4KSApIHtcclxuXHRcdFx0XHRvcmRlcmVkLnB1c2goW2VudHJ5W2luZGV4XSwgaW5kZXhdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNvcnQgYWxsIGVudHJpZXMgYnkgdmFsdWUgKG51bWVyaWMgc29ydCkuXHJcblx0XHRpZiAoIG9yZGVyZWQubGVuZ3RoICYmIHR5cGVvZiBvcmRlcmVkWzBdWzBdID09PSBcIm9iamVjdFwiICkge1xyXG5cdFx0XHRvcmRlcmVkLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYVswXVswXSAtIGJbMF1bMF07IH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b3JkZXJlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGFbMF0gLSBiWzBdOyB9KTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Ly8gQ29udmVydCBhbGwgZW50cmllcyB0byBzdWJyYW5nZXMuXHJcblx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgb3JkZXJlZC5sZW5ndGg7IGluZGV4KysgKSB7XHJcblx0XHRcdGhhbmRsZUVudHJ5UG9pbnQob3JkZXJlZFtpbmRleF1bMV0sIG9yZGVyZWRbaW5kZXhdWzBdLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTdG9yZSB0aGUgYWN0dWFsIHN0ZXAgdmFsdWVzLlxyXG5cdFx0Ly8geFN0ZXBzIGlzIHNvcnRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB4UGN0IGFuZCB4VmFsLlxyXG5cdFx0dGhpcy54TnVtU3RlcHMgPSB0aGlzLnhTdGVwcy5zbGljZSgwKTtcclxuXHJcblx0XHQvLyBDb252ZXJ0IGFsbCBudW1lcmljIHN0ZXBzIHRvIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBzdWJyYW5nZSB0aGV5IHJlcHJlc2VudC5cclxuXHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnhOdW1TdGVwcy5sZW5ndGg7IGluZGV4KysgKSB7XHJcblx0XHRcdGhhbmRsZVN0ZXBQb2ludChpbmRleCwgdGhpcy54TnVtU3RlcHNbaW5kZXhdLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdFNwZWN0cnVtLnByb3RvdHlwZS5nZXRNYXJnaW4gPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHZhciBzdGVwID0gdGhpcy54TnVtU3RlcHNbMF07XHJcblxyXG5cdFx0aWYgKCBzdGVwICYmICgodmFsdWUgLyBzdGVwKSAlIDEpICE9PSAwICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdsaW1pdCcsICdtYXJnaW4nIGFuZCAncGFkZGluZycgbXVzdCBiZSBkaXZpc2libGUgYnkgc3RlcC5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueFBjdC5sZW5ndGggPT09IDIgPyBmcm9tUGVyY2VudGFnZSh0aGlzLnhWYWwsIHZhbHVlKSA6IGZhbHNlO1xyXG5cdH07XHJcblxyXG5cdFNwZWN0cnVtLnByb3RvdHlwZS50b1N0ZXBwaW5nID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR2YWx1ZSA9IHRvU3RlcHBpbmcoIHRoaXMueFZhbCwgdGhpcy54UGN0LCB2YWx1ZSApO1xyXG5cclxuXHRcdHJldHVybiB2YWx1ZTtcclxuXHR9O1xyXG5cclxuXHRTcGVjdHJ1bS5wcm90b3R5cGUuZnJvbVN0ZXBwaW5nID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gZnJvbVN0ZXBwaW5nKCB0aGlzLnhWYWwsIHRoaXMueFBjdCwgdmFsdWUgKTtcclxuXHR9O1xyXG5cclxuXHRTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0U3RlcCA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dmFsdWUgPSBnZXRTdGVwKHRoaXMueFBjdCwgdGhpcy54U3RlcHMsIHRoaXMuc25hcCwgdmFsdWUgKTtcclxuXHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fTtcclxuXHJcblx0U3BlY3RydW0ucHJvdG90eXBlLmdldE5lYXJieVN0ZXBzID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR2YXIgaiA9IGdldEoodmFsdWUsIHRoaXMueFBjdCk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0c3RlcEJlZm9yZTogeyBzdGFydFZhbHVlOiB0aGlzLnhWYWxbai0yXSwgc3RlcDogdGhpcy54TnVtU3RlcHNbai0yXSwgaGlnaGVzdFN0ZXA6IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbai0yXSB9LFxyXG5cdFx0XHR0aGlzU3RlcDogeyBzdGFydFZhbHVlOiB0aGlzLnhWYWxbai0xXSwgc3RlcDogdGhpcy54TnVtU3RlcHNbai0xXSwgaGlnaGVzdFN0ZXA6IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbai0xXSB9LFxyXG5cdFx0XHRzdGVwQWZ0ZXI6IHsgc3RhcnRWYWx1ZTogdGhpcy54VmFsW2otMF0sIHN0ZXA6IHRoaXMueE51bVN0ZXBzW2otMF0sIGhpZ2hlc3RTdGVwOiB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwW2otMF0gfVxyXG5cdFx0fTtcclxuXHR9O1xyXG5cclxuXHRTcGVjdHJ1bS5wcm90b3R5cGUuY291bnRTdGVwRGVjaW1hbHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc3RlcERlY2ltYWxzID0gdGhpcy54TnVtU3RlcHMubWFwKGNvdW50RGVjaW1hbHMpO1xyXG5cdFx0cmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIHN0ZXBEZWNpbWFscyk7XHJcbiBcdH07XHJcblxyXG5cdC8vIE91dHNpZGUgdGVzdGluZ1xyXG5cdFNwZWN0cnVtLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFN0ZXAodGhpcy50b1N0ZXBwaW5nKHZhbHVlKSk7XHJcblx0fTtcclxuXHJcbi8qXHRFdmVyeSBpbnB1dCBvcHRpb24gaXMgdGVzdGVkIGFuZCBwYXJzZWQuIFRoaXMnbGwgcHJldmVudFxyXG5cdGVuZGxlc3MgdmFsaWRhdGlvbiBpbiBpbnRlcm5hbCBtZXRob2RzLiBUaGVzZSB0ZXN0cyBhcmVcclxuXHRzdHJ1Y3R1cmVkIHdpdGggYW4gaXRlbSBmb3IgZXZlcnkgb3B0aW9uIGF2YWlsYWJsZS4gQW5cclxuXHRvcHRpb24gY2FuIGJlIG1hcmtlZCBhcyByZXF1aXJlZCBieSBzZXR0aW5nIHRoZSAncicgZmxhZy5cclxuXHRUaGUgdGVzdGluZyBmdW5jdGlvbiBpcyBwcm92aWRlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcclxuXHRcdC0gVGhlIHByb3ZpZGVkIHZhbHVlIGZvciB0aGUgb3B0aW9uO1xyXG5cdFx0LSBBIHJlZmVyZW5jZSB0byB0aGUgb3B0aW9ucyBvYmplY3Q7XHJcblx0XHQtIFRoZSBuYW1lIGZvciB0aGUgb3B0aW9uO1xyXG5cclxuXHRUaGUgdGVzdGluZyBmdW5jdGlvbiByZXR1cm5zIGZhbHNlIHdoZW4gYW4gZXJyb3IgaXMgZGV0ZWN0ZWQsXHJcblx0b3IgdHJ1ZSB3aGVuIGV2ZXJ5dGhpbmcgaXMgT0suIEl0IGNhbiBhbHNvIG1vZGlmeSB0aGUgb3B0aW9uXHJcblx0b2JqZWN0LCB0byBtYWtlIHN1cmUgYWxsIHZhbHVlcyBjYW4gYmUgY29ycmVjdGx5IGxvb3BlZCBlbHNld2hlcmUuICovXHJcblxyXG5cdHZhciBkZWZhdWx0Rm9ybWF0dGVyID0geyAndG8nOiBmdW5jdGlvbiggdmFsdWUgKXtcclxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLnRvRml4ZWQoMik7XHJcblx0fSwgJ2Zyb20nOiBOdW1iZXIgfTtcclxuXHJcblx0ZnVuY3Rpb24gdGVzdFN0ZXAgKCBwYXJzZWQsIGVudHJ5ICkge1xyXG5cclxuXHRcdGlmICggIWlzTnVtZXJpYyggZW50cnkgKSApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnc3RlcCcgaXMgbm90IG51bWVyaWMuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRoZSBzdGVwIG9wdGlvbiBjYW4gc3RpbGwgYmUgdXNlZCB0byBzZXQgc3RlcHBpbmdcclxuXHRcdC8vIGZvciBsaW5lYXIgc2xpZGVycy4gT3ZlcndyaXR0ZW4gaWYgc2V0IGluICdyYW5nZScuXHJcblx0XHRwYXJzZWQuc2luZ2xlU3RlcCA9IGVudHJ5O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGVzdFJhbmdlICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHQvLyBGaWx0ZXIgaW5jb3JyZWN0IGlucHV0LlxyXG5cdFx0aWYgKCB0eXBlb2YgZW50cnkgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkoZW50cnkpICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdyYW5nZScgaXMgbm90IGFuIG9iamVjdC5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2F0Y2ggbWlzc2luZyBzdGFydCBvciBlbmQuXHJcblx0XHRpZiAoIGVudHJ5Lm1pbiA9PT0gdW5kZWZpbmVkIHx8IGVudHJ5Lm1heCA9PT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6IE1pc3NpbmcgJ21pbicgb3IgJ21heCcgaW4gJ3JhbmdlJy5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2F0Y2ggZXF1YWwgc3RhcnQgb3IgZW5kLlxyXG5cdFx0aWYgKCBlbnRyeS5taW4gPT09IGVudHJ5Lm1heCApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncmFuZ2UnICdtaW4nIGFuZCAnbWF4JyBjYW5ub3QgYmUgZXF1YWwuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHBhcnNlZC5zcGVjdHJ1bSA9IG5ldyBTcGVjdHJ1bShlbnRyeSwgcGFyc2VkLnNuYXAsIHBhcnNlZC5kaXIsIHBhcnNlZC5zaW5nbGVTdGVwKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RTdGFydCAoIHBhcnNlZCwgZW50cnkgKSB7XHJcblxyXG5cdFx0ZW50cnkgPSBhc0FycmF5KGVudHJ5KTtcclxuXHJcblx0XHQvLyBWYWxpZGF0ZSBpbnB1dC4gVmFsdWVzIGFyZW4ndCB0ZXN0ZWQsIGFzIHRoZSBwdWJsaWMgLnZhbCBtZXRob2RcclxuXHRcdC8vIHdpbGwgYWx3YXlzIHByb3ZpZGUgYSB2YWxpZCBsb2NhdGlvbi5cclxuXHRcdGlmICggIUFycmF5LmlzQXJyYXkoIGVudHJ5ICkgfHwgIWVudHJ5Lmxlbmd0aCApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnc3RhcnQnIG9wdGlvbiBpcyBpbmNvcnJlY3QuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFN0b3JlIHRoZSBudW1iZXIgb2YgaGFuZGxlcy5cclxuXHRcdHBhcnNlZC5oYW5kbGVzID0gZW50cnkubGVuZ3RoO1xyXG5cclxuXHRcdC8vIFdoZW4gdGhlIHNsaWRlciBpcyBpbml0aWFsaXplZCwgdGhlIC52YWwgbWV0aG9kIHdpbGxcclxuXHRcdC8vIGJlIGNhbGxlZCB3aXRoIHRoZSBzdGFydCBvcHRpb25zLlxyXG5cdFx0cGFyc2VkLnN0YXJ0ID0gZW50cnk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0U25hcCAoIHBhcnNlZCwgZW50cnkgKSB7XHJcblxyXG5cdFx0Ly8gRW5mb3JjZSAxMDAlIHN0ZXBwaW5nIHdpdGhpbiBzdWJyYW5nZXMuXHJcblx0XHRwYXJzZWQuc25hcCA9IGVudHJ5O1xyXG5cclxuXHRcdGlmICggdHlwZW9mIGVudHJ5ICE9PSAnYm9vbGVhbicgKXtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnc25hcCcgb3B0aW9uIG11c3QgYmUgYSBib29sZWFuLlwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RBbmltYXRlICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHQvLyBFbmZvcmNlIDEwMCUgc3RlcHBpbmcgd2l0aGluIHN1YnJhbmdlcy5cclxuXHRcdHBhcnNlZC5hbmltYXRlID0gZW50cnk7XHJcblxyXG5cdFx0aWYgKCB0eXBlb2YgZW50cnkgIT09ICdib29sZWFuJyApe1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdhbmltYXRlJyBvcHRpb24gbXVzdCBiZSBhIGJvb2xlYW4uXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGVzdEFuaW1hdGlvbkR1cmF0aW9uICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHRwYXJzZWQuYW5pbWF0aW9uRHVyYXRpb24gPSBlbnRyeTtcclxuXHJcblx0XHRpZiAoIHR5cGVvZiBlbnRyeSAhPT0gJ251bWJlcicgKXtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnYW5pbWF0aW9uRHVyYXRpb24nIG9wdGlvbiBtdXN0IGJlIGEgbnVtYmVyLlwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RDb25uZWN0ICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHR2YXIgY29ubmVjdCA9IFtmYWxzZV07XHJcblx0XHR2YXIgaTtcclxuXHJcblx0XHQvLyBNYXAgbGVnYWN5IG9wdGlvbnNcclxuXHRcdGlmICggZW50cnkgPT09ICdsb3dlcicgKSB7XHJcblx0XHRcdGVudHJ5ID0gW3RydWUsIGZhbHNlXTtcclxuXHRcdH1cclxuXHJcblx0XHRlbHNlIGlmICggZW50cnkgPT09ICd1cHBlcicgKSB7XHJcblx0XHRcdGVudHJ5ID0gW2ZhbHNlLCB0cnVlXTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBIYW5kbGUgYm9vbGVhbiBvcHRpb25zXHJcblx0XHRpZiAoIGVudHJ5ID09PSB0cnVlIHx8IGVudHJ5ID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAxOyBpIDwgcGFyc2VkLmhhbmRsZXM7IGkrKyApIHtcclxuXHRcdFx0XHRjb25uZWN0LnB1c2goZW50cnkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25uZWN0LnB1c2goZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlamVjdCBpbnZhbGlkIGlucHV0XHJcblx0XHRlbHNlIGlmICggIUFycmF5LmlzQXJyYXkoIGVudHJ5ICkgfHwgIWVudHJ5Lmxlbmd0aCB8fCBlbnRyeS5sZW5ndGggIT09IHBhcnNlZC5oYW5kbGVzICsgMSApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnY29ubmVjdCcgb3B0aW9uIGRvZXNuJ3QgbWF0Y2ggaGFuZGxlIGNvdW50LlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRlbHNlIHtcclxuXHRcdFx0Y29ubmVjdCA9IGVudHJ5O1xyXG5cdFx0fVxyXG5cclxuXHRcdHBhcnNlZC5jb25uZWN0ID0gY29ubmVjdDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RPcmllbnRhdGlvbiAoIHBhcnNlZCwgZW50cnkgKSB7XHJcblxyXG5cdFx0Ly8gU2V0IG9yaWVudGF0aW9uIHRvIGFuIGEgbnVtZXJpY2FsIHZhbHVlIGZvciBlYXN5XHJcblx0XHQvLyBhcnJheSBzZWxlY3Rpb24uXHJcblx0XHRzd2l0Y2ggKCBlbnRyeSApe1xyXG5cdFx0ICBjYXNlICdob3Jpem9udGFsJzpcclxuXHRcdFx0cGFyc2VkLm9ydCA9IDA7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0ICBjYXNlICd2ZXJ0aWNhbCc6XHJcblx0XHRcdHBhcnNlZC5vcnQgPSAxO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdCAgZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnb3JpZW50YXRpb24nIG9wdGlvbiBpcyBpbnZhbGlkLlwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RNYXJnaW4gKCBwYXJzZWQsIGVudHJ5ICkge1xyXG5cclxuXHRcdGlmICggIWlzTnVtZXJpYyhlbnRyeSkgKXtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnbWFyZ2luJyBvcHRpb24gbXVzdCBiZSBudW1lcmljLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJc3N1ZSAjNTgyXHJcblx0XHRpZiAoIGVudHJ5ID09PSAwICkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0cGFyc2VkLm1hcmdpbiA9IHBhcnNlZC5zcGVjdHJ1bS5nZXRNYXJnaW4oZW50cnkpO1xyXG5cclxuXHRcdGlmICggIXBhcnNlZC5tYXJnaW4gKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ21hcmdpbicgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIG9uIGxpbmVhciBzbGlkZXJzLlwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RMaW1pdCAoIHBhcnNlZCwgZW50cnkgKSB7XHJcblxyXG5cdFx0aWYgKCAhaXNOdW1lcmljKGVudHJ5KSApe1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdsaW1pdCcgb3B0aW9uIG11c3QgYmUgbnVtZXJpYy5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0cGFyc2VkLmxpbWl0ID0gcGFyc2VkLnNwZWN0cnVtLmdldE1hcmdpbihlbnRyeSk7XHJcblxyXG5cdFx0aWYgKCAhcGFyc2VkLmxpbWl0IHx8IHBhcnNlZC5oYW5kbGVzIDwgMiApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnbGltaXQnIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBsaW5lYXIgc2xpZGVycyB3aXRoIDIgb3IgbW9yZSBoYW5kbGVzLlwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RQYWRkaW5nICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHRpZiAoICFpc051bWVyaWMoZW50cnkpICl7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IGJlIG51bWVyaWMuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZW50cnkgPT09IDAgKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRwYXJzZWQucGFkZGluZyA9IHBhcnNlZC5zcGVjdHJ1bS5nZXRNYXJnaW4oZW50cnkpO1xyXG5cclxuXHRcdGlmICggIXBhcnNlZC5wYWRkaW5nICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdwYWRkaW5nJyBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgb24gbGluZWFyIHNsaWRlcnMuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcGFyc2VkLnBhZGRpbmcgPCAwICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdwYWRkaW5nJyBvcHRpb24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlci5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwYXJzZWQucGFkZGluZyA+PSA1MCApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncGFkZGluZycgb3B0aW9uIG11c3QgYmUgbGVzcyB0aGFuIGhhbGYgdGhlIHJhbmdlLlwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3REaXJlY3Rpb24gKCBwYXJzZWQsIGVudHJ5ICkge1xyXG5cclxuXHRcdC8vIFNldCBkaXJlY3Rpb24gYXMgYSBudW1lcmljYWwgdmFsdWUgZm9yIGVhc3kgcGFyc2luZy5cclxuXHRcdC8vIEludmVydCBjb25uZWN0aW9uIGZvciBSVEwgc2xpZGVycywgc28gdGhhdCB0aGUgcHJvcGVyXHJcblx0XHQvLyBoYW5kbGVzIGdldCB0aGUgY29ubmVjdC9iYWNrZ3JvdW5kIGNsYXNzZXMuXHJcblx0XHRzd2l0Y2ggKCBlbnRyeSApIHtcclxuXHRcdCAgY2FzZSAnbHRyJzpcclxuXHRcdFx0cGFyc2VkLmRpciA9IDA7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0ICBjYXNlICdydGwnOlxyXG5cdFx0XHRwYXJzZWQuZGlyID0gMTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHQgIGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2RpcmVjdGlvbicgb3B0aW9uIHdhcyBub3QgcmVjb2duaXplZC5cIik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0QmVoYXZpb3VyICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHQvLyBNYWtlIHN1cmUgdGhlIGlucHV0IGlzIGEgc3RyaW5nLlxyXG5cdFx0aWYgKCB0eXBlb2YgZW50cnkgIT09ICdzdHJpbmcnICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdiZWhhdmlvdXInIG11c3QgYmUgYSBzdHJpbmcgY29udGFpbmluZyBvcHRpb25zLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDaGVjayBpZiB0aGUgc3RyaW5nIGNvbnRhaW5zIGFueSBrZXl3b3Jkcy5cclxuXHRcdC8vIE5vbmUgYXJlIHJlcXVpcmVkLlxyXG5cdFx0dmFyIHRhcCA9IGVudHJ5LmluZGV4T2YoJ3RhcCcpID49IDA7XHJcblx0XHR2YXIgZHJhZyA9IGVudHJ5LmluZGV4T2YoJ2RyYWcnKSA+PSAwO1xyXG5cdFx0dmFyIGZpeGVkID0gZW50cnkuaW5kZXhPZignZml4ZWQnKSA+PSAwO1xyXG5cdFx0dmFyIHNuYXAgPSBlbnRyeS5pbmRleE9mKCdzbmFwJykgPj0gMDtcclxuXHRcdHZhciBob3ZlciA9IGVudHJ5LmluZGV4T2YoJ2hvdmVyJykgPj0gMDtcclxuXHJcblx0XHRpZiAoIGZpeGVkICkge1xyXG5cclxuXHRcdFx0aWYgKCBwYXJzZWQuaGFuZGxlcyAhPT0gMiApIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdmaXhlZCcgYmVoYXZpb3VyIG11c3QgYmUgdXNlZCB3aXRoIDIgaGFuZGxlc1wiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVXNlIG1hcmdpbiB0byBlbmZvcmNlIGZpeGVkIHN0YXRlXHJcblx0XHRcdHRlc3RNYXJnaW4ocGFyc2VkLCBwYXJzZWQuc3RhcnRbMV0gLSBwYXJzZWQuc3RhcnRbMF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHBhcnNlZC5ldmVudHMgPSB7XHJcblx0XHRcdHRhcDogdGFwIHx8IHNuYXAsXHJcblx0XHRcdGRyYWc6IGRyYWcsXHJcblx0XHRcdGZpeGVkOiBmaXhlZCxcclxuXHRcdFx0c25hcDogc25hcCxcclxuXHRcdFx0aG92ZXI6IGhvdmVyXHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGVzdFRvb2x0aXBzICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHRpZiAoIGVudHJ5ID09PSBmYWxzZSApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGVsc2UgaWYgKCBlbnRyeSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHBhcnNlZC50b29sdGlwcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcGFyc2VkLmhhbmRsZXM7IGkrKyApIHtcclxuXHRcdFx0XHRwYXJzZWQudG9vbHRpcHMucHVzaCh0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGVsc2Uge1xyXG5cclxuXHRcdFx0cGFyc2VkLnRvb2x0aXBzID0gYXNBcnJheShlbnRyeSk7XHJcblxyXG5cdFx0XHRpZiAoIHBhcnNlZC50b29sdGlwcy5sZW5ndGggIT09IHBhcnNlZC5oYW5kbGVzICkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogbXVzdCBwYXNzIGEgZm9ybWF0dGVyIGZvciBhbGwgaGFuZGxlcy5cIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBhcnNlZC50b29sdGlwcy5mb3JFYWNoKGZ1bmN0aW9uKGZvcm1hdHRlcil7XHJcblx0XHRcdFx0aWYgKCB0eXBlb2YgZm9ybWF0dGVyICE9PSAnYm9vbGVhbicgJiYgKHR5cGVvZiBmb3JtYXR0ZXIgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBmb3JtYXR0ZXIudG8gIT09ICdmdW5jdGlvbicpICkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAndG9vbHRpcHMnIG11c3QgYmUgcGFzc2VkIGEgZm9ybWF0dGVyIG9yICdmYWxzZScuXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0Rm9ybWF0ICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHRwYXJzZWQuZm9ybWF0ID0gZW50cnk7XHJcblxyXG5cdFx0Ly8gQW55IG9iamVjdCB3aXRoIGEgdG8gYW5kIGZyb20gbWV0aG9kIGlzIHN1cHBvcnRlZC5cclxuXHRcdGlmICggdHlwZW9mIGVudHJ5LnRvID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbnRyeS5mcm9tID09PSAnZnVuY3Rpb24nICkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdmb3JtYXQnIHJlcXVpcmVzICd0bycgYW5kICdmcm9tJyBtZXRob2RzLlwiKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RDc3NQcmVmaXggKCBwYXJzZWQsIGVudHJ5ICkge1xyXG5cclxuXHRcdGlmICggZW50cnkgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW50cnkgIT09ICdzdHJpbmcnICYmIGVudHJ5ICE9PSBmYWxzZSApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnY3NzUHJlZml4JyBtdXN0IGJlIGEgc3RyaW5nIG9yIGBmYWxzZWAuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHBhcnNlZC5jc3NQcmVmaXggPSBlbnRyeTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RDc3NDbGFzc2VzICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHRpZiAoIGVudHJ5ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVudHJ5ICE9PSAnb2JqZWN0JyApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnY3NzQ2xhc3NlcycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdHlwZW9mIHBhcnNlZC5jc3NQcmVmaXggPT09ICdzdHJpbmcnICkge1xyXG5cdFx0XHRwYXJzZWQuY3NzQ2xhc3NlcyA9IHt9O1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBlbnRyeSApIHtcclxuXHRcdFx0XHRpZiAoICFlbnRyeS5oYXNPd25Qcm9wZXJ0eShrZXkpICkgeyBjb250aW51ZTsgfVxyXG5cclxuXHRcdFx0XHRwYXJzZWQuY3NzQ2xhc3Nlc1trZXldID0gcGFyc2VkLmNzc1ByZWZpeCArIGVudHJ5W2tleV07XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBhcnNlZC5jc3NDbGFzc2VzID0gZW50cnk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0VXNlUmFmICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHRcdGlmICggZW50cnkgPT09IHRydWUgfHwgZW50cnkgPT09IGZhbHNlICkge1xyXG5cdFx0XHRwYXJzZWQudXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZW50cnk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICd1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnIG9wdGlvbiBzaG91bGQgYmUgdHJ1ZSAoZGVmYXVsdCkgb3IgZmFsc2UuXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gVGVzdCBhbGwgZGV2ZWxvcGVyIHNldHRpbmdzIGFuZCBwYXJzZSB0byBhc3N1bXB0aW9uLXNhZmUgdmFsdWVzLlxyXG5cdGZ1bmN0aW9uIHRlc3RPcHRpb25zICggb3B0aW9ucyApIHtcclxuXHJcblx0XHQvLyBUbyBwcm92ZSBhIGZpeCBmb3IgIzUzNywgZnJlZXplIG9wdGlvbnMgaGVyZS5cclxuXHRcdC8vIElmIHRoZSBvYmplY3QgaXMgbW9kaWZpZWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxyXG5cdFx0Ly8gT2JqZWN0LmZyZWV6ZShvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgcGFyc2VkID0ge1xyXG5cdFx0XHRtYXJnaW46IDAsXHJcblx0XHRcdGxpbWl0OiAwLFxyXG5cdFx0XHRwYWRkaW5nOiAwLFxyXG5cdFx0XHRhbmltYXRlOiB0cnVlLFxyXG5cdFx0XHRhbmltYXRpb25EdXJhdGlvbjogMzAwLFxyXG5cdFx0XHRmb3JtYXQ6IGRlZmF1bHRGb3JtYXR0ZXJcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gVGVzdHMgYXJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlciB0aGV5IGFyZSBwcmVzZW50ZWQgaGVyZS5cclxuXHRcdHZhciB0ZXN0cyA9IHtcclxuXHRcdFx0J3N0ZXAnOiB7IHI6IGZhbHNlLCB0OiB0ZXN0U3RlcCB9LFxyXG5cdFx0XHQnc3RhcnQnOiB7IHI6IHRydWUsIHQ6IHRlc3RTdGFydCB9LFxyXG5cdFx0XHQnY29ubmVjdCc6IHsgcjogdHJ1ZSwgdDogdGVzdENvbm5lY3QgfSxcclxuXHRcdFx0J2RpcmVjdGlvbic6IHsgcjogdHJ1ZSwgdDogdGVzdERpcmVjdGlvbiB9LFxyXG5cdFx0XHQnc25hcCc6IHsgcjogZmFsc2UsIHQ6IHRlc3RTbmFwIH0sXHJcblx0XHRcdCdhbmltYXRlJzogeyByOiBmYWxzZSwgdDogdGVzdEFuaW1hdGUgfSxcclxuXHRcdFx0J2FuaW1hdGlvbkR1cmF0aW9uJzogeyByOiBmYWxzZSwgdDogdGVzdEFuaW1hdGlvbkR1cmF0aW9uIH0sXHJcblx0XHRcdCdyYW5nZSc6IHsgcjogdHJ1ZSwgdDogdGVzdFJhbmdlIH0sXHJcblx0XHRcdCdvcmllbnRhdGlvbic6IHsgcjogZmFsc2UsIHQ6IHRlc3RPcmllbnRhdGlvbiB9LFxyXG5cdFx0XHQnbWFyZ2luJzogeyByOiBmYWxzZSwgdDogdGVzdE1hcmdpbiB9LFxyXG5cdFx0XHQnbGltaXQnOiB7IHI6IGZhbHNlLCB0OiB0ZXN0TGltaXQgfSxcclxuXHRcdFx0J3BhZGRpbmcnOiB7IHI6IGZhbHNlLCB0OiB0ZXN0UGFkZGluZyB9LFxyXG5cdFx0XHQnYmVoYXZpb3VyJzogeyByOiB0cnVlLCB0OiB0ZXN0QmVoYXZpb3VyIH0sXHJcblx0XHRcdCdmb3JtYXQnOiB7IHI6IGZhbHNlLCB0OiB0ZXN0Rm9ybWF0IH0sXHJcblx0XHRcdCd0b29sdGlwcyc6IHsgcjogZmFsc2UsIHQ6IHRlc3RUb29sdGlwcyB9LFxyXG5cdFx0XHQnY3NzUHJlZml4JzogeyByOiBmYWxzZSwgdDogdGVzdENzc1ByZWZpeCB9LFxyXG5cdFx0XHQnY3NzQ2xhc3Nlcyc6IHsgcjogZmFsc2UsIHQ6IHRlc3RDc3NDbGFzc2VzIH0sXHJcblx0XHRcdCd1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnOiB7IHI6IGZhbHNlLCB0OiB0ZXN0VXNlUmFmIH1cclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIGRlZmF1bHRzID0ge1xyXG5cdFx0XHQnY29ubmVjdCc6IGZhbHNlLFxyXG5cdFx0XHQnZGlyZWN0aW9uJzogJ2x0cicsXHJcblx0XHRcdCdiZWhhdmlvdXInOiAndGFwJyxcclxuXHRcdFx0J29yaWVudGF0aW9uJzogJ2hvcml6b250YWwnLFxyXG5cdFx0XHQnY3NzUHJlZml4JyA6ICdub1VpLScsXHJcblx0XHRcdCdjc3NDbGFzc2VzJzoge1xyXG5cdFx0XHRcdHRhcmdldDogJ3RhcmdldCcsXHJcblx0XHRcdFx0YmFzZTogJ2Jhc2UnLFxyXG5cdFx0XHRcdG9yaWdpbjogJ29yaWdpbicsXHJcblx0XHRcdFx0aGFuZGxlOiAnaGFuZGxlJyxcclxuXHRcdFx0XHRoYW5kbGVMb3dlcjogJ2hhbmRsZS1sb3dlcicsXHJcblx0XHRcdFx0aGFuZGxlVXBwZXI6ICdoYW5kbGUtdXBwZXInLFxyXG5cdFx0XHRcdGhvcml6b250YWw6ICdob3Jpem9udGFsJyxcclxuXHRcdFx0XHR2ZXJ0aWNhbDogJ3ZlcnRpY2FsJyxcclxuXHRcdFx0XHRiYWNrZ3JvdW5kOiAnYmFja2dyb3VuZCcsXHJcblx0XHRcdFx0Y29ubmVjdDogJ2Nvbm5lY3QnLFxyXG5cdFx0XHRcdGx0cjogJ2x0cicsXHJcblx0XHRcdFx0cnRsOiAncnRsJyxcclxuXHRcdFx0XHRkcmFnZ2FibGU6ICdkcmFnZ2FibGUnLFxyXG5cdFx0XHRcdGRyYWc6ICdzdGF0ZS1kcmFnJyxcclxuXHRcdFx0XHR0YXA6ICdzdGF0ZS10YXAnLFxyXG5cdFx0XHRcdGFjdGl2ZTogJ2FjdGl2ZScsXHJcblx0XHRcdFx0dG9vbHRpcDogJ3Rvb2x0aXAnLFxyXG5cdFx0XHRcdHBpcHM6ICdwaXBzJyxcclxuXHRcdFx0XHRwaXBzSG9yaXpvbnRhbDogJ3BpcHMtaG9yaXpvbnRhbCcsXHJcblx0XHRcdFx0cGlwc1ZlcnRpY2FsOiAncGlwcy12ZXJ0aWNhbCcsXHJcblx0XHRcdFx0bWFya2VyOiAnbWFya2VyJyxcclxuXHRcdFx0XHRtYXJrZXJIb3Jpem9udGFsOiAnbWFya2VyLWhvcml6b250YWwnLFxyXG5cdFx0XHRcdG1hcmtlclZlcnRpY2FsOiAnbWFya2VyLXZlcnRpY2FsJyxcclxuXHRcdFx0XHRtYXJrZXJOb3JtYWw6ICdtYXJrZXItbm9ybWFsJyxcclxuXHRcdFx0XHRtYXJrZXJMYXJnZTogJ21hcmtlci1sYXJnZScsXHJcblx0XHRcdFx0bWFya2VyU3ViOiAnbWFya2VyLXN1YicsXHJcblx0XHRcdFx0dmFsdWU6ICd2YWx1ZScsXHJcblx0XHRcdFx0dmFsdWVIb3Jpem9udGFsOiAndmFsdWUtaG9yaXpvbnRhbCcsXHJcblx0XHRcdFx0dmFsdWVWZXJ0aWNhbDogJ3ZhbHVlLXZlcnRpY2FsJyxcclxuXHRcdFx0XHR2YWx1ZU5vcm1hbDogJ3ZhbHVlLW5vcm1hbCcsXHJcblx0XHRcdFx0dmFsdWVMYXJnZTogJ3ZhbHVlLWxhcmdlJyxcclxuXHRcdFx0XHR2YWx1ZVN1YjogJ3ZhbHVlLXN1YidcclxuXHRcdFx0fSxcclxuXHRcdFx0J3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSc6IHRydWVcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gUnVuIGFsbCBvcHRpb25zIHRocm91Z2ggYSB0ZXN0aW5nIG1lY2hhbmlzbSB0byBlbnN1cmUgY29ycmVjdFxyXG5cdFx0Ly8gaW5wdXQuIEl0IHNob3VsZCBiZSBub3RlZCB0aGF0IG9wdGlvbnMgbWlnaHQgZ2V0IG1vZGlmaWVkIHRvXHJcblx0XHQvLyBiZSBoYW5kbGVkIHByb3Blcmx5LiBFLmcuIHdyYXBwaW5nIGludGVnZXJzIGluIGFycmF5cy5cclxuXHRcdE9iamVjdC5rZXlzKHRlc3RzKS5mb3JFYWNoKGZ1bmN0aW9uKCBuYW1lICl7XHJcblxyXG5cdFx0XHQvLyBJZiB0aGUgb3B0aW9uIGlzbid0IHNldCwgYnV0IGl0IGlzIHJlcXVpcmVkLCB0aHJvdyBhbiBlcnJvci5cclxuXHRcdFx0aWYgKCBvcHRpb25zW25hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdHNbbmFtZV0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXN0c1tuYW1lXS5yICkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnXCIgKyBuYW1lICsgXCInIGlzIHJlcXVpcmVkLlwiKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0ZXN0c1tuYW1lXS50KCBwYXJzZWQsIG9wdGlvbnNbbmFtZV0gPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRzW25hbWVdIDogb3B0aW9uc1tuYW1lXSApO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gRm9yd2FyZCBwaXBzIG9wdGlvbnNcclxuXHRcdHBhcnNlZC5waXBzID0gb3B0aW9ucy5waXBzO1xyXG5cclxuXHRcdHZhciBzdHlsZXMgPSBbWydsZWZ0JywgJ3RvcCddLCBbJ3JpZ2h0JywgJ2JvdHRvbSddXTtcclxuXHJcblx0XHQvLyBQcmUtZGVmaW5lIHRoZSBzdHlsZXMuXHJcblx0XHRwYXJzZWQuc3R5bGUgPSBzdHlsZXNbcGFyc2VkLmRpcl1bcGFyc2VkLm9ydF07XHJcblx0XHRwYXJzZWQuc3R5bGVPcG9zaXRlID0gc3R5bGVzW3BhcnNlZC5kaXI/MDoxXVtwYXJzZWQub3J0XTtcclxuXHJcblx0XHRyZXR1cm4gcGFyc2VkO1xyXG5cdH1cclxuXHJcblxyXG5mdW5jdGlvbiBjbG9zdXJlICggdGFyZ2V0LCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMgKXtcclxuXHJcblx0dmFyIGFjdGlvbnMgPSBnZXRBY3Rpb25zKCApO1xyXG5cclxuXHQvLyBBbGwgdmFyaWFibGVzIGxvY2FsIHRvICdjbG9zdXJlJyBhcmUgcHJlZml4ZWQgd2l0aCAnc2NvcGVfJ1xyXG5cdHZhciBzY29wZV9UYXJnZXQgPSB0YXJnZXQ7XHJcblx0dmFyIHNjb3BlX0xvY2F0aW9ucyA9IFtdO1xyXG5cdHZhciBzY29wZV9CYXNlO1xyXG5cdHZhciBzY29wZV9IYW5kbGVzO1xyXG5cdHZhciBzY29wZV9IYW5kbGVOdW1iZXJzID0gW107XHJcblx0dmFyIHNjb3BlX0FjdGl2ZUhhbmRsZSA9IGZhbHNlO1xyXG5cdHZhciBzY29wZV9Db25uZWN0cztcclxuXHR2YXIgc2NvcGVfU3BlY3RydW0gPSBvcHRpb25zLnNwZWN0cnVtO1xyXG5cdHZhciBzY29wZV9WYWx1ZXMgPSBbXTtcclxuXHR2YXIgc2NvcGVfRXZlbnRzID0ge307XHJcblx0dmFyIHNjb3BlX1NlbGY7XHJcblxyXG5cclxuXHQvLyBBcHBlbmQgYSBvcmlnaW4gdG8gdGhlIGJhc2VcclxuXHRmdW5jdGlvbiBhZGRPcmlnaW4gKCBiYXNlLCBoYW5kbGVOdW1iZXIgKSB7XHJcblxyXG5cdFx0dmFyIG9yaWdpbiA9IGFkZE5vZGVUbyhiYXNlLCBvcHRpb25zLmNzc0NsYXNzZXMub3JpZ2luKTtcclxuXHRcdHZhciBoYW5kbGUgPSBhZGROb2RlVG8ob3JpZ2luLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlKTtcclxuXHJcblx0XHRoYW5kbGUuc2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZScsIGhhbmRsZU51bWJlcik7XHJcblxyXG5cdFx0aWYgKCBoYW5kbGVOdW1iZXIgPT09IDAgKSB7XHJcblx0XHRcdGFkZENsYXNzKGhhbmRsZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmhhbmRsZUxvd2VyKTtcclxuXHRcdH1cclxuXHJcblx0XHRlbHNlIGlmICggaGFuZGxlTnVtYmVyID09PSBvcHRpb25zLmhhbmRsZXMgLSAxICkge1xyXG5cdFx0XHRhZGRDbGFzcyhoYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5oYW5kbGVVcHBlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9yaWdpbjtcclxuXHR9XHJcblxyXG5cdC8vIEluc2VydCBub2RlcyBmb3IgY29ubmVjdCBlbGVtZW50c1xyXG5cdGZ1bmN0aW9uIGFkZENvbm5lY3QgKCBiYXNlLCBhZGQgKSB7XHJcblxyXG5cdFx0aWYgKCAhYWRkICkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFkZE5vZGVUbyhiYXNlLCBvcHRpb25zLmNzc0NsYXNzZXMuY29ubmVjdCk7XHJcblx0fVxyXG5cclxuXHQvLyBBZGQgaGFuZGxlcyB0byB0aGUgc2xpZGVyIGJhc2UuXHJcblx0ZnVuY3Rpb24gYWRkRWxlbWVudHMgKCBjb25uZWN0T3B0aW9ucywgYmFzZSApIHtcclxuXHJcblx0XHRzY29wZV9IYW5kbGVzID0gW107XHJcblx0XHRzY29wZV9Db25uZWN0cyA9IFtdO1xyXG5cclxuXHRcdHNjb3BlX0Nvbm5lY3RzLnB1c2goYWRkQ29ubmVjdChiYXNlLCBjb25uZWN0T3B0aW9uc1swXSkpO1xyXG5cclxuXHRcdC8vIFs6Ojo6Tz09PT1PPT09PU89PT09XVxyXG5cdFx0Ly8gY29ubmVjdE9wdGlvbnMgPSBbMCwgMSwgMSwgMV1cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmhhbmRsZXM7IGkrKyApIHtcclxuXHRcdFx0Ly8gS2VlcCBhIGxpc3Qgb2YgYWxsIGFkZGVkIGhhbmRsZXMuXHJcblx0XHRcdHNjb3BlX0hhbmRsZXMucHVzaChhZGRPcmlnaW4oYmFzZSwgaSkpO1xyXG5cdFx0XHRzY29wZV9IYW5kbGVOdW1iZXJzW2ldID0gaTtcclxuXHRcdFx0c2NvcGVfQ29ubmVjdHMucHVzaChhZGRDb25uZWN0KGJhc2UsIGNvbm5lY3RPcHRpb25zW2kgKyAxXSkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gSW5pdGlhbGl6ZSBhIHNpbmdsZSBzbGlkZXIuXHJcblx0ZnVuY3Rpb24gYWRkU2xpZGVyICggdGFyZ2V0ICkge1xyXG5cclxuXHRcdC8vIEFwcGx5IGNsYXNzZXMgYW5kIGRhdGEgdG8gdGhlIHRhcmdldC5cclxuXHRcdGFkZENsYXNzKHRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRhcmdldCk7XHJcblxyXG5cdFx0aWYgKCBvcHRpb25zLmRpciA9PT0gMCApIHtcclxuXHRcdFx0YWRkQ2xhc3ModGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMubHRyKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGFkZENsYXNzKHRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnJ0bCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvcHRpb25zLm9ydCA9PT0gMCApIHtcclxuXHRcdFx0YWRkQ2xhc3ModGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMuaG9yaXpvbnRhbCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRhZGRDbGFzcyh0YXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy52ZXJ0aWNhbCk7XHJcblx0XHR9XHJcblxyXG5cdFx0c2NvcGVfQmFzZSA9IGFkZE5vZGVUbyh0YXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5iYXNlKTtcclxuXHR9XHJcblxyXG5cclxuXHRmdW5jdGlvbiBhZGRUb29sdGlwICggaGFuZGxlLCBoYW5kbGVOdW1iZXIgKSB7XHJcblxyXG5cdFx0aWYgKCAhb3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdICkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFkZE5vZGVUbyhoYW5kbGUuZmlyc3RDaGlsZCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRvb2x0aXApO1xyXG5cdH1cclxuXHJcblx0Ly8gVGhlIHRvb2x0aXBzIG9wdGlvbiBpcyBhIHNob3J0aGFuZCBmb3IgdXNpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxyXG5cdGZ1bmN0aW9uIHRvb2x0aXBzICggKSB7XHJcblxyXG5cdFx0Ly8gVG9vbHRpcHMgYXJlIGFkZGVkIHdpdGggb3B0aW9ucy50b29sdGlwcyBpbiBvcmlnaW5hbCBvcmRlci5cclxuXHRcdHZhciB0aXBzID0gc2NvcGVfSGFuZGxlcy5tYXAoYWRkVG9vbHRpcCk7XHJcblxyXG5cdFx0YmluZEV2ZW50KCd1cGRhdGUnLCBmdW5jdGlvbih2YWx1ZXMsIGhhbmRsZU51bWJlciwgdW5lbmNvZGVkKSB7XHJcblxyXG5cdFx0XHRpZiAoICF0aXBzW2hhbmRsZU51bWJlcl0gKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgZm9ybWF0dGVkVmFsdWUgPSB2YWx1ZXNbaGFuZGxlTnVtYmVyXTtcclxuXHJcblx0XHRcdGlmICggb3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdICE9PSB0cnVlICkge1xyXG5cdFx0XHRcdGZvcm1hdHRlZFZhbHVlID0gb3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdLnRvKHVuZW5jb2RlZFtoYW5kbGVOdW1iZXJdKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGlwc1toYW5kbGVOdW1iZXJdLmlubmVySFRNTCA9IGZvcm1hdHRlZFZhbHVlO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHJcblx0ZnVuY3Rpb24gZ2V0R3JvdXAgKCBtb2RlLCB2YWx1ZXMsIHN0ZXBwZWQgKSB7XHJcblxyXG5cdFx0Ly8gVXNlIHRoZSByYW5nZS5cclxuXHRcdGlmICggbW9kZSA9PT0gJ3JhbmdlJyB8fCBtb2RlID09PSAnc3RlcHMnICkge1xyXG5cdFx0XHRyZXR1cm4gc2NvcGVfU3BlY3RydW0ueFZhbDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1vZGUgPT09ICdjb3VudCcgKSB7XHJcblxyXG5cdFx0XHRpZiAoICF2YWx1ZXMgKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAndmFsdWVzJyByZXF1aXJlZCBmb3IgbW9kZSAnY291bnQnLlwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRGl2aWRlIDAgLSAxMDAgaW4gJ2NvdW50JyBwYXJ0cy5cclxuXHRcdFx0dmFyIHNwcmVhZCA9ICggMTAwIC8gKHZhbHVlcyAtIDEpICk7XHJcblx0XHRcdHZhciB2O1xyXG5cdFx0XHR2YXIgaSA9IDA7XHJcblxyXG5cdFx0XHR2YWx1ZXMgPSBbXTtcclxuXHJcblx0XHRcdC8vIExpc3QgdGhlc2UgcGFydHMgYW5kIGhhdmUgdGhlbSBoYW5kbGVkIGFzICdwb3NpdGlvbnMnLlxyXG5cdFx0XHR3aGlsZSAoICh2ID0gaSsrICogc3ByZWFkKSA8PSAxMDAgKSB7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2godik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1vZGUgPSAncG9zaXRpb25zJztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1vZGUgPT09ICdwb3NpdGlvbnMnICkge1xyXG5cclxuXHRcdFx0Ly8gTWFwIGFsbCBwZXJjZW50YWdlcyB0byBvbi1yYW5nZSB2YWx1ZXMuXHJcblx0XHRcdHJldHVybiB2YWx1ZXMubWFwKGZ1bmN0aW9uKCB2YWx1ZSApe1xyXG5cdFx0XHRcdHJldHVybiBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcoIHN0ZXBwZWQgPyBzY29wZV9TcGVjdHJ1bS5nZXRTdGVwKCB2YWx1ZSApIDogdmFsdWUgKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtb2RlID09PSAndmFsdWVzJyApIHtcclxuXHJcblx0XHRcdC8vIElmIHRoZSB2YWx1ZSBtdXN0IGJlIHN0ZXBwZWQsIGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhIHBlcmNlbnRhZ2UgZmlyc3QuXHJcblx0XHRcdGlmICggc3RlcHBlZCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24oIHZhbHVlICl7XHJcblxyXG5cdFx0XHRcdFx0Ly8gQ29udmVydCB0byBwZXJjZW50YWdlLCBhcHBseSBzdGVwLCByZXR1cm4gdG8gdmFsdWUuXHJcblx0XHRcdFx0XHRyZXR1cm4gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKCBzY29wZV9TcGVjdHJ1bS5nZXRTdGVwKCBzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKCB2YWx1ZSApICkgKTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIE90aGVyd2lzZSwgd2UgY2FuIHNpbXBseSB1c2UgdGhlIHZhbHVlcy5cclxuXHRcdFx0cmV0dXJuIHZhbHVlcztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdlbmVyYXRlU3ByZWFkICggZGVuc2l0eSwgbW9kZSwgZ3JvdXAgKSB7XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2FmZUluY3JlbWVudCh2YWx1ZSwgaW5jcmVtZW50KSB7XHJcblx0XHRcdC8vIEF2b2lkIGZsb2F0aW5nIHBvaW50IHZhcmlhbmNlIGJ5IGRyb3BwaW5nIHRoZSBzbWFsbGVzdCBkZWNpbWFsIHBsYWNlcy5cclxuXHRcdFx0cmV0dXJuICh2YWx1ZSArIGluY3JlbWVudCkudG9GaXhlZCg3KSAvIDE7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGluZGV4ZXMgPSB7fTtcclxuXHRcdHZhciBmaXJzdEluUmFuZ2UgPSBzY29wZV9TcGVjdHJ1bS54VmFsWzBdO1xyXG5cdFx0dmFyIGxhc3RJblJhbmdlID0gc2NvcGVfU3BlY3RydW0ueFZhbFtzY29wZV9TcGVjdHJ1bS54VmFsLmxlbmd0aC0xXTtcclxuXHRcdHZhciBpZ25vcmVGaXJzdCA9IGZhbHNlO1xyXG5cdFx0dmFyIGlnbm9yZUxhc3QgPSBmYWxzZTtcclxuXHRcdHZhciBwcmV2UGN0ID0gMDtcclxuXHJcblx0XHQvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBncm91cCwgc29ydCBpdCBhbmQgZmlsdGVyIGF3YXkgYWxsIGR1cGxpY2F0ZXMuXHJcblx0XHRncm91cCA9IHVuaXF1ZShncm91cC5zbGljZSgpLnNvcnQoZnVuY3Rpb24oYSwgYil7IHJldHVybiBhIC0gYjsgfSkpO1xyXG5cclxuXHRcdC8vIE1ha2Ugc3VyZSB0aGUgcmFuZ2Ugc3RhcnRzIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQuXHJcblx0XHRpZiAoIGdyb3VwWzBdICE9PSBmaXJzdEluUmFuZ2UgKSB7XHJcblx0XHRcdGdyb3VwLnVuc2hpZnQoZmlyc3RJblJhbmdlKTtcclxuXHRcdFx0aWdub3JlRmlyc3QgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIExpa2V3aXNlIGZvciB0aGUgbGFzdCBvbmUuXHJcblx0XHRpZiAoIGdyb3VwW2dyb3VwLmxlbmd0aCAtIDFdICE9PSBsYXN0SW5SYW5nZSApIHtcclxuXHRcdFx0Z3JvdXAucHVzaChsYXN0SW5SYW5nZSk7XHJcblx0XHRcdGlnbm9yZUxhc3QgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGdyb3VwLmZvckVhY2goZnVuY3Rpb24gKCBjdXJyZW50LCBpbmRleCApIHtcclxuXHJcblx0XHRcdC8vIEdldCB0aGUgY3VycmVudCBzdGVwIGFuZCB0aGUgbG93ZXIgKyB1cHBlciBwb3NpdGlvbnMuXHJcblx0XHRcdHZhciBzdGVwO1xyXG5cdFx0XHR2YXIgaTtcclxuXHRcdFx0dmFyIHE7XHJcblx0XHRcdHZhciBsb3cgPSBjdXJyZW50O1xyXG5cdFx0XHR2YXIgaGlnaCA9IGdyb3VwW2luZGV4KzFdO1xyXG5cdFx0XHR2YXIgbmV3UGN0O1xyXG5cdFx0XHR2YXIgcGN0RGlmZmVyZW5jZTtcclxuXHRcdFx0dmFyIHBjdFBvcztcclxuXHRcdFx0dmFyIHR5cGU7XHJcblx0XHRcdHZhciBzdGVwcztcclxuXHRcdFx0dmFyIHJlYWxTdGVwcztcclxuXHRcdFx0dmFyIHN0ZXBzaXplO1xyXG5cclxuXHRcdFx0Ly8gV2hlbiB1c2luZyAnc3RlcHMnIG1vZGUsIHVzZSB0aGUgcHJvdmlkZWQgc3RlcHMuXHJcblx0XHRcdC8vIE90aGVyd2lzZSwgd2UnbGwgc3RlcCBvbiB0byB0aGUgbmV4dCBzdWJyYW5nZS5cclxuXHRcdFx0aWYgKCBtb2RlID09PSAnc3RlcHMnICkge1xyXG5cdFx0XHRcdHN0ZXAgPSBzY29wZV9TcGVjdHJ1bS54TnVtU3RlcHNbIGluZGV4IF07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIERlZmF1bHQgdG8gYSAnZnVsbCcgc3RlcC5cclxuXHRcdFx0aWYgKCAhc3RlcCApIHtcclxuXHRcdFx0XHRzdGVwID0gaGlnaC1sb3c7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIExvdyBjYW4gYmUgMCwgc28gdGVzdCBmb3IgZmFsc2UuIElmIGhpZ2ggaXMgdW5kZWZpbmVkLFxyXG5cdFx0XHQvLyB3ZSBhcmUgYXQgdGhlIGxhc3Qgc3VicmFuZ2UuIEluZGV4IDAgaXMgYWxyZWFkeSBoYW5kbGVkLlxyXG5cdFx0XHRpZiAoIGxvdyA9PT0gZmFsc2UgfHwgaGlnaCA9PT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gTWFrZSBzdXJlIHN0ZXAgaXNuJ3QgMCwgd2hpY2ggd291bGQgY2F1c2UgYW4gaW5maW5pdGUgbG9vcCAoIzY1NClcclxuXHRcdFx0c3RlcCA9IE1hdGgubWF4KHN0ZXAsIDAuMDAwMDAwMSk7XHJcblxyXG5cdFx0XHQvLyBGaW5kIGFsbCBzdGVwcyBpbiB0aGUgc3VicmFuZ2UuXHJcblx0XHRcdGZvciAoIGkgPSBsb3c7IGkgPD0gaGlnaDsgaSA9IHNhZmVJbmNyZW1lbnQoaSwgc3RlcCkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIEdldCB0aGUgcGVyY2VudGFnZSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgc3RlcCxcclxuXHRcdFx0XHQvLyBjYWxjdWxhdGUgdGhlIHNpemUgZm9yIHRoZSBzdWJyYW5nZS5cclxuXHRcdFx0XHRuZXdQY3QgPSBzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKCBpICk7XHJcblx0XHRcdFx0cGN0RGlmZmVyZW5jZSA9IG5ld1BjdCAtIHByZXZQY3Q7XHJcblxyXG5cdFx0XHRcdHN0ZXBzID0gcGN0RGlmZmVyZW5jZSAvIGRlbnNpdHk7XHJcblx0XHRcdFx0cmVhbFN0ZXBzID0gTWF0aC5yb3VuZChzdGVwcyk7XHJcblxyXG5cdFx0XHRcdC8vIFRoaXMgcmF0aW8gcmVwcmVzZW50cyB0aGUgYW1tb3VudCBvZiBwZXJjZW50YWdlLXNwYWNlIGEgcG9pbnQgaW5kaWNhdGVzLlxyXG5cdFx0XHRcdC8vIEZvciBhIGRlbnNpdHkgMSB0aGUgcG9pbnRzL3BlcmNlbnRhZ2UgPSAxLiBGb3IgZGVuc2l0eSAyLCB0aGF0IHBlcmNlbnRhZ2UgbmVlZHMgdG8gYmUgcmUtZGV2aWRlZC5cclxuXHRcdFx0XHQvLyBSb3VuZCB0aGUgcGVyY2VudGFnZSBvZmZzZXQgdG8gYW4gZXZlbiBudW1iZXIsIHRoZW4gZGl2aWRlIGJ5IHR3b1xyXG5cdFx0XHRcdC8vIHRvIHNwcmVhZCB0aGUgb2Zmc2V0IG9uIGJvdGggc2lkZXMgb2YgdGhlIHJhbmdlLlxyXG5cdFx0XHRcdHN0ZXBzaXplID0gcGN0RGlmZmVyZW5jZS9yZWFsU3RlcHM7XHJcblxyXG5cdFx0XHRcdC8vIERpdmlkZSBhbGwgcG9pbnRzIGV2ZW5seSwgYWRkaW5nIHRoZSBjb3JyZWN0IG51bWJlciB0byB0aGlzIHN1YnJhbmdlLlxyXG5cdFx0XHRcdC8vIFJ1biB1cCB0byA8PSBzbyB0aGF0IDEwMCUgZ2V0cyBhIHBvaW50LCBldmVudCBpZiBpZ25vcmVMYXN0IGlzIHNldC5cclxuXHRcdFx0XHRmb3IgKCBxID0gMTsgcSA8PSByZWFsU3RlcHM7IHEgKz0gMSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBUaGUgcmF0aW8gYmV0d2VlbiB0aGUgcm91bmRlZCB2YWx1ZSBhbmQgdGhlIGFjdHVhbCBzaXplIG1pZ2h0IGJlIH4xJSBvZmYuXHJcblx0XHRcdFx0XHQvLyBDb3JyZWN0IHRoZSBwZXJjZW50YWdlIG9mZnNldCBieSB0aGUgbnVtYmVyIG9mIHBvaW50c1xyXG5cdFx0XHRcdFx0Ly8gcGVyIHN1YnJhbmdlLiBkZW5zaXR5ID0gMSB3aWxsIHJlc3VsdCBpbiAxMDAgcG9pbnRzIG9uIHRoZVxyXG5cdFx0XHRcdFx0Ly8gZnVsbCByYW5nZSwgMiBmb3IgNTAsIDQgZm9yIDI1LCBldGMuXHJcblx0XHRcdFx0XHRwY3RQb3MgPSBwcmV2UGN0ICsgKCBxICogc3RlcHNpemUgKTtcclxuXHRcdFx0XHRcdGluZGV4ZXNbcGN0UG9zLnRvRml4ZWQoNSldID0gWyd4JywgMF07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBEZXRlcm1pbmUgdGhlIHBvaW50IHR5cGUuXHJcblx0XHRcdFx0dHlwZSA9IChncm91cC5pbmRleE9mKGkpID4gLTEpID8gMSA6ICggbW9kZSA9PT0gJ3N0ZXBzJyA/IDIgOiAwICk7XHJcblxyXG5cdFx0XHRcdC8vIEVuZm9yY2UgdGhlICdpZ25vcmVGaXJzdCcgb3B0aW9uIGJ5IG92ZXJ3cml0aW5nIHRoZSB0eXBlIGZvciAwLlxyXG5cdFx0XHRcdGlmICggIWluZGV4ICYmIGlnbm9yZUZpcnN0ICkge1xyXG5cdFx0XHRcdFx0dHlwZSA9IDA7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoICEoaSA9PT0gaGlnaCAmJiBpZ25vcmVMYXN0KSkge1xyXG5cdFx0XHRcdFx0Ly8gTWFyayB0aGUgJ3R5cGUnIG9mIHRoaXMgcG9pbnQuIDAgPSBwbGFpbiwgMSA9IHJlYWwgdmFsdWUsIDIgPSBzdGVwIHZhbHVlLlxyXG5cdFx0XHRcdFx0aW5kZXhlc1tuZXdQY3QudG9GaXhlZCg1KV0gPSBbaSwgdHlwZV07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIHBlcmNlbnRhZ2UgY291bnQuXHJcblx0XHRcdFx0cHJldlBjdCA9IG5ld1BjdDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGluZGV4ZXM7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBhZGRNYXJraW5nICggc3ByZWFkLCBmaWx0ZXJGdW5jLCBmb3JtYXR0ZXIgKSB7XHJcblxyXG5cdFx0dmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdHZhciBvdXQgPSAnJztcclxuXHRcdHZhciB2YWx1ZVNpemVDbGFzc2VzID0gW1xyXG5cdFx0XHRvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVOb3JtYWwsXHJcblx0XHRcdG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZUxhcmdlLFxyXG5cdFx0XHRvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVTdWJcclxuXHRcdF07XHJcblx0XHR2YXIgbWFya2VyU2l6ZUNsYXNzZXMgPSBbXHJcblx0XHRcdG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJOb3JtYWwsXHJcblx0XHRcdG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJMYXJnZSxcclxuXHRcdFx0b3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlclN1YlxyXG5cdFx0XTtcclxuXHRcdHZhciB2YWx1ZU9yaWVudGF0aW9uQ2xhc3NlcyA9IFtcclxuXHRcdFx0b3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlSG9yaXpvbnRhbCxcclxuXHRcdFx0b3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlVmVydGljYWxcclxuXHRcdF07XHJcblx0XHR2YXIgbWFya2VyT3JpZW50YXRpb25DbGFzc2VzID0gW1xyXG5cdFx0XHRvcHRpb25zLmNzc0NsYXNzZXMubWFya2VySG9yaXpvbnRhbCxcclxuXHRcdFx0b3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlclZlcnRpY2FsXHJcblx0XHRdO1xyXG5cclxuXHRcdGFkZENsYXNzKGVsZW1lbnQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5waXBzKTtcclxuXHRcdGFkZENsYXNzKGVsZW1lbnQsIG9wdGlvbnMub3J0ID09PSAwID8gb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHNIb3Jpem9udGFsIDogb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHNWZXJ0aWNhbCk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0Q2xhc3NlcyggdHlwZSwgc291cmNlICl7XHJcblx0XHRcdHZhciBhID0gc291cmNlID09PSBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWU7XHJcblx0XHRcdHZhciBvcmllbnRhdGlvbkNsYXNzZXMgPSBhID8gdmFsdWVPcmllbnRhdGlvbkNsYXNzZXMgOiBtYXJrZXJPcmllbnRhdGlvbkNsYXNzZXM7XHJcblx0XHRcdHZhciBzaXplQ2xhc3NlcyA9IGEgPyB2YWx1ZVNpemVDbGFzc2VzIDogbWFya2VyU2l6ZUNsYXNzZXM7XHJcblxyXG5cdFx0XHRyZXR1cm4gc291cmNlICsgJyAnICsgb3JpZW50YXRpb25DbGFzc2VzW29wdGlvbnMub3J0XSArICcgJyArIHNpemVDbGFzc2VzW3R5cGVdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldFRhZ3MoIG9mZnNldCwgc291cmNlLCB2YWx1ZXMgKSB7XHJcblx0XHRcdHJldHVybiAnY2xhc3M9XCInICsgZ2V0Q2xhc3Nlcyh2YWx1ZXNbMV0sIHNvdXJjZSkgKyAnXCIgc3R5bGU9XCInICsgb3B0aW9ucy5zdHlsZSArICc6ICcgKyBvZmZzZXQgKyAnJVwiJztcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBhZGRTcHJlYWQgKCBvZmZzZXQsIHZhbHVlcyApe1xyXG5cclxuXHRcdFx0Ly8gQXBwbHkgdGhlIGZpbHRlciBmdW5jdGlvbiwgaWYgaXQgaXMgc2V0LlxyXG5cdFx0XHR2YWx1ZXNbMV0gPSAodmFsdWVzWzFdICYmIGZpbHRlckZ1bmMpID8gZmlsdGVyRnVuYyh2YWx1ZXNbMF0sIHZhbHVlc1sxXSkgOiB2YWx1ZXNbMV07XHJcblxyXG5cdFx0XHQvLyBBZGQgYSBtYXJrZXIgZm9yIGV2ZXJ5IHBvaW50XHJcblx0XHRcdG91dCArPSAnPGRpdiAnICsgZ2V0VGFncyhvZmZzZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXIsIHZhbHVlcykgKyAnPjwvZGl2Pic7XHJcblxyXG5cdFx0XHQvLyBWYWx1ZXMgYXJlIG9ubHkgYXBwZW5kZWQgZm9yIHBvaW50cyBtYXJrZWQgJzEnIG9yICcyJy5cclxuXHRcdFx0aWYgKCB2YWx1ZXNbMV0gKSB7XHJcblx0XHRcdFx0b3V0ICs9ICc8ZGl2ICcgKyBnZXRUYWdzKG9mZnNldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlLCB2YWx1ZXMpICsgJz4nICsgZm9ybWF0dGVyLnRvKHZhbHVlc1swXSkgKyAnPC9kaXY+JztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFwcGVuZCBhbGwgcG9pbnRzLlxyXG5cdFx0T2JqZWN0LmtleXMoc3ByZWFkKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe1xyXG5cdFx0XHRhZGRTcHJlYWQoYSwgc3ByZWFkW2FdKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGVsZW1lbnQuaW5uZXJIVE1MID0gb3V0O1xyXG5cclxuXHRcdHJldHVybiBlbGVtZW50O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcGlwcyAoIGdyaWQgKSB7XHJcblxyXG5cdFx0dmFyIG1vZGUgPSBncmlkLm1vZGU7XHJcblx0XHR2YXIgZGVuc2l0eSA9IGdyaWQuZGVuc2l0eSB8fCAxO1xyXG5cdFx0dmFyIGZpbHRlciA9IGdyaWQuZmlsdGVyIHx8IGZhbHNlO1xyXG5cdFx0dmFyIHZhbHVlcyA9IGdyaWQudmFsdWVzIHx8IGZhbHNlO1xyXG5cdFx0dmFyIHN0ZXBwZWQgPSBncmlkLnN0ZXBwZWQgfHwgZmFsc2U7XHJcblx0XHR2YXIgZ3JvdXAgPSBnZXRHcm91cCggbW9kZSwgdmFsdWVzLCBzdGVwcGVkICk7XHJcblx0XHR2YXIgc3ByZWFkID0gZ2VuZXJhdGVTcHJlYWQoIGRlbnNpdHksIG1vZGUsIGdyb3VwICk7XHJcblx0XHR2YXIgZm9ybWF0ID0gZ3JpZC5mb3JtYXQgfHwge1xyXG5cdFx0XHR0bzogTWF0aC5yb3VuZFxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gc2NvcGVfVGFyZ2V0LmFwcGVuZENoaWxkKGFkZE1hcmtpbmcoXHJcblx0XHRcdHNwcmVhZCxcclxuXHRcdFx0ZmlsdGVyLFxyXG5cdFx0XHRmb3JtYXRcclxuXHRcdCkpO1xyXG5cdH1cclxuXHJcblxyXG5cdC8vIFNob3J0aGFuZCBmb3IgYmFzZSBkaW1lbnNpb25zLlxyXG5cdGZ1bmN0aW9uIGJhc2VTaXplICggKSB7XHJcblx0XHR2YXIgcmVjdCA9IHNjb3BlX0Jhc2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGFsdCA9ICdvZmZzZXQnICsgWydXaWR0aCcsICdIZWlnaHQnXVtvcHRpb25zLm9ydF07XHJcblx0XHRyZXR1cm4gb3B0aW9ucy5vcnQgPT09IDAgPyAocmVjdC53aWR0aHx8c2NvcGVfQmFzZVthbHRdKSA6IChyZWN0LmhlaWdodHx8c2NvcGVfQmFzZVthbHRdKTtcclxuXHR9XHJcblxyXG5cdC8vIEhhbmRsZXIgZm9yIGF0dGFjaGluZyBldmVudHMgdHJvdWdoIGEgcHJveHkuXHJcblx0ZnVuY3Rpb24gYXR0YWNoRXZlbnQgKCBldmVudHMsIGVsZW1lbnQsIGNhbGxiYWNrLCBkYXRhICkge1xyXG5cclxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gJ2ZpbHRlcicgZXZlbnRzIHRvIHRoZSBzbGlkZXIuXHJcblx0XHQvLyBlbGVtZW50IGlzIGEgbm9kZSwgbm90IGEgbm9kZUxpc3RcclxuXHJcblx0XHR2YXIgbWV0aG9kID0gZnVuY3Rpb24gKCBlICl7XHJcblxyXG5cdFx0XHRpZiAoIHNjb3BlX1RhcmdldC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBTdG9wIGlmIGFuIGFjdGl2ZSAndGFwJyB0cmFuc2l0aW9uIGlzIHRha2luZyBwbGFjZS5cclxuXHRcdFx0aWYgKCBoYXNDbGFzcyhzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXApICkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZSA9IGZpeEV2ZW50KGUsIGRhdGEucGFnZU9mZnNldCk7XHJcblxyXG5cdFx0XHQvLyBIYW5kbGUgcmVqZWN0IG9mIG11bHRpdG91Y2hcclxuXHRcdFx0aWYgKCAhZSApIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIElnbm9yZSByaWdodCBvciBtaWRkbGUgY2xpY2tzIG9uIHN0YXJ0ICM0NTRcclxuXHRcdFx0aWYgKCBldmVudHMgPT09IGFjdGlvbnMuc3RhcnQgJiYgZS5idXR0b25zICE9PSB1bmRlZmluZWQgJiYgZS5idXR0b25zID4gMSApIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIElnbm9yZSByaWdodCBvciBtaWRkbGUgY2xpY2tzIG9uIHN0YXJ0ICM0NTRcclxuXHRcdFx0aWYgKCBkYXRhLmhvdmVyICYmIGUuYnV0dG9ucyApIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGUuY2FsY1BvaW50ID0gZS5wb2ludHNbIG9wdGlvbnMub3J0IF07XHJcblxyXG5cdFx0XHQvLyBDYWxsIHRoZSBldmVudCBoYW5kbGVyIHdpdGggdGhlIGV2ZW50IFsgYW5kIGFkZGl0aW9uYWwgZGF0YSBdLlxyXG5cdFx0XHRjYWxsYmFjayAoIGUsIGRhdGEgKTtcclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIG1ldGhvZHMgPSBbXTtcclxuXHJcblx0XHQvLyBCaW5kIGEgY2xvc3VyZSBvbiB0aGUgdGFyZ2V0IGZvciBldmVyeSBldmVudCB0eXBlLlxyXG5cdFx0ZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiggZXZlbnROYW1lICl7XHJcblx0XHRcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIG1ldGhvZCwgZmFsc2UpO1xyXG5cdFx0XHRtZXRob2RzLnB1c2goW2V2ZW50TmFtZSwgbWV0aG9kXSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gbWV0aG9kcztcclxuXHR9XHJcblxyXG5cdC8vIFByb3ZpZGUgYSBjbGVhbiBldmVudCB3aXRoIHN0YW5kYXJkaXplZCBvZmZzZXQgdmFsdWVzLlxyXG5cdGZ1bmN0aW9uIGZpeEV2ZW50ICggZSwgcGFnZU9mZnNldCApIHtcclxuXHJcblx0XHQvLyBQcmV2ZW50IHNjcm9sbGluZyBhbmQgcGFubmluZyBvbiB0b3VjaCBldmVudHMsIHdoaWxlXHJcblx0XHQvLyBhdHRlbXB0aW5nIHRvIHNsaWRlLiBUaGUgdGFwIGV2ZW50IGFsc28gZGVwZW5kcyBvbiB0aGlzLlxyXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdC8vIEZpbHRlciB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgdGhlIHR5cGUsIHdoaWNoIGNhbiBiZVxyXG5cdFx0Ly8gdG91Y2gsIG1vdXNlIG9yIHBvaW50ZXIuIE9mZnNldCBjaGFuZ2VzIG5lZWQgdG8gYmVcclxuXHRcdC8vIG1hZGUgb24gYW4gZXZlbnQgc3BlY2lmaWMgYmFzaXMuXHJcblx0XHR2YXIgdG91Y2ggPSBlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMDtcclxuXHRcdHZhciBtb3VzZSA9IGUudHlwZS5pbmRleE9mKCdtb3VzZScpID09PSAwO1xyXG5cdFx0dmFyIHBvaW50ZXIgPSBlLnR5cGUuaW5kZXhPZigncG9pbnRlcicpID09PSAwO1xyXG5cdFx0dmFyIHg7XHJcblx0XHR2YXIgeTtcclxuXHJcblx0XHQvLyBJRTEwIGltcGxlbWVudGVkIHBvaW50ZXIgZXZlbnRzIHdpdGggYSBwcmVmaXg7XHJcblx0XHRpZiAoIGUudHlwZS5pbmRleE9mKCdNU1BvaW50ZXInKSA9PT0gMCApIHtcclxuXHRcdFx0cG9pbnRlciA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0b3VjaCApIHtcclxuXHJcblx0XHRcdC8vIEZpeCBidWcgd2hlbiB1c2VyIHRvdWNoZXMgd2l0aCB0d28gb3IgbW9yZSBmaW5nZXJzIG9uIG1vYmlsZSBkZXZpY2VzLlxyXG5cdFx0XHQvLyBJdCdzIHVzZWZ1bCB3aGVuIHlvdSBoYXZlIHR3byBvciBtb3JlIHNsaWRlcnMgb24gb25lIHBhZ2UsXHJcblx0XHRcdC8vIHRoYXQgY2FuIGJlIHRvdWNoZWQgc2ltdWx0YW5lb3VzbHkuXHJcblx0XHRcdC8vICM2NDksICM2NjMsICM2NjhcclxuXHRcdFx0aWYgKCBlLnRvdWNoZXMubGVuZ3RoID4gMSApIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIG5vVWlTbGlkZXIgc3VwcG9ydHMgb25lIG1vdmVtZW50IGF0IGEgdGltZSxcclxuXHRcdFx0Ly8gc28gd2UgY2FuIHNlbGVjdCB0aGUgZmlyc3QgJ2NoYW5nZWRUb3VjaCcuXHJcblx0XHRcdHggPSBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xyXG5cdFx0XHR5ID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcclxuXHRcdH1cclxuXHJcblx0XHRwYWdlT2Zmc2V0ID0gcGFnZU9mZnNldCB8fCBnZXRQYWdlT2Zmc2V0KCk7XHJcblxyXG5cdFx0aWYgKCBtb3VzZSB8fCBwb2ludGVyICkge1xyXG5cdFx0XHR4ID0gZS5jbGllbnRYICsgcGFnZU9mZnNldC54O1xyXG5cdFx0XHR5ID0gZS5jbGllbnRZICsgcGFnZU9mZnNldC55O1xyXG5cdFx0fVxyXG5cclxuXHRcdGUucGFnZU9mZnNldCA9IHBhZ2VPZmZzZXQ7XHJcblx0XHRlLnBvaW50cyA9IFt4LCB5XTtcclxuXHRcdGUuY3Vyc29yID0gbW91c2UgfHwgcG9pbnRlcjsgLy8gRml4ICM0MzVcclxuXHJcblx0XHRyZXR1cm4gZTtcclxuXHR9XHJcblxyXG5cdC8vIFRyYW5zbGF0ZSBhIGNvb3JkaW5hdGUgaW4gdGhlIGRvY3VtZW50IHRvIGEgcGVyY2VudGFnZSBvbiB0aGUgc2xpZGVyXHJcblx0ZnVuY3Rpb24gY2FsY1BvaW50VG9QZXJjZW50YWdlICggY2FsY1BvaW50ICkge1xyXG5cdFx0dmFyIGxvY2F0aW9uID0gY2FsY1BvaW50IC0gb2Zmc2V0KHNjb3BlX0Jhc2UsIG9wdGlvbnMub3J0KTtcclxuXHRcdHZhciBwcm9wb3NhbCA9ICggbG9jYXRpb24gKiAxMDAgKSAvIGJhc2VTaXplKCk7XHJcblx0XHRyZXR1cm4gb3B0aW9ucy5kaXIgPyAxMDAgLSBwcm9wb3NhbCA6IHByb3Bvc2FsO1xyXG5cdH1cclxuXHJcblx0Ly8gRmluZCBoYW5kbGUgY2xvc2VzdCB0byBhIGNlcnRhaW4gcGVyY2VudGFnZSBvbiB0aGUgc2xpZGVyXHJcblx0ZnVuY3Rpb24gZ2V0Q2xvc2VzdEhhbmRsZSAoIHByb3Bvc2FsICkge1xyXG5cclxuXHRcdHZhciBjbG9zZXN0ID0gMTAwO1xyXG5cdFx0dmFyIGhhbmRsZU51bWJlciA9IGZhbHNlO1xyXG5cclxuXHRcdHNjb3BlX0hhbmRsZXMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGUsIGluZGV4KXtcclxuXHJcblx0XHRcdC8vIERpc2FibGVkIGhhbmRsZXMgYXJlIGlnbm9yZWRcclxuXHRcdFx0aWYgKCBoYW5kbGUuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpICkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHBvcyA9IE1hdGguYWJzKHNjb3BlX0xvY2F0aW9uc1tpbmRleF0gLSBwcm9wb3NhbCk7XHJcblxyXG5cdFx0XHRpZiAoIHBvcyA8IGNsb3Nlc3QgKSB7XHJcblx0XHRcdFx0aGFuZGxlTnVtYmVyID0gaW5kZXg7XHJcblx0XHRcdFx0Y2xvc2VzdCA9IHBvcztcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGhhbmRsZU51bWJlcjtcclxuXHR9XHJcblxyXG5cdC8vIE1vdmVzIGhhbmRsZShzKSBieSBhIHBlcmNlbnRhZ2VcclxuXHQvLyAoYm9vbCwgJSB0byBtb3ZlLCBbJSB3aGVyZSBoYW5kbGUgc3RhcnRlZCwgLi4uXSwgW2luZGV4IGluIHNjb3BlX0hhbmRsZXMsIC4uLl0pXHJcblx0ZnVuY3Rpb24gbW92ZUhhbmRsZXMgKCB1cHdhcmQsIHByb3Bvc2FsLCBsb2NhdGlvbnMsIGhhbmRsZU51bWJlcnMgKSB7XHJcblxyXG5cdFx0dmFyIHByb3Bvc2FscyA9IGxvY2F0aW9ucy5zbGljZSgpO1xyXG5cclxuXHRcdHZhciBiID0gWyF1cHdhcmQsIHVwd2FyZF07XHJcblx0XHR2YXIgZiA9IFt1cHdhcmQsICF1cHdhcmRdO1xyXG5cclxuXHRcdC8vIENvcHkgaGFuZGxlTnVtYmVycyBzbyB3ZSBkb24ndCBjaGFuZ2UgdGhlIGRhdGFzZXRcclxuXHRcdGhhbmRsZU51bWJlcnMgPSBoYW5kbGVOdW1iZXJzLnNsaWNlKCk7XHJcblxyXG5cdFx0Ly8gQ2hlY2sgdG8gc2VlIHdoaWNoIGhhbmRsZSBpcyAnbGVhZGluZycuXHJcblx0XHQvLyBJZiB0aGF0IG9uZSBjYW4ndCBtb3ZlIHRoZSBzZWNvbmQgY2FuJ3QgZWl0aGVyLlxyXG5cdFx0aWYgKCB1cHdhcmQgKSB7XHJcblx0XHRcdGhhbmRsZU51bWJlcnMucmV2ZXJzZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFN0ZXAgMTogZ2V0IHRoZSBtYXhpbXVtIHBlcmNlbnRhZ2UgdGhhdCBhbnkgb2YgdGhlIGhhbmRsZXMgY2FuIG1vdmVcclxuXHRcdGlmICggaGFuZGxlTnVtYmVycy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0aGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlciwgbykge1xyXG5cclxuXHRcdFx0XHR2YXIgdG8gPSBjaGVja0hhbmRsZVBvc2l0aW9uKHByb3Bvc2FscywgaGFuZGxlTnVtYmVyLCBwcm9wb3NhbHNbaGFuZGxlTnVtYmVyXSArIHByb3Bvc2FsLCBiW29dLCBmW29dKTtcclxuXHJcblx0XHRcdFx0Ly8gU3RvcCBpZiBvbmUgb2YgdGhlIGhhbmRsZXMgY2FuJ3QgbW92ZS5cclxuXHRcdFx0XHRpZiAoIHRvID09PSBmYWxzZSApIHtcclxuXHRcdFx0XHRcdHByb3Bvc2FsID0gMDtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cHJvcG9zYWwgPSB0byAtIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdO1xyXG5cdFx0XHRcdFx0cHJvcG9zYWxzW2hhbmRsZU51bWJlcl0gPSB0bztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIElmIHVzaW5nIG9uZSBoYW5kbGUsIGNoZWNrIGJhY2t3YXJkIEFORCBmb3J3YXJkXHJcblx0XHRlbHNlIHtcclxuXHRcdFx0YiA9IGYgPSBbdHJ1ZV07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN0YXRlID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gU3RlcCAyOiBUcnkgdG8gc2V0IHRoZSBoYW5kbGVzIHdpdGggdGhlIGZvdW5kIHBlcmNlbnRhZ2VcclxuXHRcdGhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIsIG8pIHtcclxuXHRcdFx0c3RhdGUgPSBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBsb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSArIHByb3Bvc2FsLCBiW29dLCBmW29dKSB8fCBzdGF0ZTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIFN0ZXAgMzogSWYgYSBoYW5kbGUgbW92ZWQsIGZpcmUgZXZlbnRzXHJcblx0XHRpZiAoIHN0YXRlICkge1xyXG5cdFx0XHRoYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlTnVtYmVyKXtcclxuXHRcdFx0XHRmaXJlRXZlbnQoJ3VwZGF0ZScsIGhhbmRsZU51bWJlcik7XHJcblx0XHRcdFx0ZmlyZUV2ZW50KCdzbGlkZScsIGhhbmRsZU51bWJlcik7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gRXh0ZXJuYWwgZXZlbnQgaGFuZGxpbmdcclxuXHRmdW5jdGlvbiBmaXJlRXZlbnQgKCBldmVudE5hbWUsIGhhbmRsZU51bWJlciwgdGFwICkge1xyXG5cclxuXHRcdE9iamVjdC5rZXlzKHNjb3BlX0V2ZW50cykuZm9yRWFjaChmdW5jdGlvbiggdGFyZ2V0RXZlbnQgKSB7XHJcblxyXG5cdFx0XHR2YXIgZXZlbnRUeXBlID0gdGFyZ2V0RXZlbnQuc3BsaXQoJy4nKVswXTtcclxuXHJcblx0XHRcdGlmICggZXZlbnROYW1lID09PSBldmVudFR5cGUgKSB7XHJcblx0XHRcdFx0c2NvcGVfRXZlbnRzW3RhcmdldEV2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKFxyXG5cdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNsaWRlciBwdWJsaWMgQVBJIGFzIHRoZSBzY29wZSAoJ3RoaXMnKVxyXG5cdFx0XHRcdFx0XHRzY29wZV9TZWxmLFxyXG5cdFx0XHRcdFx0XHQvLyBSZXR1cm4gdmFsdWVzIGFzIGFycmF5LCBzbyBhcmdfMVthcmdfMl0gaXMgYWx3YXlzIHZhbGlkLlxyXG5cdFx0XHRcdFx0XHRzY29wZV9WYWx1ZXMubWFwKG9wdGlvbnMuZm9ybWF0LnRvKSxcclxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGluZGV4LCAwIG9yIDFcclxuXHRcdFx0XHRcdFx0aGFuZGxlTnVtYmVyLFxyXG5cdFx0XHRcdFx0XHQvLyBVbmZvcm1hdHRlZCBzbGlkZXIgdmFsdWVzXHJcblx0XHRcdFx0XHRcdHNjb3BlX1ZhbHVlcy5zbGljZSgpLFxyXG5cdFx0XHRcdFx0XHQvLyBFdmVudCBpcyBmaXJlZCBieSB0YXAsIHRydWUgb3IgZmFsc2VcclxuXHRcdFx0XHRcdFx0dGFwIHx8IGZhbHNlLFxyXG5cdFx0XHRcdFx0XHQvLyBMZWZ0IG9mZnNldCBvZiB0aGUgaGFuZGxlLCBpbiByZWxhdGlvbiB0byB0aGUgc2xpZGVyXHJcblx0XHRcdFx0XHRcdHNjb3BlX0xvY2F0aW9ucy5zbGljZSgpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cclxuXHQvLyBGaXJlICdlbmQnIHdoZW4gYSBtb3VzZSBvciBwZW4gbGVhdmVzIHRoZSBkb2N1bWVudC5cclxuXHRmdW5jdGlvbiBkb2N1bWVudExlYXZlICggZXZlbnQsIGRhdGEgKSB7XHJcblx0XHRpZiAoIGV2ZW50LnR5cGUgPT09IFwibW91c2VvdXRcIiAmJiBldmVudC50YXJnZXQubm9kZU5hbWUgPT09IFwiSFRNTFwiICYmIGV2ZW50LnJlbGF0ZWRUYXJnZXQgPT09IG51bGwgKXtcclxuXHRcdFx0ZXZlbnRFbmQgKGV2ZW50LCBkYXRhKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEhhbmRsZSBtb3ZlbWVudCBvbiBkb2N1bWVudCBmb3IgaGFuZGxlIGFuZCByYW5nZSBkcmFnLlxyXG5cdGZ1bmN0aW9uIGV2ZW50TW92ZSAoIGV2ZW50LCBkYXRhICkge1xyXG5cclxuXHRcdC8vIEZpeCAjNDk4XHJcblx0XHQvLyBDaGVjayB2YWx1ZSBvZiAuYnV0dG9ucyBpbiAnc3RhcnQnIHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluIElFMTAgbW9iaWxlIChkYXRhLmJ1dHRvbnNQcm9wZXJ0eSkuXHJcblx0XHQvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzkyNzAwNS9tb2JpbGUtaWUxMC13aW5kb3dzLXBob25lLWJ1dHRvbnMtcHJvcGVydHktb2YtcG9pbnRlcm1vdmUtZXZlbnQtYWx3YXlzLXplcm9cclxuXHRcdC8vIElFOSBoYXMgLmJ1dHRvbnMgYW5kIC53aGljaCB6ZXJvIG9uIG1vdXNlbW92ZS5cclxuXHRcdC8vIEZpcmVmb3ggYnJlYWtzIHRoZSBzcGVjIE1ETiBkZWZpbmVzLlxyXG5cdFx0aWYgKCBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKFwiTVNJRSA5XCIpID09PSAtMSAmJiBldmVudC5idXR0b25zID09PSAwICYmIGRhdGEuYnV0dG9uc1Byb3BlcnR5ICE9PSAwICkge1xyXG5cdFx0XHRyZXR1cm4gZXZlbnRFbmQoZXZlbnQsIGRhdGEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENoZWNrIGlmIHdlIGFyZSBtb3ZpbmcgdXAgb3IgZG93blxyXG5cdFx0dmFyIG1vdmVtZW50ID0gKG9wdGlvbnMuZGlyID8gLTEgOiAxKSAqIChldmVudC5jYWxjUG9pbnQgLSBkYXRhLnN0YXJ0Q2FsY1BvaW50KTtcclxuXHJcblx0XHQvLyBDb252ZXJ0IHRoZSBtb3ZlbWVudCBpbnRvIGEgcGVyY2VudGFnZSBvZiB0aGUgc2xpZGVyIHdpZHRoL2hlaWdodFxyXG5cdFx0dmFyIHByb3Bvc2FsID0gKG1vdmVtZW50ICogMTAwKSAvIGRhdGEuYmFzZVNpemU7XHJcblxyXG5cdFx0bW92ZUhhbmRsZXMobW92ZW1lbnQgPiAwLCBwcm9wb3NhbCwgZGF0YS5sb2NhdGlvbnMsIGRhdGEuaGFuZGxlTnVtYmVycyk7XHJcblx0fVxyXG5cclxuXHQvLyBVbmJpbmQgbW92ZSBldmVudHMgb24gZG9jdW1lbnQsIGNhbGwgY2FsbGJhY2tzLlxyXG5cdGZ1bmN0aW9uIGV2ZW50RW5kICggZXZlbnQsIGRhdGEgKSB7XHJcblxyXG5cdFx0Ly8gVGhlIGhhbmRsZSBpcyBubyBsb25nZXIgYWN0aXZlLCBzbyByZW1vdmUgdGhlIGNsYXNzLlxyXG5cdFx0aWYgKCBzY29wZV9BY3RpdmVIYW5kbGUgKSB7XHJcblx0XHRcdHJlbW92ZUNsYXNzKHNjb3BlX0FjdGl2ZUhhbmRsZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmFjdGl2ZSk7XHJcblx0XHRcdHNjb3BlX0FjdGl2ZUhhbmRsZSA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlbW92ZSBjdXJzb3Igc3R5bGVzIGFuZCB0ZXh0LXNlbGVjdGlvbiBldmVudHMgYm91bmQgdG8gdGhlIGJvZHkuXHJcblx0XHRpZiAoIGV2ZW50LmN1cnNvciApIHtcclxuXHRcdFx0ZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnJztcclxuXHRcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGRvY3VtZW50LmJvZHkubm9VaUxpc3RlbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBVbmJpbmQgdGhlIG1vdmUgYW5kIGVuZCBldmVudHMsIHdoaWNoIGFyZSBhZGRlZCBvbiAnc3RhcnQnLlxyXG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm5vVWlMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiggYyApIHtcclxuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoY1swXSwgY1sxXSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBSZW1vdmUgZHJhZ2dpbmcgY2xhc3MuXHJcblx0XHRyZW1vdmVDbGFzcyhzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5kcmFnKTtcclxuXHJcblx0XHRzZXRaaW5kZXgoKTtcclxuXHJcblx0XHRkYXRhLmhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpe1xyXG5cdFx0XHRmaXJlRXZlbnQoJ3NldCcsIGhhbmRsZU51bWJlcik7XHJcblx0XHRcdGZpcmVFdmVudCgnY2hhbmdlJywgaGFuZGxlTnVtYmVyKTtcclxuXHRcdFx0ZmlyZUV2ZW50KCdlbmQnLCBoYW5kbGVOdW1iZXIpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvLyBCaW5kIG1vdmUgZXZlbnRzIG9uIGRvY3VtZW50LlxyXG5cdGZ1bmN0aW9uIGV2ZW50U3RhcnQgKCBldmVudCwgZGF0YSApIHtcclxuXHJcblx0XHRpZiAoIGRhdGEuaGFuZGxlTnVtYmVycy5sZW5ndGggPT09IDEgKSB7XHJcblxyXG5cdFx0XHR2YXIgaGFuZGxlID0gc2NvcGVfSGFuZGxlc1tkYXRhLmhhbmRsZU51bWJlcnNbMF1dO1xyXG5cclxuXHRcdFx0Ly8gSWdub3JlICdkaXNhYmxlZCcgaGFuZGxlc1xyXG5cdFx0XHRpZiAoIGhhbmRsZS5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBNYXJrIHRoZSBoYW5kbGUgYXMgJ2FjdGl2ZScgc28gaXQgY2FuIGJlIHN0eWxlZC5cclxuXHRcdFx0c2NvcGVfQWN0aXZlSGFuZGxlID0gaGFuZGxlLmNoaWxkcmVuWzBdO1xyXG5cdFx0XHRhZGRDbGFzcyhzY29wZV9BY3RpdmVIYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5hY3RpdmUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZpeCAjNTUxLCB3aGVyZSBhIGhhbmRsZSBnZXRzIHNlbGVjdGVkIGluc3RlYWQgb2YgZHJhZ2dlZC5cclxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0Ly8gQSBkcmFnIHNob3VsZCBuZXZlciBwcm9wYWdhdGUgdXAgdG8gdGhlICd0YXAnIGV2ZW50LlxyXG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG5cdFx0Ly8gQXR0YWNoIHRoZSBtb3ZlIGFuZCBlbmQgZXZlbnRzLlxyXG5cdFx0dmFyIG1vdmVFdmVudCA9IGF0dGFjaEV2ZW50KGFjdGlvbnMubW92ZSwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBldmVudE1vdmUsIHtcclxuXHRcdFx0c3RhcnRDYWxjUG9pbnQ6IGV2ZW50LmNhbGNQb2ludCxcclxuXHRcdFx0YmFzZVNpemU6IGJhc2VTaXplKCksXHJcblx0XHRcdHBhZ2VPZmZzZXQ6IGV2ZW50LnBhZ2VPZmZzZXQsXHJcblx0XHRcdGhhbmRsZU51bWJlcnM6IGRhdGEuaGFuZGxlTnVtYmVycyxcclxuXHRcdFx0YnV0dG9uc1Byb3BlcnR5OiBldmVudC5idXR0b25zLFxyXG5cdFx0XHRsb2NhdGlvbnM6IHNjb3BlX0xvY2F0aW9ucy5zbGljZSgpXHJcblx0XHR9KTtcclxuXHJcblx0XHR2YXIgZW5kRXZlbnQgPSBhdHRhY2hFdmVudChhY3Rpb25zLmVuZCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBldmVudEVuZCwge1xyXG5cdFx0XHRoYW5kbGVOdW1iZXJzOiBkYXRhLmhhbmRsZU51bWJlcnNcclxuXHRcdH0pO1xyXG5cclxuXHRcdHZhciBvdXRFdmVudCA9IGF0dGFjaEV2ZW50KFwibW91c2VvdXRcIiwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudExlYXZlLCB7XHJcblx0XHRcdGhhbmRsZU51bWJlcnM6IGRhdGEuaGFuZGxlTnVtYmVyc1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm5vVWlMaXN0ZW5lcnMgPSBtb3ZlRXZlbnQuY29uY2F0KGVuZEV2ZW50LCBvdXRFdmVudCk7XHJcblxyXG5cdFx0Ly8gVGV4dCBzZWxlY3Rpb24gaXNuJ3QgYW4gaXNzdWUgb24gdG91Y2ggZGV2aWNlcyxcclxuXHRcdC8vIHNvIGFkZGluZyBjdXJzb3Igc3R5bGVzIGNhbiBiZSBza2lwcGVkLlxyXG5cdFx0aWYgKCBldmVudC5jdXJzb3IgKSB7XHJcblxyXG5cdFx0XHQvLyBQcmV2ZW50IHRoZSAnSScgY3Vyc29yIGFuZCBleHRlbmQgdGhlIHJhbmdlLWRyYWcgY3Vyc29yLlxyXG5cdFx0XHRkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9IGdldENvbXB1dGVkU3R5bGUoZXZlbnQudGFyZ2V0KS5jdXJzb3I7XHJcblxyXG5cdFx0XHQvLyBNYXJrIHRoZSB0YXJnZXQgd2l0aCBhIGRyYWdnaW5nIHN0YXRlLlxyXG5cdFx0XHRpZiAoIHNjb3BlX0hhbmRsZXMubGVuZ3RoID4gMSApIHtcclxuXHRcdFx0XHRhZGRDbGFzcyhzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5kcmFnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGYgPSBmdW5jdGlvbigpe1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGRvY3VtZW50LmJvZHkubm9VaUxpc3RlbmVyID0gZjtcclxuXHJcblx0XHRcdC8vIFByZXZlbnQgdGV4dCBzZWxlY3Rpb24gd2hlbiBkcmFnZ2luZyB0aGUgaGFuZGxlcy5cclxuXHRcdFx0ZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGYsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHRkYXRhLmhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpe1xyXG5cdFx0XHRmaXJlRXZlbnQoJ3N0YXJ0JywgaGFuZGxlTnVtYmVyKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Ly8gTW92ZSBjbG9zZXN0IGhhbmRsZSB0byB0YXBwZWQgbG9jYXRpb24uXHJcblx0ZnVuY3Rpb24gZXZlbnRUYXAgKCBldmVudCApIHtcclxuXHJcblx0XHQvLyBUaGUgdGFwIGV2ZW50IHNob3VsZG4ndCBwcm9wYWdhdGUgdXBcclxuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuXHRcdHZhciBwcm9wb3NhbCA9IGNhbGNQb2ludFRvUGVyY2VudGFnZShldmVudC5jYWxjUG9pbnQpO1xyXG5cdFx0dmFyIGhhbmRsZU51bWJlciA9IGdldENsb3Nlc3RIYW5kbGUocHJvcG9zYWwpO1xyXG5cclxuXHRcdC8vIFRhY2tsZSB0aGUgY2FzZSB0aGF0IGFsbCBoYW5kbGVzIGFyZSAnZGlzYWJsZWQnLlxyXG5cdFx0aWYgKCBoYW5kbGVOdW1iZXIgPT09IGZhbHNlICkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmxhZyB0aGUgc2xpZGVyIGFzIGl0IGlzIG5vdyBpbiBhIHRyYW5zaXRpb25hbCBzdGF0ZS5cclxuXHRcdC8vIFRyYW5zaXRpb24gdGFrZXMgYSBjb25maWd1cmFibGUgYW1vdW50IG9mIG1zIChkZWZhdWx0IDMwMCkuIFJlLWVuYWJsZSB0aGUgc2xpZGVyIGFmdGVyIHRoYXQuXHJcblx0XHRpZiAoICFvcHRpb25zLmV2ZW50cy5zbmFwICkge1xyXG5cdFx0XHRhZGRDbGFzc0ZvcihzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXAsIG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHByb3Bvc2FsLCB0cnVlLCB0cnVlKTtcclxuXHJcblx0XHRzZXRaaW5kZXgoKTtcclxuXHJcblx0XHRmaXJlRXZlbnQoJ3NsaWRlJywgaGFuZGxlTnVtYmVyLCB0cnVlKTtcclxuXHRcdGZpcmVFdmVudCgnc2V0JywgaGFuZGxlTnVtYmVyLCB0cnVlKTtcclxuXHRcdGZpcmVFdmVudCgnY2hhbmdlJywgaGFuZGxlTnVtYmVyLCB0cnVlKTtcclxuXHRcdGZpcmVFdmVudCgndXBkYXRlJywgaGFuZGxlTnVtYmVyLCB0cnVlKTtcclxuXHJcblx0XHRpZiAoIG9wdGlvbnMuZXZlbnRzLnNuYXAgKSB7XHJcblx0XHRcdGV2ZW50U3RhcnQoZXZlbnQsIHsgaGFuZGxlTnVtYmVyczogW2hhbmRsZU51bWJlcl0gfSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBGaXJlcyBhICdob3ZlcicgZXZlbnQgZm9yIGEgaG92ZXJlZCBtb3VzZS9wZW4gcG9zaXRpb24uXHJcblx0ZnVuY3Rpb24gZXZlbnRIb3ZlciAoIGV2ZW50ICkge1xyXG5cclxuXHRcdHZhciBwcm9wb3NhbCA9IGNhbGNQb2ludFRvUGVyY2VudGFnZShldmVudC5jYWxjUG9pbnQpO1xyXG5cclxuXHRcdHZhciB0byA9IHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAocHJvcG9zYWwpO1xyXG5cdFx0dmFyIHZhbHVlID0gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHRvKTtcclxuXHJcblx0XHRPYmplY3Qua2V5cyhzY29wZV9FdmVudHMpLmZvckVhY2goZnVuY3Rpb24oIHRhcmdldEV2ZW50ICkge1xyXG5cdFx0XHRpZiAoICdob3ZlcicgPT09IHRhcmdldEV2ZW50LnNwbGl0KCcuJylbMF0gKSB7XHJcblx0XHRcdFx0c2NvcGVfRXZlbnRzW3RhcmdldEV2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoIHNjb3BlX1NlbGYsIHZhbHVlICk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Ly8gQXR0YWNoIGV2ZW50cyB0byBzZXZlcmFsIHNsaWRlciBwYXJ0cy5cclxuXHRmdW5jdGlvbiBiaW5kU2xpZGVyRXZlbnRzICggYmVoYXZpb3VyICkge1xyXG5cclxuXHRcdC8vIEF0dGFjaCB0aGUgc3RhbmRhcmQgZHJhZyBldmVudCB0byB0aGUgaGFuZGxlcy5cclxuXHRcdGlmICggIWJlaGF2aW91ci5maXhlZCApIHtcclxuXHJcblx0XHRcdHNjb3BlX0hhbmRsZXMuZm9yRWFjaChmdW5jdGlvbiggaGFuZGxlLCBpbmRleCApe1xyXG5cclxuXHRcdFx0XHQvLyBUaGVzZSBldmVudHMgYXJlIG9ubHkgYm91bmQgdG8gdGhlIHZpc3VhbCBoYW5kbGVcclxuXHRcdFx0XHQvLyBlbGVtZW50LCBub3QgdGhlICdyZWFsJyBvcmlnaW4gZWxlbWVudC5cclxuXHRcdFx0XHRhdHRhY2hFdmVudCAoIGFjdGlvbnMuc3RhcnQsIGhhbmRsZS5jaGlsZHJlblswXSwgZXZlbnRTdGFydCwge1xyXG5cdFx0XHRcdFx0aGFuZGxlTnVtYmVyczogW2luZGV4XVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBBdHRhY2ggdGhlIHRhcCBldmVudCB0byB0aGUgc2xpZGVyIGJhc2UuXHJcblx0XHRpZiAoIGJlaGF2aW91ci50YXAgKSB7XHJcblx0XHRcdGF0dGFjaEV2ZW50IChhY3Rpb25zLnN0YXJ0LCBzY29wZV9CYXNlLCBldmVudFRhcCwge30pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZpcmUgaG92ZXIgZXZlbnRzXHJcblx0XHRpZiAoIGJlaGF2aW91ci5ob3ZlciApIHtcclxuXHRcdFx0YXR0YWNoRXZlbnQgKGFjdGlvbnMubW92ZSwgc2NvcGVfQmFzZSwgZXZlbnRIb3ZlciwgeyBob3ZlcjogdHJ1ZSB9KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBNYWtlIHRoZSByYW5nZSBkcmFnZ2FibGUuXHJcblx0XHRpZiAoIGJlaGF2aW91ci5kcmFnICl7XHJcblxyXG5cdFx0XHRzY29wZV9Db25uZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKCBjb25uZWN0LCBpbmRleCApe1xyXG5cclxuXHRcdFx0XHRpZiAoIGNvbm5lY3QgPT09IGZhbHNlIHx8IGluZGV4ID09PSAwIHx8IGluZGV4ID09PSBzY29wZV9Db25uZWN0cy5sZW5ndGggLSAxICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGhhbmRsZUJlZm9yZSA9IHNjb3BlX0hhbmRsZXNbaW5kZXggLSAxXTtcclxuXHRcdFx0XHR2YXIgaGFuZGxlQWZ0ZXIgPSBzY29wZV9IYW5kbGVzW2luZGV4XTtcclxuXHRcdFx0XHR2YXIgZXZlbnRIb2xkZXJzID0gW2Nvbm5lY3RdO1xyXG5cclxuXHRcdFx0XHRhZGRDbGFzcyhjb25uZWN0LCBvcHRpb25zLmNzc0NsYXNzZXMuZHJhZ2dhYmxlKTtcclxuXHJcblx0XHRcdFx0Ly8gV2hlbiB0aGUgcmFuZ2UgaXMgZml4ZWQsIHRoZSBlbnRpcmUgcmFuZ2UgY2FuXHJcblx0XHRcdFx0Ly8gYmUgZHJhZ2dlZCBieSB0aGUgaGFuZGxlcy4gVGhlIGhhbmRsZSBpbiB0aGUgZmlyc3RcclxuXHRcdFx0XHQvLyBvcmlnaW4gd2lsbCBwcm9wYWdhdGUgdGhlIHN0YXJ0IGV2ZW50IHVwd2FyZCxcclxuXHRcdFx0XHQvLyBidXQgaXQgbmVlZHMgdG8gYmUgYm91bmQgbWFudWFsbHkgb24gdGhlIG90aGVyLlxyXG5cdFx0XHRcdGlmICggYmVoYXZpb3VyLmZpeGVkICkge1xyXG5cdFx0XHRcdFx0ZXZlbnRIb2xkZXJzLnB1c2goaGFuZGxlQmVmb3JlLmNoaWxkcmVuWzBdKTtcclxuXHRcdFx0XHRcdGV2ZW50SG9sZGVycy5wdXNoKGhhbmRsZUFmdGVyLmNoaWxkcmVuWzBdKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGV2ZW50SG9sZGVycy5mb3JFYWNoKGZ1bmN0aW9uKCBldmVudEhvbGRlciApIHtcclxuXHRcdFx0XHRcdGF0dGFjaEV2ZW50ICggYWN0aW9ucy5zdGFydCwgZXZlbnRIb2xkZXIsIGV2ZW50U3RhcnQsIHtcclxuXHRcdFx0XHRcdFx0aGFuZGxlczogW2hhbmRsZUJlZm9yZSwgaGFuZGxlQWZ0ZXJdLFxyXG5cdFx0XHRcdFx0XHRoYW5kbGVOdW1iZXJzOiBbaW5kZXggLSAxLCBpbmRleF1cclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHQvLyBTcGxpdCBvdXQgdGhlIGhhbmRsZSBwb3NpdGlvbmluZyBsb2dpYyBzbyB0aGUgTW92ZSBldmVudCBjYW4gdXNlIGl0LCB0b29cclxuXHRmdW5jdGlvbiBjaGVja0hhbmRsZVBvc2l0aW9uICggcmVmZXJlbmNlLCBoYW5kbGVOdW1iZXIsIHRvLCBsb29rQmFja3dhcmQsIGxvb2tGb3J3YXJkICkge1xyXG5cclxuXHRcdC8vIEZvciBzbGlkZXJzIHdpdGggbXVsdGlwbGUgaGFuZGxlcywgbGltaXQgbW92ZW1lbnQgdG8gdGhlIG90aGVyIGhhbmRsZS5cclxuXHRcdC8vIEFwcGx5IHRoZSBtYXJnaW4gb3B0aW9uIGJ5IGFkZGluZyBpdCB0byB0aGUgaGFuZGxlIHBvc2l0aW9ucy5cclxuXHRcdGlmICggc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0aWYgKCBsb29rQmFja3dhcmQgJiYgaGFuZGxlTnVtYmVyID4gMCApIHtcclxuXHRcdFx0XHR0byA9IE1hdGgubWF4KHRvLCByZWZlcmVuY2VbaGFuZGxlTnVtYmVyIC0gMV0gKyBvcHRpb25zLm1hcmdpbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbG9va0ZvcndhcmQgJiYgaGFuZGxlTnVtYmVyIDwgc2NvcGVfSGFuZGxlcy5sZW5ndGggLSAxICkge1xyXG5cdFx0XHRcdHRvID0gTWF0aC5taW4odG8sIHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgKyAxXSAtIG9wdGlvbnMubWFyZ2luKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRoZSBsaW1pdCBvcHRpb24gaGFzIHRoZSBvcHBvc2l0ZSBlZmZlY3QsIGxpbWl0aW5nIGhhbmRsZXMgdG8gYVxyXG5cdFx0Ly8gbWF4aW11bSBkaXN0YW5jZSBmcm9tIGFub3RoZXIuIExpbWl0IG11c3QgYmUgPiAwLCBhcyBvdGhlcndpc2VcclxuXHRcdC8vIGhhbmRsZXMgd291bGQgYmUgdW5tb3ZlYWJsZS5cclxuXHRcdGlmICggc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxICYmIG9wdGlvbnMubGltaXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGxvb2tCYWNrd2FyZCAmJiBoYW5kbGVOdW1iZXIgPiAwICkge1xyXG5cdFx0XHRcdHRvID0gTWF0aC5taW4odG8sIHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgLSAxXSArIG9wdGlvbnMubGltaXQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGxvb2tGb3J3YXJkICYmIGhhbmRsZU51bWJlciA8IHNjb3BlX0hhbmRsZXMubGVuZ3RoIC0gMSApIHtcclxuXHRcdFx0XHR0byA9IE1hdGgubWF4KHRvLCByZWZlcmVuY2VbaGFuZGxlTnVtYmVyICsgMV0gLSBvcHRpb25zLmxpbWl0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRoZSBwYWRkaW5nIG9wdGlvbiBrZWVwcyB0aGUgaGFuZGxlcyBhIGNlcnRhaW4gZGlzdGFuY2UgZnJvbSB0aGVcclxuXHRcdC8vIGVkZ2VzIG9mIHRoZSBzbGlkZXIuIFBhZGRpbmcgbXVzdCBiZSA+IDAuXHJcblx0XHRpZiAoIG9wdGlvbnMucGFkZGluZyApIHtcclxuXHJcblx0XHRcdGlmICggaGFuZGxlTnVtYmVyID09PSAwICkge1xyXG5cdFx0XHRcdHRvID0gTWF0aC5tYXgodG8sIG9wdGlvbnMucGFkZGluZyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaGFuZGxlTnVtYmVyID09PSBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEgKSB7XHJcblx0XHRcdFx0dG8gPSBNYXRoLm1pbih0bywgMTAwIC0gb3B0aW9ucy5wYWRkaW5nKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRvID0gc2NvcGVfU3BlY3RydW0uZ2V0U3RlcCh0byk7XHJcblxyXG5cdFx0Ly8gTGltaXQgcGVyY2VudGFnZSB0byB0aGUgMCAtIDEwMCByYW5nZVxyXG5cdFx0dG8gPSBsaW1pdCh0byk7XHJcblxyXG5cdFx0Ly8gUmV0dXJuIGZhbHNlIGlmIGhhbmRsZSBjYW4ndCBtb3ZlXHJcblx0XHRpZiAoIHRvID09PSByZWZlcmVuY2VbaGFuZGxlTnVtYmVyXSApIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0bztcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRvUGN0ICggcGN0ICkge1xyXG5cdFx0cmV0dXJuIHBjdCArICclJztcclxuXHR9XHJcblxyXG5cdC8vIFVwZGF0ZXMgc2NvcGVfTG9jYXRpb25zIGFuZCBzY29wZV9WYWx1ZXMsIHVwZGF0ZXMgdmlzdWFsIHN0YXRlXHJcblx0ZnVuY3Rpb24gdXBkYXRlSGFuZGxlUG9zaXRpb24gKCBoYW5kbGVOdW1iZXIsIHRvICkge1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBsb2NhdGlvbnMuXHJcblx0XHRzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSA9IHRvO1xyXG5cclxuXHRcdC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIHRoZSBzbGlkZXIgc3RlcHBpbmcvcmFuZ2UuXHJcblx0XHRzY29wZV9WYWx1ZXNbaGFuZGxlTnVtYmVyXSA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyh0byk7XHJcblxyXG5cdFx0Ly8gQ2FsbGVkIHN5bmNocm9ub3VzbHkgb3Igb24gdGhlIG5leHQgYW5pbWF0aW9uRnJhbWVcclxuXHRcdHZhciBzdGF0ZVVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRzY29wZV9IYW5kbGVzW2hhbmRsZU51bWJlcl0uc3R5bGVbb3B0aW9ucy5zdHlsZV0gPSB0b1BjdCh0byk7XHJcblx0XHRcdHVwZGF0ZUNvbm5lY3QoaGFuZGxlTnVtYmVyKTtcclxuXHRcdFx0dXBkYXRlQ29ubmVjdChoYW5kbGVOdW1iZXIgKyAxKTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gU2V0IHRoZSBoYW5kbGUgdG8gdGhlIG5ldyBwb3NpdGlvbi5cclxuXHRcdC8vIFVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZm9yIGVmZmljaWVudCBwYWludGluZy5cclxuXHRcdC8vIE5vIHNpZ25pZmljYW50IGVmZmVjdCBpbiBDaHJvbWUsIEVkZ2Ugc2VlcyBkcmFtYXRpYyBwZXJmb3JtYWNlIGltcHJvdmVtZW50cy5cclxuXHRcdC8vIE9wdGlvbiB0byBkaXNhYmxlIGlzIHVzZWZ1bCBmb3IgdW5pdCB0ZXN0cywgYW5kIHNpbmdsZS1zdGVwIGRlYnVnZ2luZy5cclxuXHRcdGlmICggd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiBvcHRpb25zLnVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcclxuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShzdGF0ZVVwZGF0ZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdGF0ZVVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0WmluZGV4ICggKSB7XHJcblxyXG5cdFx0c2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcil7XHJcblx0XHRcdC8vIEhhbmRsZXMgYmVmb3JlIHRoZSBzbGlkZXIgbWlkZGxlIGFyZSBzdGFja2VkIGxhdGVyID0gaGlnaGVyLFxyXG5cdFx0XHQvLyBIYW5kbGVzIGFmdGVyIHRoZSBtaWRkbGUgbGF0ZXIgaXMgbG93ZXJcclxuXHRcdFx0Ly8gW1s3XSBbOF0gLi4uLi4uLi4uLiB8IC4uLi4uLi4uLi4gWzVdIFs0XVxyXG5cdFx0XHR2YXIgZGlyID0gKHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdID4gNTAgPyAtMSA6IDEpO1xyXG5cdFx0XHR2YXIgekluZGV4ID0gMyArIChzY29wZV9IYW5kbGVzLmxlbmd0aCArIChkaXIgKiBoYW5kbGVOdW1iZXIpKTtcclxuXHRcdFx0c2NvcGVfSGFuZGxlc1toYW5kbGVOdW1iZXJdLmNoaWxkTm9kZXNbMF0uc3R5bGUuekluZGV4ID0gekluZGV4O1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvLyBUZXN0IHN1Z2dlc3RlZCB2YWx1ZXMgYW5kIGFwcGx5IG1hcmdpbiwgc3RlcC5cclxuXHRmdW5jdGlvbiBzZXRIYW5kbGUgKCBoYW5kbGVOdW1iZXIsIHRvLCBsb29rQmFja3dhcmQsIGxvb2tGb3J3YXJkICkge1xyXG5cclxuXHRcdHRvID0gY2hlY2tIYW5kbGVQb3NpdGlvbihzY29wZV9Mb2NhdGlvbnMsIGhhbmRsZU51bWJlciwgdG8sIGxvb2tCYWNrd2FyZCwgbG9va0ZvcndhcmQpO1xyXG5cclxuXHRcdGlmICggdG8gPT09IGZhbHNlICkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0dXBkYXRlSGFuZGxlUG9zaXRpb24oaGFuZGxlTnVtYmVyLCB0byk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHQvLyBVcGRhdGVzIHN0eWxlIGF0dHJpYnV0ZSBmb3IgY29ubmVjdCBub2Rlc1xyXG5cdGZ1bmN0aW9uIHVwZGF0ZUNvbm5lY3QgKCBpbmRleCApIHtcclxuXHJcblx0XHQvLyBTa2lwIGNvbm5lY3RzIHNldCB0byBmYWxzZVxyXG5cdFx0aWYgKCAhc2NvcGVfQ29ubmVjdHNbaW5kZXhdICkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGwgPSAwO1xyXG5cdFx0dmFyIGggPSAxMDA7XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gMCApIHtcclxuXHRcdFx0bCA9IHNjb3BlX0xvY2F0aW9uc1tpbmRleCAtIDFdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggaW5kZXggIT09IHNjb3BlX0Nvbm5lY3RzLmxlbmd0aCAtIDEgKSB7XHJcblx0XHRcdGggPSBzY29wZV9Mb2NhdGlvbnNbaW5kZXhdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHNjb3BlX0Nvbm5lY3RzW2luZGV4XS5zdHlsZVtvcHRpb25zLnN0eWxlXSA9IHRvUGN0KGwpO1xyXG5cdFx0c2NvcGVfQ29ubmVjdHNbaW5kZXhdLnN0eWxlW29wdGlvbnMuc3R5bGVPcG9zaXRlXSA9IHRvUGN0KDEwMCAtIGgpO1xyXG5cdH1cclxuXHJcblx0Ly8gLi4uXHJcblx0ZnVuY3Rpb24gc2V0VmFsdWUgKCB0bywgaGFuZGxlTnVtYmVyICkge1xyXG5cclxuXHRcdC8vIFNldHRpbmcgd2l0aCBudWxsIGluZGljYXRlcyBhbiAnaWdub3JlJy5cclxuXHRcdC8vIElucHV0dGluZyAnZmFsc2UnIGlzIGludmFsaWQuXHJcblx0XHRpZiAoIHRvID09PSBudWxsIHx8IHRvID09PSBmYWxzZSApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIElmIGEgZm9ybWF0dGVkIG51bWJlciB3YXMgcGFzc2VkLCBhdHRlbXQgdG8gZGVjb2RlIGl0LlxyXG5cdFx0aWYgKCB0eXBlb2YgdG8gPT09ICdudW1iZXInICkge1xyXG5cdFx0XHR0byA9IFN0cmluZyh0byk7XHJcblx0XHR9XHJcblxyXG5cdFx0dG8gPSBvcHRpb25zLmZvcm1hdC5mcm9tKHRvKTtcclxuXHJcblx0XHQvLyBSZXF1ZXN0IGFuIHVwZGF0ZSBmb3IgYWxsIGxpbmtzIGlmIHRoZSB2YWx1ZSB3YXMgaW52YWxpZC5cclxuXHRcdC8vIERvIHNvIHRvbyBpZiBzZXR0aW5nIHRoZSBoYW5kbGUgZmFpbHMuXHJcblx0XHRpZiAoIHRvICE9PSBmYWxzZSAmJiAhaXNOYU4odG8pICkge1xyXG5cdFx0XHRzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKHRvKSwgZmFsc2UsIGZhbHNlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIFNldCB0aGUgc2xpZGVyIHZhbHVlLlxyXG5cdGZ1bmN0aW9uIHZhbHVlU2V0ICggaW5wdXQsIGZpcmVTZXRFdmVudCApIHtcclxuXHJcblx0XHR2YXIgdmFsdWVzID0gYXNBcnJheShpbnB1dCk7XHJcblx0XHR2YXIgaXNJbml0ID0gc2NvcGVfTG9jYXRpb25zWzBdID09PSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0Ly8gRXZlbnQgZmlyZXMgYnkgZGVmYXVsdFxyXG5cdFx0ZmlyZVNldEV2ZW50ID0gKGZpcmVTZXRFdmVudCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhZmlyZVNldEV2ZW50KTtcclxuXHJcblx0XHR2YWx1ZXMuZm9yRWFjaChzZXRWYWx1ZSk7XHJcblxyXG5cdFx0Ly8gQW5pbWF0aW9uIGlzIG9wdGlvbmFsLlxyXG5cdFx0Ly8gTWFrZSBzdXJlIHRoZSBpbml0aWFsIHZhbHVlcyB3ZXJlIHNldCBiZWZvcmUgdXNpbmcgYW5pbWF0ZWQgcGxhY2VtZW50LlxyXG5cdFx0aWYgKCBvcHRpb25zLmFuaW1hdGUgJiYgIWlzSW5pdCApIHtcclxuXHRcdFx0YWRkQ2xhc3NGb3Ioc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGFwLCBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBOb3cgdGhhdCBhbGwgYmFzZSB2YWx1ZXMgYXJlIHNldCwgYXBwbHkgY29uc3RyYWludHNcclxuXHRcdHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpe1xyXG5cdFx0XHRzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSwgdHJ1ZSwgZmFsc2UpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0c2V0WmluZGV4KCk7XHJcblxyXG5cdFx0c2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcil7XHJcblxyXG5cdFx0XHRmaXJlRXZlbnQoJ3VwZGF0ZScsIGhhbmRsZU51bWJlcik7XHJcblxyXG5cdFx0XHQvLyBGaXJlIHRoZSBldmVudCBvbmx5IGZvciBoYW5kbGVzIHRoYXQgcmVjZWl2ZWQgYSBuZXcgdmFsdWUsIGFzIHBlciAjNTc5XHJcblx0XHRcdGlmICggdmFsdWVzW2hhbmRsZU51bWJlcl0gIT09IG51bGwgJiYgZmlyZVNldEV2ZW50ICkge1xyXG5cdFx0XHRcdGZpcmVFdmVudCgnc2V0JywgaGFuZGxlTnVtYmVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvLyBSZXNldCBzbGlkZXIgdG8gaW5pdGlhbCB2YWx1ZXNcclxuXHRmdW5jdGlvbiB2YWx1ZVJlc2V0ICggZmlyZVNldEV2ZW50ICkge1xyXG5cdFx0dmFsdWVTZXQob3B0aW9ucy5zdGFydCwgZmlyZVNldEV2ZW50KTtcclxuXHR9XHJcblxyXG5cdC8vIEdldCB0aGUgc2xpZGVyIHZhbHVlLlxyXG5cdGZ1bmN0aW9uIHZhbHVlR2V0ICggKSB7XHJcblxyXG5cdFx0dmFyIHZhbHVlcyA9IHNjb3BlX1ZhbHVlcy5tYXAob3B0aW9ucy5mb3JtYXQudG8pO1xyXG5cclxuXHRcdC8vIElmIG9ubHkgb25lIGhhbmRsZSBpcyB1c2VkLCByZXR1cm4gYSBzaW5nbGUgdmFsdWUuXHJcblx0XHRpZiAoIHZhbHVlcy5sZW5ndGggPT09IDEgKXtcclxuXHRcdFx0cmV0dXJuIHZhbHVlc1swXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdH1cclxuXHJcblx0Ly8gUmVtb3ZlcyBjbGFzc2VzIGZyb20gdGhlIHJvb3QgYW5kIGVtcHRpZXMgaXQuXHJcblx0ZnVuY3Rpb24gZGVzdHJveSAoICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBrZXkgaW4gb3B0aW9ucy5jc3NDbGFzc2VzICkge1xyXG5cdFx0XHRpZiAoICFvcHRpb25zLmNzc0NsYXNzZXMuaGFzT3duUHJvcGVydHkoa2V5KSApIHsgY29udGludWU7IH1cclxuXHRcdFx0cmVtb3ZlQ2xhc3Moc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXNba2V5XSk7XHJcblx0XHR9XHJcblxyXG5cdFx0d2hpbGUgKHNjb3BlX1RhcmdldC5maXJzdENoaWxkKSB7XHJcblx0XHRcdHNjb3BlX1RhcmdldC5yZW1vdmVDaGlsZChzY29wZV9UYXJnZXQuZmlyc3RDaGlsZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHNjb3BlX1RhcmdldC5ub1VpU2xpZGVyO1xyXG5cdH1cclxuXHJcblx0Ly8gR2V0IHRoZSBjdXJyZW50IHN0ZXAgc2l6ZSBmb3IgdGhlIHNsaWRlci5cclxuXHRmdW5jdGlvbiBnZXRDdXJyZW50U3RlcCAoICkge1xyXG5cclxuXHRcdC8vIENoZWNrIGFsbCBsb2NhdGlvbnMsIG1hcCB0aGVtIHRvIHRoZWlyIHN0ZXBwaW5nIHBvaW50LlxyXG5cdFx0Ly8gR2V0IHRoZSBzdGVwIHBvaW50LCB0aGVuIGZpbmQgaXQgaW4gdGhlIGlucHV0IGxpc3QuXHJcblx0XHRyZXR1cm4gc2NvcGVfTG9jYXRpb25zLm1hcChmdW5jdGlvbiggbG9jYXRpb24sIGluZGV4ICl7XHJcblxyXG5cdFx0XHR2YXIgbmVhcmJ5U3RlcHMgPSBzY29wZV9TcGVjdHJ1bS5nZXROZWFyYnlTdGVwcyggbG9jYXRpb24gKTtcclxuXHRcdFx0dmFyIHZhbHVlID0gc2NvcGVfVmFsdWVzW2luZGV4XTtcclxuXHRcdFx0dmFyIGluY3JlbWVudCA9IG5lYXJieVN0ZXBzLnRoaXNTdGVwLnN0ZXA7XHJcblx0XHRcdHZhciBkZWNyZW1lbnQgPSBudWxsO1xyXG5cclxuXHRcdFx0Ly8gSWYgdGhlIG5leHQgdmFsdWUgaW4gdGhpcyBzdGVwIG1vdmVzIGludG8gdGhlIG5leHQgc3RlcCxcclxuXHRcdFx0Ly8gdGhlIGluY3JlbWVudCBpcyB0aGUgc3RhcnQgb2YgdGhlIG5leHQgc3RlcCAtIHRoZSBjdXJyZW50IHZhbHVlXHJcblx0XHRcdGlmICggaW5jcmVtZW50ICE9PSBmYWxzZSApIHtcclxuXHRcdFx0XHRpZiAoIHZhbHVlICsgaW5jcmVtZW50ID4gbmVhcmJ5U3RlcHMuc3RlcEFmdGVyLnN0YXJ0VmFsdWUgKSB7XHJcblx0XHRcdFx0XHRpbmNyZW1lbnQgPSBuZWFyYnlTdGVwcy5zdGVwQWZ0ZXIuc3RhcnRWYWx1ZSAtIHZhbHVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdC8vIElmIHRoZSB2YWx1ZSBpcyBiZXlvbmQgdGhlIHN0YXJ0aW5nIHBvaW50XHJcblx0XHRcdGlmICggdmFsdWUgPiBuZWFyYnlTdGVwcy50aGlzU3RlcC5zdGFydFZhbHVlICkge1xyXG5cdFx0XHRcdGRlY3JlbWVudCA9IG5lYXJieVN0ZXBzLnRoaXNTdGVwLnN0ZXA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGVsc2UgaWYgKCBuZWFyYnlTdGVwcy5zdGVwQmVmb3JlLnN0ZXAgPT09IGZhbHNlICkge1xyXG5cdFx0XHRcdGRlY3JlbWVudCA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBJZiBhIGhhbmRsZSBpcyBhdCB0aGUgc3RhcnQgb2YgYSBzdGVwLCBpdCBhbHdheXMgc3RlcHMgYmFjayBpbnRvIHRoZSBwcmV2aW91cyBzdGVwIGZpcnN0XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGRlY3JlbWVudCA9IHZhbHVlIC0gbmVhcmJ5U3RlcHMuc3RlcEJlZm9yZS5oaWdoZXN0U3RlcDtcclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdC8vIE5vdywgaWYgYXQgdGhlIHNsaWRlciBlZGdlcywgdGhlcmUgaXMgbm90IGluL2RlY3JlbWVudFxyXG5cdFx0XHRpZiAoIGxvY2F0aW9uID09PSAxMDAgKSB7XHJcblx0XHRcdFx0aW5jcmVtZW50ID0gbnVsbDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZWxzZSBpZiAoIGxvY2F0aW9uID09PSAwICkge1xyXG5cdFx0XHRcdGRlY3JlbWVudCA9IG51bGw7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEFzIHBlciAjMzkxLCB0aGUgY29tcGFyaXNvbiBmb3IgdGhlIGRlY3JlbWVudCBzdGVwIGNhbiBoYXZlIHNvbWUgcm91bmRpbmcgaXNzdWVzLlxyXG5cdFx0XHR2YXIgc3RlcERlY2ltYWxzID0gc2NvcGVfU3BlY3RydW0uY291bnRTdGVwRGVjaW1hbHMoKTtcclxuXHJcblx0XHRcdC8vIFJvdW5kIHBlciAjMzkxXHJcblx0XHRcdGlmICggaW5jcmVtZW50ICE9PSBudWxsICYmIGluY3JlbWVudCAhPT0gZmFsc2UgKSB7XHJcblx0XHRcdFx0aW5jcmVtZW50ID0gTnVtYmVyKGluY3JlbWVudC50b0ZpeGVkKHN0ZXBEZWNpbWFscykpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGRlY3JlbWVudCAhPT0gbnVsbCAmJiBkZWNyZW1lbnQgIT09IGZhbHNlICkge1xyXG5cdFx0XHRcdGRlY3JlbWVudCA9IE51bWJlcihkZWNyZW1lbnQudG9GaXhlZChzdGVwRGVjaW1hbHMpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIFtkZWNyZW1lbnQsIGluY3JlbWVudF07XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8vIEF0dGFjaCBhbiBldmVudCB0byB0aGlzIHNsaWRlciwgcG9zc2libHkgaW5jbHVkaW5nIGEgbmFtZXNwYWNlXHJcblx0ZnVuY3Rpb24gYmluZEV2ZW50ICggbmFtZXNwYWNlZEV2ZW50LCBjYWxsYmFjayApIHtcclxuXHRcdHNjb3BlX0V2ZW50c1tuYW1lc3BhY2VkRXZlbnRdID0gc2NvcGVfRXZlbnRzW25hbWVzcGFjZWRFdmVudF0gfHwgW107XHJcblx0XHRzY29wZV9FdmVudHNbbmFtZXNwYWNlZEV2ZW50XS5wdXNoKGNhbGxiYWNrKTtcclxuXHJcblx0XHQvLyBJZiB0aGUgZXZlbnQgYm91bmQgaXMgJ3VwZGF0ZSwnIGZpcmUgaXQgaW1tZWRpYXRlbHkgZm9yIGFsbCBoYW5kbGVzLlxyXG5cdFx0aWYgKCBuYW1lc3BhY2VkRXZlbnQuc3BsaXQoJy4nKVswXSA9PT0gJ3VwZGF0ZScgKSB7XHJcblx0XHRcdHNjb3BlX0hhbmRsZXMuZm9yRWFjaChmdW5jdGlvbihhLCBpbmRleCl7XHJcblx0XHRcdFx0ZmlyZUV2ZW50KCd1cGRhdGUnLCBpbmRleCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gVW5kbyBhdHRhY2htZW50IG9mIGV2ZW50XHJcblx0ZnVuY3Rpb24gcmVtb3ZlRXZlbnQgKCBuYW1lc3BhY2VkRXZlbnQgKSB7XHJcblxyXG5cdFx0dmFyIGV2ZW50ID0gbmFtZXNwYWNlZEV2ZW50ICYmIG5hbWVzcGFjZWRFdmVudC5zcGxpdCgnLicpWzBdO1xyXG5cdFx0dmFyIG5hbWVzcGFjZSA9IGV2ZW50ICYmIG5hbWVzcGFjZWRFdmVudC5zdWJzdHJpbmcoZXZlbnQubGVuZ3RoKTtcclxuXHJcblx0XHRPYmplY3Qua2V5cyhzY29wZV9FdmVudHMpLmZvckVhY2goZnVuY3Rpb24oIGJpbmQgKXtcclxuXHJcblx0XHRcdHZhciB0RXZlbnQgPSBiaW5kLnNwbGl0KCcuJylbMF0sXHJcblx0XHRcdFx0dE5hbWVzcGFjZSA9IGJpbmQuc3Vic3RyaW5nKHRFdmVudC5sZW5ndGgpO1xyXG5cclxuXHRcdFx0aWYgKCAoIWV2ZW50IHx8IGV2ZW50ID09PSB0RXZlbnQpICYmICghbmFtZXNwYWNlIHx8IG5hbWVzcGFjZSA9PT0gdE5hbWVzcGFjZSkgKSB7XHJcblx0XHRcdFx0ZGVsZXRlIHNjb3BlX0V2ZW50c1tiaW5kXTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvLyBVcGRhdGVhYmxlOiBtYXJnaW4sIGxpbWl0LCBwYWRkaW5nLCBzdGVwLCByYW5nZSwgYW5pbWF0ZSwgc25hcFxyXG5cdGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMgKCBvcHRpb25zVG9VcGRhdGUsIGZpcmVTZXRFdmVudCApIHtcclxuXHJcblx0XHQvLyBTcGVjdHJ1bSBpcyBjcmVhdGVkIHVzaW5nIHRoZSByYW5nZSwgc25hcCwgZGlyZWN0aW9uIGFuZCBzdGVwIG9wdGlvbnMuXHJcblx0XHQvLyAnc25hcCcgYW5kICdzdGVwJyBjYW4gYmUgdXBkYXRlZCwgJ2RpcmVjdGlvbicgY2Fubm90LCBkdWUgdG8gZXZlbnQgYmluZGluZy5cclxuXHRcdC8vIElmICdzbmFwJyBhbmQgJ3N0ZXAnIGFyZSBub3QgcGFzc2VkLCB0aGV5IHNob3VsZCByZW1haW4gdW5jaGFuZ2VkLlxyXG5cdFx0dmFyIHYgPSB2YWx1ZUdldCgpO1xyXG5cclxuXHRcdHZhciB1cGRhdGVBYmxlID0gWydtYXJnaW4nLCAnbGltaXQnLCAncGFkZGluZycsICdyYW5nZScsICdhbmltYXRlJywgJ3NuYXAnLCAnc3RlcCcsICdmb3JtYXQnXTtcclxuXHJcblx0XHQvLyBPbmx5IGNoYW5nZSBvcHRpb25zIHRoYXQgd2UncmUgYWN0dWFsbHkgcGFzc2VkIHRvIHVwZGF0ZS5cclxuXHRcdHVwZGF0ZUFibGUuZm9yRWFjaChmdW5jdGlvbihuYW1lKXtcclxuXHRcdFx0aWYgKCBvcHRpb25zVG9VcGRhdGVbbmFtZV0gIT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHRvcmlnaW5hbE9wdGlvbnNbbmFtZV0gPSBvcHRpb25zVG9VcGRhdGVbbmFtZV07XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHZhciBuZXdPcHRpb25zID0gdGVzdE9wdGlvbnMob3JpZ2luYWxPcHRpb25zKTtcclxuXHJcblx0XHQvLyBMb2FkIG5ldyBvcHRpb25zIGludG8gdGhlIHNsaWRlciBzdGF0ZVxyXG5cdFx0dXBkYXRlQWJsZS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpe1xyXG5cdFx0XHRpZiAoIG9wdGlvbnNUb1VwZGF0ZVtuYW1lXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdG9wdGlvbnNbbmFtZV0gPSBuZXdPcHRpb25zW25hbWVdO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBTYXZlIGN1cnJlbnQgc3BlY3RydW0gZGlyZWN0aW9uIGFzIHRlc3RPcHRpb25zIGluIHRlc3RSYW5nZSBjYWxsXHJcblx0XHQvLyBkb2Vzbid0IHJlbHkgb24gY3VycmVudCBkaXJlY3Rpb25cclxuXHRcdG5ld09wdGlvbnMuc3BlY3RydW0uZGlyZWN0aW9uID0gc2NvcGVfU3BlY3RydW0uZGlyZWN0aW9uO1xyXG5cdFx0c2NvcGVfU3BlY3RydW0gPSBuZXdPcHRpb25zLnNwZWN0cnVtO1xyXG5cclxuXHRcdC8vIExpbWl0LCBtYXJnaW4gYW5kIHBhZGRpbmcgZGVwZW5kIG9uIHRoZSBzcGVjdHJ1bSBidXQgYXJlIHN0b3JlZCBvdXRzaWRlIG9mIGl0LiAoIzY3NylcclxuXHRcdG9wdGlvbnMubWFyZ2luID0gbmV3T3B0aW9ucy5tYXJnaW47XHJcblx0XHRvcHRpb25zLmxpbWl0ID0gbmV3T3B0aW9ucy5saW1pdDtcclxuXHRcdG9wdGlvbnMucGFkZGluZyA9IG5ld09wdGlvbnMucGFkZGluZztcclxuXHJcblx0XHQvLyBJbnZhbGlkYXRlIHRoZSBjdXJyZW50IHBvc2l0aW9uaW5nIHNvIHZhbHVlU2V0IGZvcmNlcyBhbiB1cGRhdGUuXHJcblx0XHRzY29wZV9Mb2NhdGlvbnMgPSBbXTtcclxuXHRcdHZhbHVlU2V0KG9wdGlvbnNUb1VwZGF0ZS5zdGFydCB8fCB2LCBmaXJlU2V0RXZlbnQpO1xyXG5cdH1cclxuXHJcblx0Ly8gVGhyb3cgYW4gZXJyb3IgaWYgdGhlIHNsaWRlciB3YXMgYWxyZWFkeSBpbml0aWFsaXplZC5cclxuXHRpZiAoIHNjb3BlX1RhcmdldC5ub1VpU2xpZGVyICkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiBTbGlkZXIgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXCIpO1xyXG5cdH1cclxuXHJcblx0Ly8gQ3JlYXRlIHRoZSBiYXNlIGVsZW1lbnQsIGluaXRpYWxpc2UgSFRNTCBhbmQgc2V0IGNsYXNzZXMuXHJcblx0Ly8gQWRkIGhhbmRsZXMgYW5kIGNvbm5lY3QgZWxlbWVudHMuXHJcblx0YWRkU2xpZGVyKHNjb3BlX1RhcmdldCk7XHJcblx0YWRkRWxlbWVudHMob3B0aW9ucy5jb25uZWN0LCBzY29wZV9CYXNlKTtcclxuXHJcblx0c2NvcGVfU2VsZiA9IHtcclxuXHRcdGRlc3Ryb3k6IGRlc3Ryb3ksXHJcblx0XHRzdGVwczogZ2V0Q3VycmVudFN0ZXAsXHJcblx0XHRvbjogYmluZEV2ZW50LFxyXG5cdFx0b2ZmOiByZW1vdmVFdmVudCxcclxuXHRcdGdldDogdmFsdWVHZXQsXHJcblx0XHRzZXQ6IHZhbHVlU2V0LFxyXG5cdFx0cmVzZXQ6IHZhbHVlUmVzZXQsXHJcblx0XHQvLyBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcsIGRvbid0IHVzZSB0aGlzIGluIHlvdXIgYXBwbGljYXRpb24uXHJcblx0XHRfX21vdmVIYW5kbGVzOiBmdW5jdGlvbihhLCBiLCBjKSB7IG1vdmVIYW5kbGVzKGEsIGIsIHNjb3BlX0xvY2F0aW9ucywgYyk7IH0sXHJcblx0XHRvcHRpb25zOiBvcmlnaW5hbE9wdGlvbnMsIC8vIElzc3VlICM2MDAsICM2NzhcclxuXHRcdHVwZGF0ZU9wdGlvbnM6IHVwZGF0ZU9wdGlvbnMsXHJcblx0XHR0YXJnZXQ6IHNjb3BlX1RhcmdldCwgLy8gSXNzdWUgIzU5N1xyXG5cdFx0cGlwczogcGlwcyAvLyBJc3N1ZSAjNTk0XHJcblx0fTtcclxuXHJcblx0Ly8gQXR0YWNoIHVzZXIgZXZlbnRzLlxyXG5cdGJpbmRTbGlkZXJFdmVudHMob3B0aW9ucy5ldmVudHMpO1xyXG5cclxuXHQvLyBVc2UgdGhlIHB1YmxpYyB2YWx1ZSBtZXRob2QgdG8gc2V0IHRoZSBzdGFydCB2YWx1ZXMuXHJcblx0dmFsdWVTZXQob3B0aW9ucy5zdGFydCk7XHJcblxyXG5cdGlmICggb3B0aW9ucy5waXBzICkge1xyXG5cdFx0cGlwcyhvcHRpb25zLnBpcHMpO1xyXG5cdH1cclxuXHJcblx0aWYgKCBvcHRpb25zLnRvb2x0aXBzICkge1xyXG5cdFx0dG9vbHRpcHMoKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBzY29wZV9TZWxmO1xyXG5cclxufVxyXG5cclxuXHJcblx0Ly8gUnVuIHRoZSBzdGFuZGFyZCBpbml0aWFsaXplclxyXG5cdGZ1bmN0aW9uIGluaXRpYWxpemUgKCB0YXJnZXQsIG9yaWdpbmFsT3B0aW9ucyApIHtcclxuXHJcblx0XHRpZiAoICF0YXJnZXQubm9kZU5hbWUgKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogY3JlYXRlIHJlcXVpcmVzIGEgc2luZ2xlIGVsZW1lbnQuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRlc3QgdGhlIG9wdGlvbnMgYW5kIGNyZWF0ZSB0aGUgc2xpZGVyIGVudmlyb25tZW50O1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0ZXN0T3B0aW9ucyggb3JpZ2luYWxPcHRpb25zLCB0YXJnZXQgKTtcclxuXHRcdHZhciBhcGkgPSBjbG9zdXJlKCB0YXJnZXQsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucyApO1xyXG5cclxuXHRcdHRhcmdldC5ub1VpU2xpZGVyID0gYXBpO1xyXG5cclxuXHRcdHJldHVybiBhcGk7XHJcblx0fVxyXG5cclxuXHQvLyBVc2UgYW4gb2JqZWN0IGluc3RlYWQgb2YgYSBmdW5jdGlvbiBmb3IgZnV0dXJlIGV4cGFuc2liaWxpdHk7XHJcblx0cmV0dXJuIHtcclxuXHRcdHZlcnNpb246IFZFUlNJT04sXHJcblx0XHRjcmVhdGU6IGluaXRpYWxpemVcclxuXHR9O1xyXG5cclxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ub3Vpc2xpZGVyL2Rpc3RyaWJ1dGUvbm91aXNsaWRlci5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _board = __webpack_require__(0);\n\nvar _board2 = _interopRequireDefault(_board);\n\nvar _main = __webpack_require__(1);\n\nvar _main2 = _interopRequireDefault(_main);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.init = function () {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (!options.output) return console.warn('no output values');\n\n  options.dest = options.dest || '/thumbnail';\n  options.board = options.board || {};\n  options.board.side = options.board.side || 500;\n  options.clip = options.clip || {};\n  options.clip = {\n    s: options.clip.s || 'rgba(0,0,0,0.8)'\n  };\n\n  var pccp = document.getElementById('pccp');\n  if (!pccp) return;\n\n  var board = (0, _board2.default)(pccp, options);\n\n  var dropbox = board.dropbox,\n      preview = board.preview;\n\n\n  var load = function load() {\n\n    var raw = new Image();\n    var file = dropbox.files[0];\n\n    raw.addEventListener('load', function () {\n      preview.addEventListener('load', function main() {\n        (0, _main2.default)(raw, board, options);\n        preview.removeEventListener('load', main, false);\n      }, false);\n      preview.src = URL.createObjectURL(file);\n    }, false);\n\n    raw.src = URL.createObjectURL(file);\n  };\n\n  dropbox.addEventListener('change', load);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwLmpzPzdhYzkiXSwibmFtZXMiOlsiZXhwb3J0cyIsImluaXQiLCJvcHRpb25zIiwib3V0cHV0IiwiY29uc29sZSIsIndhcm4iLCJkZXN0IiwiYm9hcmQiLCJzaWRlIiwiY2xpcCIsInMiLCJwY2NwIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImRyb3Bib3giLCJwcmV2aWV3IiwibG9hZCIsInJhdyIsIkltYWdlIiwiZmlsZSIsImZpbGVzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm1haW4iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic3JjIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIl0sIm1hcHBpbmdzIjoiOztBQUFBOzs7O0FBQ0E7Ozs7OztBQUVBQSxRQUFRQyxJQUFSLEdBQWUsWUFBa0I7QUFBQSxNQUFqQkMsT0FBaUIsdUVBQVAsRUFBTzs7QUFDL0IsTUFBSSxDQUFDQSxRQUFRQyxNQUFiLEVBQXFCLE9BQU9DLFFBQVFDLElBQVIsQ0FBYSxrQkFBYixDQUFQOztBQUVyQkgsVUFBUUksSUFBUixHQUFlSixRQUFRSSxJQUFSLElBQWdCLFlBQS9CO0FBQ0FKLFVBQVFLLEtBQVIsR0FBZ0JMLFFBQVFLLEtBQVIsSUFBaUIsRUFBakM7QUFDQUwsVUFBUUssS0FBUixDQUFjQyxJQUFkLEdBQXFCTixRQUFRSyxLQUFSLENBQWNDLElBQWQsSUFBc0IsR0FBM0M7QUFDQU4sVUFBUU8sSUFBUixHQUFlUCxRQUFRTyxJQUFSLElBQWdCLEVBQS9CO0FBQ0FQLFVBQVFPLElBQVIsR0FBZTtBQUNiQyxPQUFHUixRQUFRTyxJQUFSLENBQWFDLENBQWIsSUFBa0I7QUFEUixHQUFmOztBQUlBLE1BQU1DLE9BQU9DLFNBQVNDLGNBQVQsQ0FBd0IsTUFBeEIsQ0FBYjtBQUNBLE1BQUksQ0FBQ0YsSUFBTCxFQUFXOztBQUVYLE1BQU1KLFFBQVEscUJBQU1JLElBQU4sRUFBWVQsT0FBWixDQUFkOztBQWQrQixNQWdCdkJZLE9BaEJ1QixHQWdCRlAsS0FoQkUsQ0FnQnZCTyxPQWhCdUI7QUFBQSxNQWdCZEMsT0FoQmMsR0FnQkZSLEtBaEJFLENBZ0JkUSxPQWhCYzs7O0FBa0IvQixNQUFNQyxPQUFPLFNBQVBBLElBQU8sR0FBTTs7QUFFakIsUUFBTUMsTUFBTSxJQUFJQyxLQUFKLEVBQVo7QUFDQSxRQUFNQyxPQUFPTCxRQUFRTSxLQUFSLENBQWMsQ0FBZCxDQUFiOztBQUVBSCxRQUFJSSxnQkFBSixDQUFxQixNQUFyQixFQUE2QixZQUFNO0FBQ2pDTixjQUFRTSxnQkFBUixDQUF5QixNQUF6QixFQUFpQyxTQUFTQyxJQUFULEdBQWdCO0FBQy9DLDRCQUFLTCxHQUFMLEVBQVVWLEtBQVYsRUFBaUJMLE9BQWpCO0FBQ0FhLGdCQUFRUSxtQkFBUixDQUE0QixNQUE1QixFQUFvQ0QsSUFBcEMsRUFBMEMsS0FBMUM7QUFDRCxPQUhELEVBR0csS0FISDtBQUlBUCxjQUFRUyxHQUFSLEdBQWNDLElBQUlDLGVBQUosQ0FBb0JQLElBQXBCLENBQWQ7QUFDRCxLQU5ELEVBTUcsS0FOSDs7QUFRQUYsUUFBSU8sR0FBSixHQUFVQyxJQUFJQyxlQUFKLENBQW9CUCxJQUFwQixDQUFWO0FBQ0QsR0FkRDs7QUFnQkFMLFVBQVFPLGdCQUFSLENBQXlCLFFBQXpCLEVBQW1DTCxJQUFuQztBQUNELENBbkNEIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJvYXJkIGZyb20gJy4vYm9hcmQnXG5pbXBvcnQgTWFpbiBmcm9tICcuL21haW4nXG5cbmV4cG9ydHMuaW5pdCA9IChvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKCFvcHRpb25zLm91dHB1dCkgcmV0dXJuIGNvbnNvbGUud2Fybignbm8gb3V0cHV0IHZhbHVlcycpXG5cbiAgb3B0aW9ucy5kZXN0ID0gb3B0aW9ucy5kZXN0IHx8ICcvdGh1bWJuYWlsJ1xuICBvcHRpb25zLmJvYXJkID0gb3B0aW9ucy5ib2FyZCB8fCB7fVxuICBvcHRpb25zLmJvYXJkLnNpZGUgPSBvcHRpb25zLmJvYXJkLnNpZGUgfHwgNTAwXG4gIG9wdGlvbnMuY2xpcCA9IG9wdGlvbnMuY2xpcCB8fCB7fVxuICBvcHRpb25zLmNsaXAgPSB7XG4gICAgczogb3B0aW9ucy5jbGlwLnMgfHwgJ3JnYmEoMCwwLDAsMC44KScsXG4gIH1cblxuICBjb25zdCBwY2NwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BjY3AnKVxuICBpZiAoIXBjY3ApIHJldHVyblxuXG4gIGNvbnN0IGJvYXJkID0gQm9hcmQocGNjcCwgb3B0aW9ucylcblxuICBjb25zdCB7IGRyb3Bib3gsIHByZXZpZXcgfSA9IGJvYXJkXG5cbiAgY29uc3QgbG9hZCA9ICgpID0+IHtcblxuICAgIGNvbnN0IHJhdyA9IG5ldyBJbWFnZSgpXG4gICAgY29uc3QgZmlsZSA9IGRyb3Bib3guZmlsZXNbMF1cblxuICAgIHJhdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgcHJldmlldy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gbWFpbigpIHtcbiAgICAgICAgTWFpbihyYXcsIGJvYXJkLCBvcHRpb25zKVxuICAgICAgICBwcmV2aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBtYWluLCBmYWxzZSlcbiAgICAgIH0sIGZhbHNlKVxuICAgICAgcHJldmlldy5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpXG4gICAgfSwgZmFsc2UpXG5cbiAgICByYXcuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKVxuICB9XG5cbiAgZHJvcGJveC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBsb2FkKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwcC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ })
/******/ ]);